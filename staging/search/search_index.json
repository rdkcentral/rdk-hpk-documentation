{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RDK Hardware Porting Kit (HPK)","text":"<p>The RDK Hardware Porting Kit (HPK) provides a centralized resource for vendors integrating their hardware layer with the RDK stack.  It simplifies this process by providing a unified set of tools, documentation, and test suites.</p> <p>Specifically, the HPK includes:</p> <ul> <li>Hardware Abstraction Layer (HAL) API header files: These define the interfaces vendors must implement to ensure compatibility.</li> <li>Comprehensive software tests: These validate the vendor's HAL implementation against RDK middleware requirements.</li> <li>Standards &amp; Best Practices: Guidelines on coding standards, documentation, branching strategies, and interface development.</li> <li>Testing Methodologies: Outlines various testing levels and frameworks, including TDD and system interface testing.</li> <li>Code Examples &amp; Advanced Topics: Practical examples for dynamic library loading, plugin development, virtual device development, and control plane overviews.</li> <li>FAQ &amp; Troubleshooting: Addresses common challenges related to Git, Vagrant, C macros, testing, and RDK tools.</li> <li>Technology Overviews: Explains key technologies and frameworks like UT-Core and the RDK Docker toolchain.</li> <li>vDevice Support:  Provides the ability to develop and test vendor layers using virtualized hardware within a VM.  This \"vDevice\" approach simulates hardware components and drivers, enabling early testing, cost-effectiveness, reproducibility, and flexibility.  It allows developers to test against various hardware profiles without needing physical hardware.</li> </ul> <p>The HPK serves as a single point of reference, streamlining vendor integration, reducing redundant effort, and promoting consistency across RDK platforms. It accelerates hardware enablement and improves the quality of the RDK ecosystem.</p> <p></p>"},{"location":"external_content/deepsleep_manager/","title":"Deep Sleep Manager HAL Documentation","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Sequence Diagram</li> </ul>"},{"location":"external_content/deepsleep_manager/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>:    Hardware Abstraction Layer</li> <li><code>CPE</code>:    Customer Premises Equipment</li> <li><code>IR</code>:     InfraRed</li> <li><code>CEC</code>:    Consumer Electronic Control</li> <li><code>LAN</code>:    Local Area Network</li> <li><code>STB</code>:    Set-top Box</li> <li><code>RCU</code>:    Remote Control Unit</li> <li><code>STR</code>:    Suspend To RAM</li> <li><code>HDMI</code>:   High-Definition Multimedia Interface</li> <li><code>GPIO</code>:   General Purpose Input/OutputManufacturers</li> <li><code>A/V</code>:    Audio/Video</li> <li><code>HDD</code>:    Hard Drive Disk</li> </ul>"},{"location":"external_content/deepsleep_manager/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the module stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Deep Sleep Manager HAL];\nx[Deep Sleep Manager HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>The Deep Sleep Manager <code>HAL</code> provides a set of <code>APIs</code> to initialize, set the deep sleep state and wake-up from deep sleep state.</p> <p>Deep sleep is a power saving mode which turns off <code>STB</code> subsystems such as A/V, <code>HDMI</code>, front panels, <code>HDD</code> etc.</p> <ul> <li>The main purpose is to bring down the power consumption based on the actual usage. Also, the conditions for triggering and setting deep sleep mode will depend on the product requirements.</li> <li>It can also be triggered in other scenarios such as thermal shutdown, in case the temperature is above the threshold for a certain period of time.</li> <li>When the <code>STB</code> goes into deep sleep mode, it may be woken up for scheduled maintenance in a pre-determined time.</li> </ul>"},{"location":"external_content/deepsleep_manager/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":""},{"location":"external_content/deepsleep_manager/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>PLAT_DS_INIT()</code> before calling any other <code>API</code>.</p>"},{"location":"external_content/deepsleep_manager/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code>, while invoking these <code>HAL</code> <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/deepsleep_manager/#process-model","title":"Process Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code>, while invoking these <code>HAL</code> <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/deepsleep_manager/#memory-model","title":"Memory Model","text":"<p>The <code>caller</code> is responsible to pass message buffer and free it for transmit request.</p>"},{"location":"external_content/deepsleep_manager/#power-management-requirements","title":"Power Management Requirements","text":"<p>The Deep sleep manager <code>HAL</code> is involved in the power management operation:</p> <ul> <li>Transitions to Deep Sleep state which puts system into halt</li> <li>Wake up the system from deep sleep state by IR/RF, Bluetooth remote or through LAN wake-up based on the platform requirements</li> </ul>"},{"location":"external_content/deepsleep_manager/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface is not required to support asynchronous notification.</p>"},{"location":"external_content/deepsleep_manager/#blocking-calls","title":"Blocking calls","text":"<p>The following <code>APIs</code> are the blocking calls of this module:</p> <ul> <li>PLAT_DS_SetDeepSleep()</li> </ul> <p>This <code>API</code> call puts the system into halt state</p> <ul> <li>PLAT_DS_DeepSleepWakeup()</li> </ul> <p>This <code>API</code> call brings the system out of the halt state</p> <p>All other synchronous <code>API</code> calls must complete within a reasonable time period. Any call that can fail due to the lack of response from the connected device must have a timeout period and the function must return the relevant error code.</p>"},{"location":"external_content/deepsleep_manager/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/deepsleep_manager/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/deepsleep_manager/#non-functional-requirements","title":"Non functional requirements","text":""},{"location":"external_content/deepsleep_manager/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/deepsleep_manager/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and CPU utilization.</p>"},{"location":"external_content/deepsleep_manager/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/deepsleep_manager/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/deepsleep_manager/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library and must be named as <code>libiarmmgrs-deepsleep-hal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/deepsleep_manager/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</p>"},{"location":"external_content/deepsleep_manager/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/deepsleep_manager/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header files.</p>"},{"location":"external_content/deepsleep_manager/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ul> <li> <p>Initialize the <code>HAL</code> using function: <code>PLAT_DS_INIT()</code> before making any other <code>API</code> calls.  If <code>PLAT_DS_INIT()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation</p> </li> <li> <p>Deep sleep state can be controlled using the function <code>PLAT_DS_SetDeepSleep()</code></p> </li> <li> <p>Any post-processing after wake up can be performed using the function <code>PLAT_DS_DeepSleepWakeup()</code></p> </li> <li> <p>Reason for last wake up can be queried using the function <code>PLAT_DS_GetLastWakeupReason()</code></p> </li> <li> <p>Reason for last wake up keycode can be queried using the function <code>PLAT_DS_GetLastWakeupKeyCode()</code></p> </li> <li> <p>De-initialize the <code>HAL</code> using the function: <code>PLAT_DS_TERM()</code></p> </li> </ul>"},{"location":"external_content/deepsleep_manager/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as Deep Sleep Manager HAL\n    participant Driver as HAL Device Control/Driver\n    Caller-&gt;&gt;HAL:PLAT_DS_INIT()\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_SetDeepSleep()\n    Note over HAL: Deep sleep is set using this call\n    HAL-&gt;&gt;Driver: Set Deepsleep\n    Driver--&gt;&gt;HAL: Return\n    HAL--&gt;&gt;HAL: Waiting for device to sleep.\n    Note over HAL: After few seconds CPU will freeze for all modules here\n    Driver--&gt;&gt;Driver: Wake up trigger. (IR, CEC, etc)\n    Note over HAL: CPU resumes for all modules\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_DeepSleepWakeup()\n    Note over HAL: Set the platform status after deepsleep wake-up.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_GetLastWakeupReason()\n    Note over HAL: Reason for last wake up is returned using this call\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_GetLastWakeupKeyCode()\n    Note over HAL: Reason for last wake up keycode is returned using this call\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:PLAT_DS_TERM()\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/deepsleep_manager/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/deepsleep_manager/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/deepsleep_manager/CHANGELOG/#104","title":"1.0.4","text":"<ul> <li>gh #4 Update based on L2 review discussions <code>#6</code></li> <li>post condation is added for plat_ds_init in the interface file <code>d246c28</code></li> <li>Changes based on L2 test discussion <code>c981a13</code></li> <li>Merge tag '1.0.3' into develop <code>70956e3</code></li> </ul>"},{"location":"external_content/deepsleep_manager/CHANGELOG/#103","title":"1.0.3","text":"<p>13 November 2023</p> <ul> <li>Bumped CHANGELOG.md - 1.0.3 <code>aa12921</code></li> <li>Updated License file name in header <code>ee0ea56</code></li> <li>Merge tag '1.0.2' into develop <code>657d8e9</code></li> </ul>"},{"location":"external_content/deepsleep_manager/CHANGELOG/#102","title":"1.0.2","text":"<p>9 November 2023</p> <ul> <li>updated build_ut &amp; gitignore <code>#1</code></li> <li>baseline version <code>80e3d29</code></li> <li>Added CHANGELOG.md - 1.0.2 <code>8183022</code></li> <li>Initial commit <code>b6e8db9</code></li> </ul>"},{"location":"external_content/deepsleep_manager/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/","title":"Deep Sleep Manager HAL Documentation","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Sequence Diagram</li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>:    Hardware Abstraction Layer</li> <li><code>CPE</code>:    Customer Premises Equipment</li> <li><code>IR</code>:     InfraRed</li> <li><code>CEC</code>:    Consumer Electronic Control</li> <li><code>LAN</code>:    Local Area Network</li> <li><code>STB</code>:    Set-top Box</li> <li><code>RCU</code>:    Remote Control Unit</li> <li><code>STR</code>:    Suspend To RAM</li> <li><code>HDMI</code>:   High-Definition Multimedia Interface</li> <li><code>GPIO</code>:   General Purpose Input/OutputManufacturers</li> <li><code>A/V</code>:    Audio/Video</li> <li><code>HDD</code>:    Hard Drive Disk</li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the module stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Deep Sleep Manager HAL];\nx[Deep Sleep Manager HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>The Deep Sleep Manager <code>HAL</code> provides a set of <code>APIs</code> to initialize, set the deep sleep state and wake-up from deep sleep state.</p> <p>Deep sleep is a power saving mode which turns off <code>STB</code> subsystems such as A/V, <code>HDMI</code>, front panels, <code>HDD</code> etc.</p> <ul> <li>The main purpose is to bring down the power consumption based on the actual usage. Also, the conditions for triggering and setting deep sleep mode will depend on the product requirements.</li> <li>It can also be triggered in other scenarios such as thermal shutdown, in case the temperature is above the threshold for a certain period of time.</li> <li>When the <code>STB</code> goes into deep sleep mode, it may be woken up for scheduled maintenance in a pre-determined time.</li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":""},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>PLAT_DS_INIT()</code> before calling any other <code>API</code>.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code>, while invoking these <code>HAL</code> <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#process-model","title":"Process Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code>, while invoking these <code>HAL</code> <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#memory-model","title":"Memory Model","text":"<p>The <code>caller</code> is responsible to pass message buffer and free it for transmit request.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>The Deep sleep manager <code>HAL</code> is involved in the power management operation:</p> <ul> <li>Transitions to Deep Sleep state which puts system into halt</li> <li>Wake up the system from deep sleep state by IR/RF, Bluetooth remote or through LAN wake-up based on the platform requirements</li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface is not required to support asynchronous notification.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>The following <code>APIs</code> are the blocking calls of this module:</p> <ul> <li>PLAT_DS_SetDeepSleep()</li> </ul> <p>This <code>API</code> call puts the system into halt state</p> <ul> <li>PLAT_DS_DeepSleepWakeup()</li> </ul> <p>This <code>API</code> call brings the system out of the halt state</p> <p>All other synchronous <code>API</code> calls must complete within a reasonable time period. Any call that can fail due to the lack of response from the connected device must have a timeout period and the function must return the relevant error code.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#non-functional-requirements","title":"Non functional requirements","text":""},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and CPU utilization.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library and must be named as <code>libiarmmgrs-deepsleep-hal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header files.</p>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ul> <li> <p>Initialize the <code>HAL</code> using function: <code>PLAT_DS_INIT()</code> before making any other <code>API</code> calls.  If <code>PLAT_DS_INIT()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation</p> </li> <li> <p>Deep sleep state can be controlled using the function <code>PLAT_DS_SetDeepSleep()</code></p> </li> <li> <p>Any post-processing after wake up can be performed using the function <code>PLAT_DS_DeepSleepWakeup()</code></p> </li> <li> <p>Reason for last wake up can be queried using the function <code>PLAT_DS_GetLastWakeupReason()</code></p> </li> <li> <p>Reason for last wake up keycode can be queried using the function <code>PLAT_DS_GetLastWakeupKeyCode()</code></p> </li> <li> <p>De-initialize the <code>HAL</code> using the function: <code>PLAT_DS_TERM()</code></p> </li> </ul>"},{"location":"external_content/deepsleep_manager/docs/pages/deepsleep-manager_halSpec/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as Deep Sleep Manager HAL\n    participant Driver as HAL Device Control/Driver\n    Caller-&gt;&gt;HAL:PLAT_DS_INIT()\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_SetDeepSleep()\n    Note over HAL: Deep sleep is set using this call\n    HAL-&gt;&gt;Driver: Set Deepsleep\n    Driver--&gt;&gt;HAL: Return\n    HAL--&gt;&gt;HAL: Waiting for device to sleep.\n    Note over HAL: After few seconds CPU will freeze for all modules here\n    Driver--&gt;&gt;Driver: Wake up trigger. (IR, CEC, etc)\n    Note over HAL: CPU resumes for all modules\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_DeepSleepWakeup()\n    Note over HAL: Set the platform status after deepsleep wake-up.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_GetLastWakeupReason()\n    Note over HAL: Reason for last wake up is returned using this call\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_DS_GetLastWakeupKeyCode()\n    Note over HAL: Reason for last wake up keycode is returned using this call\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:PLAT_DS_TERM()\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/deepsleep_manager_test/","title":"Unit Testing Suite For Deep Sleep Manager HAL","text":""},{"location":"external_content/deepsleep_manager_test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Reference Documents</li> <li>Notes</li> </ul>"},{"location":"external_content/deepsleep_manager_test/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>- Hardware Abstraction Layer</li> <li><code>L1</code> - Functional Tests</li> <li><code>L2</code> - Module functional Testing</li> <li><code>L3</code> - Module testing with External Stimulus is required to validate and control device</li> <li><code>High-Level Test Specification</code> : These specification will provide a broad overview of the system's functionality from the callers' perspective. It focuses on major use cases, system behavior, and overall caller experience.</li> <li><code>Low-Level Test Specification</code> : These specification will delve deeper into the technical details. They will define specific test cases with inputs, expected outputs, and pass/fail criteria for individual functionalities, modules, or APIs.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/#description","title":"Description","text":"<p>This repository contains the Unit Test Suites (L1, L2 &amp; L3) for Deep Sleep Manager <code>HAL</code>.</p>"},{"location":"external_content/deepsleep_manager_test/#reference-documents","title":"Reference Documents","text":"SNo Document Name Document Description Document Link 1 <code>HAL</code> Specification Document This document provides specific information on the APIs for which tests are written in this module deepsleep-manager_halSpec.md 2 High Level Test Specification Document High Level Test Specification Documentation this module deep-sleep-manager_High-Level_TestSpec.md 3 <code>L2</code> Low Level Test Specification Document <code>L2</code>Low Level Test Specification Documentation this module deep-sleep-manager_L2-Low-Level_TestSpec.md 4 <code>L3</code> Low Level Test Spec <code>L3</code> Low Level Test Specification deep-sleep-manager_L3-Low-Level_TestSpec.md 5 <code>L3</code> Test Procedure Document <code>L3</code> Test Procedure Document deep-sleep-manager_L3_TestProcedure.md"},{"location":"external_content/deepsleep_manager_test/#notes","title":"Notes","text":"<ul> <li>All APIs need to be implemented in this current version. If any API is not supported, please add stub implementation with return type DEEPSLEEPMGR_SUCCESS for the same.</li> <li>Building against the actual library may introduce <code>SOC</code> dependencies. Hence, a template SKELETON library is created without <code>SOC</code> dependencies. On the real platform (target), it can be mounted, copied and bound with the actual library.</li> <li>When executing the binary, ensure to include a platform-specific profile file as an argument for the designated test cases. The following example illustrates this:</li> </ul> <p><code>bash ./hal_test -p deepsleepmanagerExtendedEnumsNotSupported.yaml</code></p> <p>Alternatively, use the run.sh script with the profile file:</p> <p><code>bash ./run.sh -p /absolute/path/to/profile/file</code></p> <ul> <li>Profiles file available in here</li> <li>Install Python Environment and Activation Scripts please check the HPK Documentation</li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#130","title":"1.3.0","text":"<ul> <li>gh #24 deepsleep: L3 Test case Development <code>#25</code></li> <li>gh #26 Updating the utcore version to 4.x <code>#27</code></li> <li>gh #19 deepsleep: L3 Test case Development <code>#20</code></li> <li>gh #21 initial l3 layout <code>#22</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#123","title":"1.2.3","text":"<p>3 September 2024</p> <ul> <li>gh #17 Deep Sleep Timer value check  <code>#18</code></li> <li>gh #17 Deepsleep timer limit check <code>618a24f</code></li> <li>Bumped CHANGELOG.md - 1.2.3 <code>abe3231</code></li> <li>Merge tag '1.2.2' into develop <code>6774246</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#122","title":"1.2.2","text":"<p>13 August 2024</p> <ul> <li>gh #15 Update the run.sh script &amp; README.md <code>#16</code></li> <li>Bumped CHANGELOG.md - 1.2.2 <code>1ddf0f2</code></li> <li>Merge tag '1.2.1' into develop <code>7b52e92</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#121","title":"1.2.1","text":"<p>9 August 2024</p> <ul> <li>gh #13 Code Cleanup in L1 for deepsleep_manager <code>#14</code></li> <li>Bumped CHANGELOG.md - 1.2.1 <code>9aa8ca9</code></li> <li>Merge tag '1.2.0' into develop <code>af26887</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#120","title":"1.2.0","text":"<p>26 June 2024</p> <ul> <li>gh #10 deep sleep manager make file update <code>#11</code></li> <li>gh #3 Test Specification document for Deep sleep manager <code>#4</code></li> <li>gh #3 Updated with L2 spec and test code initial version. <code>669d6c5</code></li> <li>gh #3 Added Test Specification <code>509da92</code></li> <li>Deepsleep hal L2 <code>0636d58</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#111","title":"1.1.1","text":"<p>5 June 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.1.1 <code>4dc8aef</code></li> <li>Updated README.md <code>c103a6d</code></li> <li>Merge tag '1.1.0' into develop <code>e73e709</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#110","title":"1.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #5 deepsleep: Adding MACRO ENABLE_ENHANCED_ERROR_CODE to enable/disable the enhanced <code>#6</code></li> <li>Enhanced error code moved to kvp  profiler <code>f2af2cf</code></li> <li>Disabling enhanced error code <code>51570f8</code></li> <li>Deepsleepmanager enhanced error code update <code>3918bab</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#104","title":"1.0.4","text":"<p>20 February 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.0.4 <code>a89bae8</code></li> <li>Updated tag version in README.md <code>5a6d6b6</code></li> <li>Merge tag '1.0.3' into develop <code>8690552</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#103","title":"1.0.3","text":"<p>29 January 2024</p> <ul> <li>gh #1 Update code improve readability <code>4ebbc01</code></li> <li>gh #1 Update UT version2.0 <code>907745b</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>14df554</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#102","title":"1.0.2","text":"<p>12 December 2023</p> <ul> <li>Updated README.md with hal &amp; haltest supported version <code>59df134</code></li> <li>Bumped CHANGELOG.md - 1.0.2 <code>d9d4ddd</code></li> <li>Merge tag '1.0.1' into develop <code>3ec172e</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CHANGELOG/#101","title":"1.0.1","text":"<p>7 December 2023</p> <ul> <li>Baseline version <code>9208f9f</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>7f839e4</code></li> <li>Initial commit <code>24dfdb8</code></li> </ul>"},{"location":"external_content/deepsleep_manager_test/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/","title":"Deep Sleep Manager High Level Test Specification Documentation","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Test Scenarios</li> <li>Set Deep Sleep with timeout</li> <li>Test with wake-up Source</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>- Hardware Abstraction Layer</li> <li><code>API</code>- Application Programming Interface</li> <li><code>L2</code> - Level2 Testing</li> <li><code>L3</code> - Level3 Testing</li> <li><code>NA</code> - Not Applicable</li> <li><code>Y</code> - Yes</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of High Level testing requirements for the Deep Sleep Manager module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, control plane emulator requirements and expected deliverables.</p> <p>Interface of the test is available here: DeepSleep Manager HAL header</p> <p>The Power manager Hal Spec document: DeepSleep Manager HAL Spec</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#test-scenarios","title":"Test Scenarios","text":"<p>The Deep-sleep Manager layer facilitates the deep-sleep sleep and wake up procedures.</p> # Test Functionality Description 1 Set deep sleep with timeout Set the deep sleep with timeout and verify the wake-up source 2 Test with Wake-up Source Configure the deep sleep mode with no timeout, ensuring that the Deep Sleep Manager facilitates wake-up sources, allowing the device to awaken from deep sleep."},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#set-deep-sleep-with-timeout","title":"Set Deep Sleep with timeout","text":"Description HAL APIs L2 L3 Control plane requirements Set the deep sleep with  of one second and verify the wake-up source PLAT_DS_SetDeepSleep <code>Y</code> <code>NA</code> <code>NA</code> Set the deep sleep with  of ten seconds and verify the wake-up source PLAT_DS_SetDeepSleep <code>Y</code> <code>NA</code> <code>NA</code> Verify that the device has come out of deep-sleep after the specified timeout period has ended. Verify that, based on how long the device sleep, it comes out with a time difference based on the platform configuration file. Also verify that the internal clock matches the network clock after wake up. PLAT_DS_SetDeepSleep <code>N</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#test-startup-requirement-set-deep-sleep-with-timeout","title":"Test Startup Requirement - Set Deep Sleep with timeout","text":"<p><code>NA</code></p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#emulator-requirements-set-deep-sleep-with-timeout","title":"Emulator Requirements - Set Deep Sleep with timeout","text":"<ul> <li>Boot configuration: Wake-up sources supported by the device read from the platform profile. See DeepSleep_WakeupReason_t.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#control-plane-requirements-set-deep-sleep-with-timeout","title":"Control Plane Requirements - Set Deep Sleep with timeout","text":"<ul> <li>Control plane must have some way to verify the time the device slept for before waking up.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#test-with-wake-up-source","title":"Test with Wake-up Source","text":"Description HAL APIs L2 L3 Control plane requirements Configure the deep sleep mode with no timeout, ensuring that the Deep Sleep Manager facilitates wake-up sources( PLAT_API_SetWakeupSrc ) for all wake-up sources that the device supports, allowing the device to awaken from deep sleep. PLAT_DS_SetDeepSleep <code>NA</code> <code>Y</code> Control plane requirements to trigger non-timeout wake up source. Configure the deep sleep mode with a timeout, before triggering a wake-up from an external wake up source( PLAT_API_SetWakeupSrc ) for all wake-up sources that the device supports, allowing the device to awaken from deep sleep. PLAT_DS_SetDeepSleep <code>NA</code> <code>Y</code> Control plane requirements to trigger non-timeout wake up source. Configure the deep sleep mode with a one minute timeout. Verify that is a wake up source is not enabled, the device does not wake up when that external wake up source( PLAT_API_SetWakeupSrc ) is triggered. PLAT_DS_SetDeepSleep, PLAT_API_GetWakeupSrc <code>NA</code> <code>Y</code> Control plane requirements to trigger non-timeout wake up source. Configure the deep sleep mode with no timeout, ensuring that the Deep Sleep Manager does not wake up from deepsleep until an external wake up source triggers. Wait thirty seconds. PLAT_DS_SetDeepSleep <code>NA</code> <code>Y</code> Control plane requirements to trigger non-timeout wake up source. Configure the deep sleep mode with a ten second timeout but timeout wake up source is disabled, ensuring that the Deep Sleep Manager does not wake up from deepsleep until an external wake up source triggers. Wait thirty seconds. PLAT_DS_SetDeepSleep, PLAT_API_SetWakeupSrc <code>NA</code> <code>Y</code> Control plane requirements to trigger non-timeout wake up source. Configure the deep sleep mode with no timeout, ensuring that the Deep Sleep Manager facilitates wake-up sources( PLAT_API_SetWakeupSrc ) for different combinations of wake up sources being enabled. (PWRMGR_WAKEUPSRC_WIFI/PWRMGR_WAKEUPSRC_LAN) PLAT_DS_SetDeepSleep PLAT_API_GetWakeupSrc <code>NA</code> <code>Y</code> Control plane requirements to trigger non-timeout wake up source."},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#test-startup-requirement-test-with-wake-up-source","title":"Test Startup Requirement - Test with Wake-up Source","text":"<p><code>NA</code></p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#emulator-requirements-test-with-wake-up-source","title":"Emulator Requirements - Test with Wake-up Source","text":"<ul> <li>Boot configuration: Wake-up sources supported by the device read from the platform profile. See DeepSleep_WakeupReason_t.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#control-plane-requirements-test-with-wake-up-source","title":"Control Plane Requirements - Test with Wake-up Source","text":"<ul> <li>Control panel to trigger the wake-up source and supported wake-up sources are:</li> <li>Ability to trigger a power cycle if the a test fails a device remains within deepsleep for too long. The limit should be two minutes. It should be on a test by case basis.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#check-power-consumption","title":"Check Power consumption","text":"Description HAL APIs L2 L3 Control plane requirements Set the deep sleep with and check that the decrease in power comsumption based on the test configuration file with network standby disabled. PLAT_DS_SetDeepSleep <code>NA</code> <code>Y</code> <code>NA</code> Set the deep sleep with and check that the decrease in power comsumption based on the test configuration file with network standby enabled. PLAT_DS_SetDeepSleep <code>NA</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#test-startup-requirement-check-power-consumption","title":"Test Startup Requirement - Check Power consumption","text":"<p><code>NA</code></p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#emulator-requirements-check-power-consumption","title":"Emulator Requirements -Check Power consumption","text":"<ul> <li>Boot configuration: Wake-up sources supported by the device read from the platform profile. See DeepSleep_WakeupReason_t.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_High-Level_TestSpec/#control-plane-requirements-check-power-consumption","title":"Control Plane Requirements - Check Power consumption","text":"<ul> <li>Control plane must have way to capture the power consumption changes when the device enters deep sleep</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/","title":"Deep Sleep Manager L2 Low-Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the L2 Low-Level Test Specification and Procedure Documentation for the Deep Sleep Manager module.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps an open-source framework that can be expanded to the requirements for future frameworks.</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - DeepSleep Manager High Level TestSpec</li> <li><code>HAL Interface file</code> -  DeepSleep Manager HAL header</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expected to test whether the module operates correctly.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_deepSleepMgr_SetDeepSleepAndVerifyWakeup1</code> Description Set the deep sleep with a duration of one second and verify the wake-up source Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the deep sleep manager using PLAT_DS_INIT None DEEPSLEEPMGR_SUCCESS Should be successful 02 Set the deep sleep with a duration of one second using PLAT_DS_SetDeepSleep deep_sleep_timeout=1, isGPIOWakeup=valid pointer, networkStandby=false DEEPSLEEPMGR_SUCCESS Should be successful 03 PLAT_DS_DeepSleepWakeup shall be called after wakeup to do any postprocessing None DEEPSLEEPMGR_SUCCESS Should be successful 04 Verify the wakeup source using PLAT_DS_GetLastWakeupReason wakeupReason = Valid pointer isGPIOWakeup=false, wakeup reason = DEEPSLEEP_WAKEUPREASON_TIMER Should be successful 05 Terminate the deep sleep manager using PLAT_DS_TERM None DEEPSLEEPMGR_SUCCESS Should be successful <pre><code>graph TB\nA[Call PLAT_DS_INIT] --&gt;|DEEPSLEEPMGR_SUCCESS| B[Call PLAT_DS_SetDeepSleep]\nA --&gt;|Failure| A1[Test case fail]\nB --&gt;|DEEPSLEEPMGR_SUCCESS| C[Wait for 1 second]\nB --&gt;|Failure| B1[Test case fail]\nC --&gt; D[Call PLAT_DS_DeepSleepWakeup]\nD --&gt; |DEEPSLEEPMGR_SUCCESS| E[verify the wakeup source using PLAT_DS_GetLastWakeupReason]\nD --&gt; |Failure| D1[Test case fail]\nE --&gt;|DEEPSLEEPMGR_SUCCESS| F[Call PLAT_DS_TERM]\nE --&gt;|Failure| E1[Test case fail]\nF --&gt;|DEEPSLEEPMGR_SUCCESS| G[Test case success]\nF --&gt;|Failure| F1[Test case fail]</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_deepSleepMgr_SetDeepSleepAndVerifyWakeUp10</code> Description Set the deep sleep with a duration of ten seconds and verify the wake-up source Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L2-Low-Level_TestSpec/#test-procedure-test2","title":"Test Procedure - Test2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the deep sleep manager using PLAT_DS_INIT None DEEPSLEEPMGR_SUCCESS Should be successful 02 Set the deep sleep with a duration of one second using PLAT_DS_SetDeepSleep deep_sleep_timeout=10sec, isGPIOWakeup=valid pointer, networkStandby=false DEEPSLEEPMGR_SUCCESS Should be successful 03 PLAT_DS_DeepSleepWakeup shall be called after wakeup to do any postprocessing None DEEPSLEEPMGR_SUCCESS Should be successful 04 Verify the wakeup source using PLAT_DS_GetLastWakeupReason wakeupReason = Valid pointer isGPIOWakeup=false, wakeup reason = DEEPSLEEP_WAKEUPREASON_TIMER Should be successful 05 Terminate the deep sleep manager using PLAT_DS_TERM None DEEPSLEEPMGR_SUCCESS Should be successful <pre><code>graph TB\nA[Call PLAT_DS_INIT] --&gt;|DEEPSLEEPMGR_SUCCESS| B[Call PLAT_DS_SetDeepSleep]\nA --&gt;|Failure| A1[Test case fail]\nB --&gt;|DEEPSLEEPMGR_SUCCESS| C[Wait for 10 seconds]\nB --&gt;|Failure| B1[Test case fail]\nC --&gt; D[Call PLAT_DS_DeepSleepWakeup]\nD --&gt; |DEEPSLEEPMGR_SUCCESS| E[verify the wakeup source using PLAT_DS_GetLastWakeupReason]\nD --&gt; |Failure| D1[Test case fail]\nE --&gt;|DEEPSLEEPMGR_SUCCESS| F[Call PLAT_DS_TERM]\nE --&gt;|Failure| E1[Test case fail]\nF --&gt;|DEEPSLEEPMGR_SUCCESS| G[Test case success]\nF --&gt;|Failure| F1[Test case fail]</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/","title":"Deepsleep Manager L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Deepsleep Manager module.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>LAN</code> - Local Area Network</li> <li><code>Y</code>   - yes supported</li> <li><code>NA</code>  - Not Supported</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - DeepSleep Manager High Level TestSpec</li> <li><code>HAL Interface file</code> -  DeepSleep Manager HAL header</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"# Test-case Description HAL APIs Source Sink 1 Verify the deepsleep wake up from Voice Trigger deepsleep, and trigger wake up from voice up source <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 2 Verify the deepsleep wake up from Presence Detection Trigger deepsleep, and trigger wake up from presence detection <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 3 Verify the deepsleep wake up from Bluetooth Trigger deepsleep, and trigger wake up from bluetooth <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 4 Verify the deepsleep wake up from wifi Trigger deepsleep, and trigger wake up from wifi <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 5 Verify the deepsleep wake up from IR Trigger deepsleep, and trigger wake up from IR <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 6 Verify the deepsleep wake up from Power Key Trigger deepsleep, and trigger wake up from Power Key <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 7 Verify the deepsleep wake up from CEC Trigger deepsleep, and trigger wake up from CEC <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code> 8 Verify the deepsleep wake up from LAN Trigger deepsleep, and trigger wake up from LAN <code>PLAT_DS_SetDeepSleep()</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of Deepsleep Manager L3 Python test cases:</p> <pre><code>---\ntitle: deepsleep - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- L3_TestClasses_Deepsleep : inherits\n    L3_TestClasses_Deepsleep ..&gt; deepsleep_tests : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for L3_TestClasses_Deepsleep \"uses testSetupConfig.yaml\"\n    ut_raft &lt;|-- L3_TestClasses_Power : inherits\n    L3_TestClasses_Power ..&gt; deepsleep_tests : uses\n    note for L3_TestClasses_Power \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>deepsleep manager</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3-Low-Level_TestSpec/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li>For more details refer RAFT and example_device_config.yml</li> </ul> <p>componentProfile.yaml/platformProfile.yaml   - Contains component-specific configurations   - Contains platform wide configuration broken down into separate components   - Example configuration file deepsleep_Settings</p> <ul> <li>testSetupConfig.yaml</li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file deepsleep_L3_testSetup.yml</p> </li> <li> <p>testSuite.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file deepsleep_testConfig.yml</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/","title":"DeepSleep HAL L3 Python Test Procedure","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Run Test Cases</li> <li>Test Setup Connections</li> <li>Test Cases</li> <li>test1_TriggerDeepsleep.py</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>CEC</code>    - Consumer Electronics Control</li> <li><code>LAN</code>    - Local Area Network</li> <li><code>SSID</code>   - Service Set Identifier</li> <li><code>IP</code>     - Internet Protocal</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default This session is used for basic operations, such as verifying the device status and retrieving the MAC address ssh_hal_deepsleep_test Executes the <code>HAL</code> binary for the deepsleep test case ssh_hal_power_test Executes the <code>HAL</code> binary for the power test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_deepsleep_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_power_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update the target directory where <code>HAL</code> binaries will be copied into the device. Also, map the profile to the source/sink settings <code>YAML</code> file path.</p> <p>Ensure the platform should match with the <code>DUT</code> platform in Rack Configuration</p> <pre><code>deviceConfig:\n  cpe1:\n    platform: \"stb\"    # Must match the platform in example_rack_config.yml\n    model: \"uk\"\n    target_directory: \"/tmp\"  # Path where HAL binaries are copied in device\n    test:\n      profile: \"../../../profiles/deepsleepmanagerExtendedEnumsNotSupported.yaml\"\n</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File the deepsleep side: deepsleep_L3_testSetup.yml</p> <p>Example Test Setup configuration File the power manager side: power_L3_testSetup.yml</p> <p>Streams required for each test case was provided in this file. Testing Deep sleep functionality doesn't require any streams.</p> <pre><code>deepsleep:  # Prefix must always exist\n  description: \"deepsleep Manager test setup\"\n  assets:\n    device:\n      test1_TestWakeupSources:\n        streams:\n\npower:  # Prefix must always exist\n  description: \"power Manager test setup\"\n  assets:\n    device:\n      test1_TestWakeupSources:\n        streams:\n</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test configuration File for deepsleep manager: deepsleep_testConfig.yml Example Test Setup configuration File for power manager: power_testConfig.yml</p> <p>The test copies the binary files from the path specified in the <code>artifacts</code> entry of the <code>yml</code> file. Ensure that the <code>HAL</code> test binaries for the deep sleep manager and power manager are available in the specified folder.</p> <p>Execute command to run the <code>HAL</code> binary was provided in this file.</p> <pre><code>deepsleep:\n    description: \"deepsleep Manager testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/deepsleepmanager/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\" #Execute command\n</code></pre> <pre><code>power:\n    description: \"power Manager testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/powermanager/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\" #Execute command\n</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#test-setup-connections","title":"Test Setup Connections","text":"<p>Make sure the device under test <code>DUT</code> is connected to wifi, <code>LAN</code> and a <code>CEC</code> supported device for waking up from deepsleep before starting the test case.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#example-wifi-configuration","title":"Example WIFI Configuration","text":"<p>If the <code>DUT</code> supports WPA, follow these steps to configure the <code>WIFI</code>:</p> <p>Generate the WPA Configuration File:</p> <p>Use the router's <code>SSID</code> and password to create a configuration file:</p> <pre><code>wpa_passphrase &lt;\"Router SSID\"&gt; &lt;\"Passsword\" &gt; /data/wpa-supplicant.conf\n</code></pre> <p>Start the wpa_supplicant daemon: Run the following command to start the <code>wpa_supplicant</code> service:</p> <pre><code>wpa_supplicant -dd -B -i wlan0 -c /data/wpa-supplicant.conf\n</code></pre> <p>If still not getting <code>IP</code> for <code>wlan0</code> bridge interface try:</p> <pre><code>ifconfig wlan0 down\nifconfig wlan0 up\n</code></pre>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#test1_triggerdeepsleeppy","title":"test1_TriggerDeepsleep.py","text":""},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Sink/Source</li> </ul>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>Yes: User interaction is required to manually trigger wake-up events from deep sleep for specific wake-up sources. (This will be automated later).</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>All supported wake-up sources must be validated and properly trigger the system to wake up from deep sleep</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>All tested wake-up sources must successfully trigger the system to exit deep sleep without errors or failures. Upon waking, the recorded wake-up reason must accurately correspond to the triggered event.</p>"},{"location":"external_content/deepsleep_manager_test/docs/pages/deep-sleep-manager_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>test1_TriggerDeepsleep.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Trigger deepsleep prompt:</p> <p>The test will set the wake-up source and trigger a deepsleep.</p> <p>The above will loop through all supported wake up sources that applicable for the specific device based on the <code>yaml</code> file.</p> </li> <li> <p>Once in deepsleep the device will need to be manually awoken for some sources like <code>IR</code>, <code>CEC</code> and <code>Power_Key</code>.</p> <ul> <li> <p>During the <code>IR</code> test, use an <code>IR</code> remote to trigger the wake-up by pressing the power key or home key. If the device successfully wakes up from deep sleep using this method, the test evaluates whether the wake-up process was successful.</p> </li> <li> <p>During the <code>Power_Key</code> test, press the power key of the <code>dut</code> to wake-up. If the device successfully wakes up from deep sleep using this method, the test evaluates whether the wake-up process was successful.</p> </li> <li> <p>During the <code>CEC</code> test, initiate the wake-up process by connecting an <code>HDMI</code> cable to the device and sending a wake-up <code>CEC</code> command (e.g., <code>Image_View_On</code>) from the connected device to the <code>DUT</code>. If the device transitions successfully from deep sleep to an active state using this method, the test assesses the success of the wake-up operation.</p> </li> </ul> </li> <li> <p>The following tests should be done automaticaly.</p> <ul> <li> <p>When the device enters <code>LAN</code> test, test automatically triggers the wake up and validates whether the device successfully wakes up.</p> </li> <li> <p>When the device enters <code>wifi</code> test, test automatically triggers the wake up and validates whether the device successfully wakes up.</p> </li> <li> <p>When the device enters <code>Timer</code> test, <code>dut</code> wakes up after 60 seconds and test validates whether the device successfully wakes up.</p> </li> </ul> </li> </ul>"},{"location":"external_content/device_settings/","title":"Device Settings Module","text":""},{"location":"external_content/device_settings/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Device Settings Sub modules details</li> </ul>"},{"location":"external_content/device_settings/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HPK</code> - Hardware Porting Kit</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>DS</code> - Device Settings</li> <li><code>NA</code> - Not Applicable</li> </ul>"},{"location":"external_content/device_settings/#description","title":"Description","text":"<p>This document provides the links for the specific sub-modules of the Device Settings.</p>"},{"location":"external_content/device_settings/#device-settings-sub-modules-details","title":"Device Settings Sub modules details","text":"SNo Sub-module Name <code>HAL</code> Specification Header File(s) Settings Template File 1 <code>DS</code> Host <code>DS</code> Host <code>HAL</code> Specification dsHost.h <code>NA</code> 2 <code>DS</code> Front Panel Display <code>DS</code> Front Panel Display <code>HAL</code> Specification dsFPD.h, dsFPDTypes.h frontPanelSettings_template.hpp 3 <code>DS</code> Display <code>DS</code> Display <code>HAL</code> Specification dsDisplay.h, dsAVDTypes.h <code>NA</code> 4 <code>DS</code> HDMI Input <code>DS</code> HDMI Input <code>HAL</code> Specification dsHdmiIn.h, dsHdmiInTypes.h <code>NA</code> 5 <code>DS</code> Composite Input <code>DS</code> Composite Input <code>HAL</code> Specification dsCompositeIn.h, dsCompositeInTypes.h <code>NA</code> 6 <code>DS</code> Audio <code>DS</code> Audio <code>HAL</code> Specification dsAudio.h, dsAVDTypes.h dsAudioSettings_template.h 7 <code>DS</code> Video Device <code>DS</code> Video Device <code>HAL</code> Specification dsVideoDevice.h, dsVideoDeviceTypes.h dsVideoDeviceSettings_template.h 8 <code>DS</code> Video Port <code>DS</code> Video Port <code>HAL</code> Specification dsVideoPort.h, dsAVDTypes.h dsVideoPortSettings_template.h, dsVideoResolutionSettings_template.h <p>For more information about Test suits and <code>HPK</code>,please check HPK repo</p>"},{"location":"external_content/device_settings/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/device_settings/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/device_settings/CHANGELOG/#412","title":"4.1.2","text":"<ul> <li>gh #85 HDMI Hal header updation for the maximum number of HDMI ports <code>#86</code></li> <li>Merge tag '4.1.1' into develop <code>3c96217</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#411","title":"4.1.1","text":"<p>27 December 2024</p> <ul> <li>gh #83 Mismatch in dialog enhancement range <code>#84</code></li> <li>Bumped CHANGELOG.md - 4.1.1 <code>c076606</code></li> <li>Modified the param description based on IDK version <code>87af9d0</code></li> <li>gh #83 Mismatch in the range of Dialog Enhancement Level <code>2b8546d</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#410","title":"4.1.0","text":"<p>21 November 2024</p> <ul> <li>gh #80 Add Composite videoModeUpdate CB header <code>#81</code></li> <li>gh #80 Added Composite VideoModeCB Header <code>73ff15d</code></li> <li>gh #80 Added Composite VideoModeCB Header <code>01d3d32</code></li> <li>Update dsCompositeIn.h <code>509bab3</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#401","title":"4.0.1","text":"<p>7 November 2024</p> <ul> <li>gh #72 Frame Rate Mode and Frame Rate API description update <code>#73</code></li> <li>Bumped CHANGELOG.md - 4.0.1 <code>f5ac950</code></li> <li>gh #72 Update Description for Framerate mode and Framerate APIs <code>0348d7b</code></li> <li>gh #73 Get and Set Framerate brief update <code>190698e</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#400","title":"4.0.0","text":"<p>28 August 2024</p> <ul> <li>gh #64 Add new getHdmiVersion API <code>#68</code></li> <li>gh #67 Interface file update - dsHdmi Input - Parameter change in Select port <code>#69</code></li> <li>gh #62 Remove statement for Operation_Not_Supported in Get and SetFPS\u2026 <code>#63</code></li> <li>gh #59 Added HDMI VideoPort ALLM APIs <code>#61</code></li> <li>gh #59 Added ALLM Set/Get APIs <code>c790aa2</code></li> <li>gh #64 Minor corrections to HDMI version API and enum names <code>b382740</code></li> <li>Bumped CHANGELOG.md - 4.0.0 <code>1a9a7f7</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#300","title":"3.0.0","text":"<p>27 June 2024</p> <ul> <li>gh #57 fp architectural comments <code>#58</code></li> <li>gh #55 Remove dsGetHDMIARCPortID() from dsAudio Interface <code>#56</code></li> <li>gh #50 Update based on review discussion <code>#51</code></li> <li>gh #53 Info about SEI Signalling in AVIContentTypeChangeCB <code>#54</code></li> <li>gh #25 DS Audio Interface update <code>#26</code></li> <li>gh #43 VideoDevice dsGetHDRCapabilities doxygen update <code>#44</code></li> <li>gh #41 dsGetAspectRatio Source related updates <code>#42</code></li> <li>gh #47 hdmi in interface architectural comments <code>#48</code></li> <li>gh #39 Video Port architectural comments <code>#40</code></li> <li>gh #36 updated the post conditions for display and composite  <code>#38</code></li> <li>gh #45 Remove the prerequisite dsCompositeInSelectPort() from dsCompositeInScaleVideo() <code>#46</code></li> <li>gh #30 Deprecate DTCP related APIs <code>#31</code></li> <li>Feature/issues15 video port interface update <code>#16</code></li> <li>gh #21 DS Video Device Interface Update <code>#22</code></li> <li>gh #23 DS HDMI IN Interface Document Update <code>#24</code></li> <li>gh #17 DS Display Interface Documentation Update <code>#18</code></li> <li>gh #25 Deprecating Encoding &amp; DelayOffset set/get APIs <code>dc7ba35</code></li> <li>gh #25 Removed wrongly uploaded Audio header <code>14f99bb</code></li> <li>gh #26 Updated Audio Header for both sink and source <code>1ce0e98</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#210","title":"2.1.0","text":"<p>11 September 2024</p> <ul> <li>gh #78 Added ALLM Set/Get APIs in 2.0.0 tag <code>#79</code></li> <li>gh #76 Add new getHdmiVersion API to 2.0.0 <code>#77</code></li> <li>gh #64 Add new getHdmiVersion API <code>e74f6cb</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#200","title":"2.0.0","text":"<p>22 March 2024</p> <ul> <li>Feature/issues11 Add set mixer levels API <code>#12</code></li> <li>Bumped CHANGELOG.md - 2.0.0 <code>72ba582</code></li> <li>gh #11 Added SetMixerLevels API <code>698703d</code></li> <li>gh #11 Generic Mixer(removed MS12) &amp; dsERR_GENERAL return value update <code>cb4eced</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#108","title":"1.0.8","text":"<p>12 December 2023</p> <ul> <li>Bumped CHANGELOG.md - 1.0.8 <code>b1bc998</code></li> <li>updated frontPanelSettings_template.hpp file name in README.md <code>ab3616d</code></li> <li>Merge tag '1.0.7' into develop <code>cc1da17</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#107","title":"1.0.7","text":"<p>11 December 2023</p> <ul> <li>Recent updates to the .h files to maintain versions, until we finish migrating to the new repo <code>#5</code></li> <li>Update AVD types with missing values <code>65abe30</code></li> <li>doxygen comments updated <code>f36dc8f</code></li> <li>Bumped CHANGELOG.md - 1.0.7 <code>b69b787</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#106","title":"1.0.6","text":"<p>14 November 2023</p> <ul> <li>Updated build_ut.sh &amp; Updated LICENSE file name in header <code>#3</code></li> <li>Baseline version <code>2726111</code></li> <li>Updated LICENSE file name in header <code>032d968</code></li> <li>Updated CHANGELOG.md - 1.0.6 <code>4380b47</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#020","title":"0.2.0","text":"<p>21 March 2024</p> <ul> <li>RDK6 Changes <code>e0942cb</code></li> <li>Added CHANGELOG.md - 0.2.0 <code>5e7e81b</code></li> <li>Initial commit <code>2f7ae7f</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#012","title":"0.1.2","text":"<p>15 January 2024</p> <ul> <li>Baseline version <code>36805cd</code></li> <li>Initial commit <code>4506122</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#011","title":"0.1.1","text":"<p>11 January 2024</p> <ul> <li>Baseline changes <code>78bde55</code></li> <li>Initial commit <code>e2cccba</code></li> </ul>"},{"location":"external_content/device_settings/CHANGELOG/#010","title":"0.1.0","text":"<p>27 December 2023</p> <ul> <li>baseline version <code>08c905d</code></li> <li>Initial commit <code>e6f05b0</code></li> </ul>"},{"location":"external_content/device_settings/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/device_settings/docs/pages/","title":"Device Settings Module","text":""},{"location":"external_content/device_settings/docs/pages/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Device Settings Sub modules details</li> </ul>"},{"location":"external_content/device_settings/docs/pages/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HPK</code> - Hardware Porting Kit</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>DS</code> - Device Settings</li> <li><code>NA</code> - Not Applicable</li> </ul>"},{"location":"external_content/device_settings/docs/pages/#description","title":"Description","text":"<p>This document provides the links for the specific sub-modules of the Device Settings.</p>"},{"location":"external_content/device_settings/docs/pages/#device-settings-sub-modules-details","title":"Device Settings Sub modules details","text":"SNo Sub-module Name <code>HAL</code> Specification Header File(s) Settings Template File 1 <code>DS</code> Host <code>DS</code> Host <code>HAL</code> Specification dsHost.h <code>NA</code> 2 <code>DS</code> Front Panel Display <code>DS</code> Front Panel Display <code>HAL</code> Specification dsFPD.h, dsFPDTypes.h frontPanelSettings_template.hpp 3 <code>DS</code> Display <code>DS</code> Display <code>HAL</code> Specification dsDisplay.h, dsAVDTypes.h <code>NA</code> 4 <code>DS</code> HDMI Input <code>DS</code> HDMI Input <code>HAL</code> Specification dsHdmiIn.h, dsHdmiInTypes.h <code>NA</code> 5 <code>DS</code> Composite Input <code>DS</code> Composite Input <code>HAL</code> Specification dsCompositeIn.h, dsCompositeInTypes.h <code>NA</code> 6 <code>DS</code> Audio <code>DS</code> Audio <code>HAL</code> Specification dsAudio.h, dsAVDTypes.h dsAudioSettings_template.h 7 <code>DS</code> Video Device <code>DS</code> Video Device <code>HAL</code> Specification dsVideoDevice.h, dsVideoDeviceTypes.h dsVideoDeviceSettings_template.h 8 <code>DS</code> Video Port <code>DS</code> Video Port <code>HAL</code> Specification dsVideoPort.h, dsAVDTypes.h dsVideoPortSettings_template.h, dsVideoResolutionSettings_template.h <p>For more information about Test suits and <code>HPK</code>,please check HPK repo</p>"},{"location":"external_content/device_settings/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/","title":"DEVICE SETTINGS AUDIO HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>DS</code>     - Device Settings</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> <li><code>CB</code>     - Callback function (suffix)</li> <li><code>ARC</code>    - Audio Return Channel</li> <li><code>eARC</code>   - Enhanced Audio Return Channel</li> <li><code>SPDIF</code>  - Sony/Philips Digital Interface</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>LE</code>     - Loudness Equivalence</li> <li><code>DRC</code>    - Dynamic Range Control</li> <li><code>MI</code>     - Media Intelligent</li> <li><code>RF</code>     - Radio Frequency</li> <li><code>dB</code>     - Decibel</li> <li><code>MS12</code>   - MultiStream 12</li> <li><code>AC4</code>    - Audio Compression 4</li> <li><code>ms</code>     - milliseconds</li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>SoC</code>    - System-on-Chip</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the <code>DS</code> Audio module.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[DEVICE SETTINGS AUDIO HAL];\nx[DEVICE SETTINGS AUDIO HAL]&lt;--&gt;z[Audio SoC Driver];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>This interface provides a set of <code>APIs</code> to facilitate communication to the Audio <code>SoC</code> Driver.</p> <p>This interface provides control to enable or disable Audio Output ports like TV Internal Speakers, <code>ARC</code>/<code>eARC</code>, Headphones, <code>SPDIF</code> and allows <code>caller</code> to configure or retrieve various audio parameters like audio encoding, audio compression, dialog enhancement, dolby volume mode, intelligent equalizer, volume leveller, bass enhancer, <code>DRC</code> mode, surround virtualizer, <code>MI</code> steering, graphic equalizer, <code>MS12</code> audio profile, stereo mode, audio gain, audio <code>dB</code>, audio level, audio max and min <code>dB</code>, audio delay, fader control, primary language and secondary language. It also provides <code>APIs</code> to  enable loop through, set audio ducking, enable <code>LE</code>, get the Atmos capability of sink device</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>The component must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput, and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behaviour.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>dsAudioPortInit()</code> before calling any other <code>APIs</code>. The <code>Caller</code> is expected to have complete control over the life cycle of the <code>DS</code> Audio module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. This interface is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by this interface must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions must not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>AudioPort provides the following asynchronous registration :</p> <ul> <li><code>dsAudioOutRegisterConnectCB()</code> - Callback function to notify the audio port connection status to the <code>caller</code></li> <li><code>dsAudioFormatUpdateRegisterCB()</code> - Callback function to notify the audio format update to the <code>caller</code></li> <li><code>dsAudioAtmosCapsChangeRegisterCB()</code> - Callback function to notify the atmos capability update to the <code>caller</code></li> </ul> <p>This interface is allowed to establish its own thread context for its operation, ensuring minimal impact on system resources. Additionally, this interface is responsible for releasing the resources it creates for its operation once the respective operation concludes.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period. Any call that can fail due to the lack of response from the connected device must have a timeout period and the function must return the relevant error code.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to this interface.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG should be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the platform.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged, to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for <code>DS</code> as Audio is a part of <code>DS</code> and must be named as libdshal.so. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li>Any modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The configuration settings file (dsAudioSettings_template.h) for <code>DS</code> Audio can be used for adding platform specific configurations. The sample file is available here.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code></p> <ol> <li> <p>Initialize the <code>DS</code> Audio <code>HAL</code> using function: <code>dsAudioPortInit()</code> before making any other <code>API</code> calls.  If <code>dsAudioPortInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>Once the Audio Ports are initialized, Audio Output ports like TV Internal Speakers, <code>ARC</code>/<code>eARC</code>, Headphones, <code>SPDIF</code> can be enabled or disabled using Audio Port Handle based on Audio Settings Template.</p> </li> <li> <p>The following Audio functionalities are supported:</p> </li> <li>Audio Encoding</li> <li>Audio Format</li> <li>Audio Compression</li> <li>Dialog Enhancement</li> <li>Dolby Volume Mode</li> <li>Audio Ducking</li> <li>Bass Enhancer</li> <li><code>MI</code> Steering</li> <li><code>LE</code></li> <li>Stereo Mode</li> <li>Audio Gain</li> <li>Loop Through</li> <li>Intelligent Equivalizer</li> <li>Dynamic Range Control</li> <li>Fader Control</li> <li><code>MS12</code> capabilities</li> <li>Audio Delay</li> <li>Audio Mixing</li> <li><code>AC4</code> Primary Language</li> <li><code>AC4</code> Secondary Language</li> <li> <p>Audio Mixer Levels(Sink specific)</p> </li> <li> <p>Callbacks can be set with:</p> <ul> <li><code>dsAudioOutRegisterConnectCB()</code> -  used when the audio port connection status changes`</li> <li><code>dsAudioFormatUpdateRegisterCB()</code> -  used when the audio format changes</li> <li><code>dsAudioAtmosCapsChangeRegisterCB()</code> -  used when the atmos capability changes</li> </ul> </li> <li> <p>De-initialize the <code>Audio HAL</code> using the function: <code>dsAudioPortTerm()</code></p> </li> </ol> <p>NOTE: The module would operate deterministically if the above call sequence is followed</p>"},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-audio_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DEVICE SETTINGS AUDIO HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsAudioPortInit()\n    Note over HAL: SoC initializes the Audio Ports\n    HAL-&gt;&gt;Driver: Initializes the Audio Output Ports\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetAudioPort()\n    Note over HAL: API to get Audio Port Handle\n    HAL-&gt;&gt;Driver: Get the Audio Port handle\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsEnableAudioPort()\n    Note over HAL: API to enable or disable specified Audio Output Port\n    HAL-&gt;&gt;Driver:Specified Audio Port is enabled or disabled\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsAudio_SetMethods\n    Note over HAL: APIs to set the Audio related parameters\n    HAL-&gt;&gt;Driver: Set the Audio Paramters using Audio Port Handle\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsAudio_GetMethods\n    Note over HAL: APIs to get the Audio related parameters\n    HAL-&gt;&gt;Driver: Get the Audio Paramters using Audio Port Handle\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsSetAudioDucking()\n    Note over HAL: API to set the Audio Ducking level of specified Audio Port\n    HAL-&gt;&gt;Driver:Set the Audio Ducking Level of Specified Audio Output Port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsEnableLoopThru()\n    Note over HAL: API to set loop-through mode of the specified audio port\n    HAL-&gt;&gt;Driver:Set the loop-through mode of Specified Audio Output Port\n    Caller-&gt;&gt;HAL:dsGetHDMIARCPortId()\n    Note over HAL: API to get HDMI ARC Port ID of each platform\n    HAL-&gt;&gt;Driver: Get the HDMI ARC Port ID\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsAudioOutRegisterConnectCB()\n    Note over HAL: Registers the callback for when the audio port connection status changes\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsAudioFormatUpdateRegisterCB()\n    Note over HAL: Registers the callback for when the audio format changes\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsAudioAtmosCapsChangeRegisterCB()\n    Note over HAL: Registers the callback for when the atmos capability changes\n    HAL--&gt;&gt;Caller:return\n    Note over HAL: Audio Port connection status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsAudioOutPortConnectCB_t callback returned\n    Note over HAL: Audio formate has changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsAudioFormatUpdateCB_t callback returned\n    Note over HAL: Atmos capabilities changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsAtmosCapsChangeCB_t callback returned\n    Caller -&gt;&gt;HAL:dsAudioTerm()\n    HAL -&gt;&gt; Driver:dsAudioTerm()\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/","title":"Device Settings CompositeIn HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>         - Hardware Abstraction Layer</li> <li><code>API</code>         - Caller Programming Interface</li> <li><code>Caller</code>      - Any user of the interface via the <code>APIs</code></li> <li><code>CPU</code>         - Central Processing Unit</li> <li><code>DS</code>          - Device Settings</li> <li><code>SoC</code>         - System on chip</li> <li><code>CompositeIn</code> - Composite Input</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the CompositeIn stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Device Settings COmpositeIn HAL];\nx[Device Settings CompositeIn HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>DS <code>CompositeIn</code> <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set information about the Composite input ports such as getting the number of input ports, getting the current status of a selected input port, setting the video scale, selecting which Composite input to be selected as active and registering callbacks for asynchronous notifications.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>This interface must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize this interface by calling <code>dsCompositeInInit()</code> before calling any other <code>APIs</code>. The <code>caller</code> is expected to have complete control over the life cycle of this module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. This interface is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by this interface must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions must not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface must support asynchronous notifications operations:</p> <ul> <li><code>dsCompositeInRegisterConnectCB()</code> must facilitate asynchronous status notifications using the callback when the connection status of the callback <code>dsCompositeInConnectCB_t</code>. This callback must be used when the connection status when the Composite input port changes.</li> <li><code>dsCompositeInRegisterSignalChangeCB()</code> must facilitate asynchronous status notifications using the callback <code>dsCompositeInSignalChangeCB_t</code>. This callback must be used when the Composite input signal status changes.</li> <li><code>dsCompositeInRegisterStatusChangeCB()</code> must facilitate asynchronous status notifications using the callback <code>dsCompositeInStatusChangeCB_t</code>. This callback must be used when the Composite input status changes.</li> <li><code>dsCompositeInRegisterVideoModeUpdateCB()</code> must facilitate asynchronous status notifications using the callback <code>dsCompositeInVideoModeUpdateCB_t</code>. This callback must be used when the Composite video mode changes.</li> </ul> <p>This interface is allowed to establish its own thread context for its operation, ensuring minimal impact on system resources. Additionally, this interface is responsible for releasing the resources it creates for its operation once the respective operation concludes.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>The <code>API</code> must return error synchronously as a return argument. This interface is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to this interface.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the platform.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for DS as <code>CompositeIn</code> module is a part of DS and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li>Any modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> <code>dsCompositeInInit()</code> before making any other <code>APIs</code> calls.  If <code>dsCompositeInInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>The <code>caller</code> can call <code>dsCompositeInSelectPort()</code>, and <code>dsCompositeInScaleVideo()</code> to set the needed information.</p> </li> <li> <p>The <code>caller</code> can call <code>dsCompositeInGetNumberOfInputs()</code> and <code>dsCompositeInGetStatus()</code> to query the needed information.</p> </li> <li> <p>Callbacks can be set with:</p> <ul> <li><code>dsCompositeInRegisterConnectCB()</code> - used when the CompositeIn port connection status changes</li> <li><code>dsCompositeInRegisterSignalChangeCB()</code> - used when the CompositeIn signal status changes</li> <li><code>dsCompositeInRegisterStatusChangeCB()</code> - used when the CompositeIn input status changes</li> <li><code>dsCompositeInRegisterVideoModeUpdateCB()</code> - used when the CompositeIn video mode changes</li> </ul> </li> <li> <p>De-initialize the <code>HAL</code> using <code>dsCompositeInTerm()</code></p> </li> </ol>"},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-composite-in_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS CompositeIn HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsCompositeInInit()\n    Note over HAL: SOC initializes the underlying subsystems\n    HAL-&gt;&gt;Driver:Initializes the underlying subsystems\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInSelectPort()\n    Note over HAL: Sets the passed port as active and available for presentation\n    HAL-&gt;&gt;Driver:Setting the selected port as active\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInGetStatus()\n    Note over HAL: Gets the status of the Composite Input ports\n    HAL-&gt;&gt;Driver:Getting the status of the Composite Input ports\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInGetNumberOfInputs()\n    Note over HAL: Gets the number of Composite Input ports\n    HAL-&gt;&gt;Driver:Getting the number of Composite Input Ports\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInScaleVideo()\n    Note over HAL: Sets the video scale\n    HAL-&gt;&gt;Driver:Setting the video scale\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInRegisterConnectCB()\n    Note over HAL: Registers the callback for when the Composite Input connection status changes\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInRegisterSignalChangeCB()\n    Note over HAL: Registers the callback for when the Composite in signal status changes\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInRegisterStatusChangeCB()\n    Note over HAL: Registers the callback for when the Composite in status changes\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsCompositeInRegisterVideoModeUpdateCB()\n    Note over HAL: Registers the callback for when the CompositeIn video mode changes\n    HAL--&gt;&gt;Caller:return\n    Note over HAL: Composite Input hotplug connection has changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsCompositeInConnectCB_t callback returned\n    Note over HAL: Composite Input signal status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsCompositeInSignalChangeCB_t callback returned\n    Note over HAL: The Composite Input status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsCompositeInStatusChangeCB_t callback returned\n    Note over HAL: The Composite Input video mode changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsCompositeInVideoModeUpdateCB_t callback returned\n    Caller -&gt;&gt;HAL:dsCompositeInTerm()\n    Note over HAL: Terminates the underlying sub-systems\n    HAL-&gt;&gt;Driver:Terminates the underlying sub-systems\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/","title":"DEVICE SETTINGS Display HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>     - Caller Programming Interface</li> <li><code>Caller</code>  - Any user of the interface via the <code>API</code></li> <li><code>DS</code>      - Device Settings</li> <li><code>HAL</code>     - Hardware Abstraction Layer</li> <li><code>HDMI</code>    - High-Definition Multimedia Interface</li> <li><code>DVI</code>     - Digital Visual Interface</li> <li><code>EDID</code>    - Extended Display Identification Data</li> <li><code>HDCP</code>    - High-bandwidth Digital Content Protection</li> <li><code>SoC</code>     - System on chip</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the <code>DS</code> Display module.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Device Settings Display HAL];\nx[DS Display HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p><code>DS</code> Display <code>HAL</code> provides a set of <code>APIs</code> to manage operations related to display devices connected to <code>HDMI</code> Output port of the source devices.</p> <p>The primary objective of this module is to streamline communication between the <code>caller</code> and the <code>HAL</code> interface. This allows the <code>caller</code> to inquire about information related to the <code>EDID</code>, Aspect Ratio and other <code>HDMI</code> related information of the connected display device. Additionally, the module notifies the <code>caller</code> about Display Device parameters, such as Device Connection/Disconnection, <code>HDCP</code> Protocol Changes, and RX Sense ON/OFF etc.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>This interface must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput, and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize this interface by calling <code>dsDisplayInit()</code> before calling any other API. The <code>caller</code> is expected to have complete control over the life cycle of the this module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. <code>HAL</code> is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by the <code>HAL</code> must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>The <code>DS</code> Display <code>HAL</code> is not involved in the power management operation.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>The below mentioned callback registration is used for aysnchronous notification:</p> <ul> <li>dsDisplayEventCallback_t() - is triggered when there is a change in display related events like Device Connection/Disconnection, HDCP Protocol Changes, and RX Sense                                       ON/OFF</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module:</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the system.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for Device Settings as this module is a part of Device Settings and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li><code>DS</code> Display <code>HAL</code> modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the interface using: <code>dsDisplayInit()</code> before making any other <code>API</code> calls.  If <code>dsDisplayInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>The <code>caller</code> can call <code>dsGetEDID()</code>, <code>dsGetDisplayAspectRatio()</code> and <code>dsGetEDIDBytes()</code> to query the information of connected display device. This interface is also used to notify <code>HDCP</code> Protocol changes of display device to the <code>caller</code>.</p> </li> <li> <p>De-initialize the HAL using <code>dsDisplayTerm()</code>.</p> </li> </ol>"},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-display_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS DISPLAY HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsDisplayInit()\n    Note over HAL: SoC initializes the underlying Display subsystem\n    HAL-&gt;&gt;Driver:Initializes Display sub-system &amp; associated data structures\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetDisplay()\n    Note over HAL: Returns the handle for connected display Device\n    HAL-&gt;&gt;Driver:Getting the handle for connected display device\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetEDID()\n    Note over HAL: Gets the EDID Information from connected display device\n    HAL-&gt;&gt;Driver:Getting the EDID Info from HDMI/DVI display device\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetDisplayAspectRatio()\n    Note over HAL: Gets the Aspect Ratio of connected display device\n    HAL-&gt;&gt;Driver:Getting the Aspect Ratio of display device\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:dsDisplayTerm()\n    HAL-&gt;&gt;Driver:Deallocates the associated data structures &amp; releases display specific handles\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/","title":"Device Settings Front Panel Display HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>DS</code>     - Device Settings</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> <li><code>FPD</code>    - Front Panel Display</li> <li><code>LED</code>    - Light-Emitting Diode</li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>SoC</code>    - System-On-Chip</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the <code>DS</code> Front Panel Display stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[DEVICE SETTINGS FRONT PANEL DISPLAY HAL];\nx[DEVICE SETTINGS FRONT PANEL DISPLAY HAL]&lt;--&gt;z[Front Panel SoC Driver];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>This interface provides a set of <code>APIs</code> to facilitate communication to Front Panel <code>LED</code> Display <code>SoC</code> Drivers.</p> <p>The brightness, color and text of Front Panel <code>LEDs</code> can be set or retrieved. This interface also provides <code>API</code> to enable or disable the specified discrete <code>LED</code> on the Front Panel Display.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>This interface must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput, and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>dsFPInit()</code> before calling any other <code>APIs</code>. <code>Caller</code> has complete control over the <code>FPD</code>.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>The <code>FPD</code> <code>HAL</code> is not involved in the power management operation directly. However, the <code>caller</code> will initiate the change in <code>LED</code> as part of power management handling.</p> <p>The <code>caller</code> is responsible for driving <code>LED</code> status in accordance with power mode change.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface is not required to have any asynchronous notification.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period. Any call that can fail due to the lack of response from the connected device must have a timeout period and the function must return the relevant error code.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":""},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and <code>CPU</code> utilization.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for Device Settings <code>HAL</code> as <code>FPD</code> is a part of Device Settings and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects. <code>DS</code> <code>FPD</code> must return the dsERR_OPERATION_NOT_SUPPORTED error code if any of the interface <code>APIs</code> are not supported by the underlying hardware.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The configuration settings file (dsFPDSettings.h) for <code>DS</code> Front Panel can be used for adding platform specific configurations. The sample file is available here.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>FPD</code> <code>HAL</code> using <code>dsFPInit()</code> before making any other <code>API</code> calls.  If the init call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>Once the <code>FPD</code> sub-system is initialized, <code>caller</code> can invoke <code>APIs</code> to control the Front Panel <code>LEDs</code>. The <code>FP</code> brightness, text, color, blink interval, <code>FP</code> <code>LED</code> state(ON/OFF), text scroll can be set or retrieved.</p> </li> <li> <p>De-initialize the <code>FP</code> <code>HAL</code> using <code>dsFPTerm()</code>.</p> </li> </ol> <p>Note : The module would operate deterministically if the above call sequence is followed</p> <p>The various <code>DS</code> <code>FP</code> <code>LED</code> states are as follows:</p> <ul> <li>Active</li> <li>Standby</li> <li>Connecting to WPS</li> <li>Connected to WPS</li> <li>WPS Error</li> <li>Factory Reset</li> <li>USB Upgrade</li> <li>Software Download Error</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-front-panel-display_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS FPD HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsFPInit()\n    Note over HAL: SoC initializes the FPD subsystem\n    HAL-&gt;&gt;Driver: Allocates required resources for FPD\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL: ds_FP_SetMethods\n    Note over HAL: APIs to set the FPD Parameters\n    HAL-&gt;&gt;Driver:Sets the FPD Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL: ds_FP_GetMethods\n    Note over HAL: APIs to get the FPD Parameters\n    HAL-&gt;&gt;Driver:Gets the FPD Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsEnableClockDisplay()\n    Note over HAL: API to enable or disable Clock Display on FP LED\n    HAL-&gt;&gt;Driver: Enables or Disables the clock display on the Front Panel LED\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:dsFPTerm()\n    HAL -&gt;&gt; Driver: Releases all the resources allocated during FPD init\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/","title":"Device Settings HdmiIn HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Caller Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>DS</code>     - Device Settings</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>EDID</code>   - Extended Display Information Data</li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>SoC</code>    - System on chip</li> <li><code>AV</code>     - Audio-Visual</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>SPD</code>    - Source Product Description.</li> <li><code>HdmiIn</code> - HDMI Input</li> <li><code>ALLM</code>   - Auto Low Latency Mode</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the HdmiIn stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Device Settings HdmiIn HAL];\nx[Device Settings HdmiIn HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>DS <code>HdmiIn</code> <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set information about the HDMI input ports such as getting the number of input ports, getting the current status of a selected input port, setting the video scale, selecting which HDMI input to be selected as active and registering callbacks for asynchronous notifications.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>The component must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize this interface by calling <code>dsHdmiInInit()</code> before calling any other <code>APIs</code>. The <code>caller</code> is expected to have complete control over the life cycle of this module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. This interface is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by this interface must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions must not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface must support asynchronous notifications operations:</p> <ul> <li><code>dsHdmiInRegisterConnectCB()</code> must facilitate asynchronous status notifications using the callback when the connection status of the callback <code>dsHdmiInConnectCB_t</code>. This callback must be used when the connection status when the HDMI input port changes.</li> <li><code>dsHdmiInRegisterSignalChangeCB()</code> must facilitate asynchronous status notifications using the callback <code>dsHdmiInSignalChangeCB_t</code>. This callback must be used when the signal status changes.</li> <li><code>dsHdmiInRegisterStatusChangeCB()</code> must facilitate asynchronous status notifications using the callback <code>dsHdmiInStatusChangeCB_t</code>. This callback must be used when the HDMI input status changes.</li> <li><code>dsHdmiInRegisterVideoModeUpdateCB()</code> must facilitate asynchronous status notifications using the callback <code>dsHdmiInVideoModeUpdateCB_t</code>. This callback must be used when the video mode changes. This callback must be used when the ALLM mode changes.</li> <li><code>dsHdmiInRegisterAllmChangeCB()</code> must facilitate asynchronous status notifications using the callback <code>dsHdmiInAllmChangeCB_t</code>.</li> <li><code>dsHdmiInRegisterAVLatencyChangeCB()</code> must facilitate asynchronous notifications using the callback <code>dsAVLatencyChangeCB_t</code> when the AV latency changes.</li> <li><code>dsHdmiInRegisterAviContentTypeChangeCB()</code> must facilitate asynchronous notifications using the call back <code>dsHdmiInAviContentTypeChangeCB_t</code> when HDMI input content type changes.</li> </ul> <p>This interface is allowed to establish its own thread context for its operation, ensuring minimal impact on system resources. Additionally, this interface is responsible for releasing the resources it creates for its operation once the respective operation concludes.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>The <code>API</code> must return error synchronously as a return argument. This interface is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to this interface.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the platform.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for DS as <code>HdmiIn</code> module is a part of DS and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li>Any modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> <code>dsHdmiInInit()</code> before making any other <code>APIs</code> calls.  If <code>dsHdmiInInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>The <code>caller</code> can call <code>dsHdmiInSelectPort()</code>, <code>dsHdmiInScaleVideo()</code>, <code>dsSetEdidVersion()</code> and <code>dsHdmiInSelectZoomMode()</code> to set the needed information.</p> </li> <li> <p>The <code>caller</code> can call <code>dsHdmiInGetNumberOfInputs()</code>, <code>dsHdmiInGetStatus()</code>, <code>dsGetEDIDBytesInfo()</code>, <code>dsIsHdmiARCPort()</code>, <code>dsGetHDMISPDInfo()</code>,  <code>dsGetEdidVersion()</code>, <code>dsGetAllmStatus()</code>, <code>dsGetSupportedGameFeaturesList()</code>, <code>dsGetAVLatency()</code> and <code>dsHdmiInGetCurrentVideoMode()</code> to query the needed information.</p> </li> <li> <p>Callbacks can be set with:</p> <ul> <li><code>dsHdmiInRegisterConnectCB()</code> - used when the HDMIin port connection status changes</li> <li><code>dsHdmiInRegisterSignalChangeCB()</code> - used when the HDMIin signal status changes</li> <li><code>dsHdmiInRegisterStatusChangeCB()</code> - used when the HDMI input status changes</li> <li><code>dsHdmiInRegisterVideoModeUpdateCB()</code> - used when the HDMIin video mode changes</li> <li><code>dsHdmiInRegisterAllmChangeCB()</code> - used when the HDMI input ALLM mode changes</li> <li><code>dsHdmiInRegisterAVLatencyChangeCB()</code> - used when the AV latency changes</li> <li><code>dsHdmiInRegisterAviContentTypeChangeCB()</code> - used when the Avi Content type changes</li> </ul> </li> <li> <p>De-initialize the <code>HAL</code> using <code>dsHdmiInTerm()</code></p> </li> </ol>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS HdmiIn HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsHdmiInInit()\n    Note over HAL: SOC initializes the underlying subsystems\n    HAL-&gt;&gt;Driver:Initializes the underlying subsystems.\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInSelectPort()\n    Note over HAL: Sets the passed port as active and available for presentation\n    HAL-&gt;&gt;Driver:Setting the selected port as active\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInGetStatus()\n    Note over HAL: Gets the status of the current port\n    HAL-&gt;&gt;Driver:Getting the status of the current port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInScaleVideo()\n    Note over HAL: Sets the video scale\n    HAL-&gt;&gt;Driver:Setting the video scale\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetEDIDBytesInfo()\n    Note over HAL: Gets the EDID Bytes info\n    HAL-&gt;&gt;Driver:Getting the EDID Bytes info\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInGetNumberOfInputs()\n    Note over HAL: Gets the number of HDMI inputs\n    HAL-&gt;&gt;Driver:Getting the number of HDMI inputs\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInGetCurrentVideoMode()\n    Note over HAL: Gets the current video mode\n    HAL-&gt;&gt;Driver:Getting the current video mode\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsSetEdidVersion()\n    Note over HAL: Sets the EDID version\n    HAL-&gt;&gt;Driver:Sets the EDID version\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetEdidVersion()\n    Note over HAL: Gets the current EDID Version\n    HAL-&gt;&gt;Driver:Getting the current EDID Version\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetAllmStatus()\n    Note over HAL: Gets the ALLM status\n    HAL-&gt;&gt;Driver:Getting the ALLM status\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetSupportedGameFeaturesList()\n    Note over HAL: Gets the supported game features\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsIsHdmiARCPort()\n    Note over HAL: Gets whether the specified HDMI input port supports ARC\n    HAL-&gt;&gt;Driver:Getting whether the specified HDMI input port supports ARC\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetHDMISPDInfo()\n    Note over HAL: Gets the HDMI SPD info\n    HAL-&gt;&gt;Driver:Getting the HDMI SPD info\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInSelectZoomMode()\n    Note over HAL: Sets the zoom mode\n    HAL-&gt;&gt;Driver:Setting the zoom mode\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetAVLatency()\n    Note over HAL: Gets the AV latency\n    HAL-&gt;&gt;Driver:Getting the AV latency\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterConnectCB()\n    Note over HAL: Creates the callback for when the HDMI connection status changes.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterSignalChangeCB()\n    Note over HAL: Creates the callback for when the HDMI in signal status changes.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterStatusChangeCB()\n    Note over HAL: Creates the callback for when the HDMI in status changes.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterVideoModeUpdateCB()\n    Note over HAL: Creates the callback for when the video mode changes.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterAllmChangeCB()\n    Note over HAL: Creates the callback for when the ALLM mode changes.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterAVLatencyChangeCB()\n    Note over HAL: Creates the callback for when the AV latency changes.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsHdmiInRegisterAviContentTypeChangeCB()\n    Note over HAL: Creates the callback for when the Avi Content type changes.\n    HAL--&gt;&gt;Caller:return\n    Note over HAL: HDMI Input connection status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsHdmiInConnectCB_t callback returned\n    Note over HAL: The HDMI Input signal status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsHdmiInSignalChangeCB_t callback returned\n    Note over HAL: HDMI Input status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsHdmiInStatusChangeCB_t callback returned\n    Note over HAL: Hdmi Input video mode changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsHdmiInVideoModeUpdateCB_t callback returned\n    Note over HAL: HDMI Input mode changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsHdmiInAllmChangeCB_t callback returned\n    Note over HAL: AV latency changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsAVLatencyChangeCB_t callback returned\n    Note over HAL: Avi content type changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsHdmiInAviContentTypeChangeCB_t callback returned\n    Caller -&gt;&gt;HAL:dsHdmiInTerm()\n    Note over HAL: Terminates the underlying sub-systems\n    HAL-&gt;&gt;Driver:Terminates the underlying sub-systems\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-hdmi-in_halSpec/#flow-diagram","title":"Flow Diagram","text":"<pre><code>stateDiagram-v2\nHDPI : HDMI Device Plugged In(Hotplug Callback)\nHSP : HDMI Select Port(from user)\nDS : DefaultSignal\nNSiG : No Signal (Signal Change Callback called if port is not connected)\nUS : Unstable (Signal Change Callback call if connection doesnot stabilize)\nNS : Not supported(signal change callback)\nStable : Stable(signal change callback)\nHDPS : HDMI port started(status change callback)\n\nHDPI --&gt; HSP\nHSP --&gt; DS : Starting at default signal\nDS --&gt; NSiG\nStable --&gt; HDPS\nNSiG --&gt; US : Port connected but unstable signal\nUS --&gt; NS : Connection stabilized but connection not supported\nUS --&gt; Stable : Connection stabilized\nNSiG --&gt; NSiG : No Port Connected\nUS --&gt; US : connection still unstable</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/","title":"Device Settings Host HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Caller Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>API</code></li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>DS</code>     - Device Settings</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>EDID</code>   - Extended Display Information Data</li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>SoC</code>    - System on chip</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the Device Settings Host module.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Device Settings HOST HAL];\nx[Device Settings HOST HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p><code>Device Settings Host</code> <code>HAL</code> provides a set of <code>APIs</code> to initialize, query information about the <code>SoC</code>.</p> <p>The main purpose of this module is to facilitate communication between the <code>caller</code>, and <code>HAL</code> interface, such that information about the Host EDID number, the current CPU temperature, and the SoC ID can be queried by the <code>caller</code>.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>This interface  must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput, and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize <code>dsHost</code> by calling <code>dsHostInit()</code> before calling any other <code>APIs</code>. The <code>caller</code> is expected to have complete control over the life cycle of the this module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. <code>HAL</code> is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by the <code>HAL</code> must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions must not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface is not required to support asynchronous notification.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module:</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the system.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for Device Settings as this module is a part of Device Settings and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li><code>DeviceSettings Host</code> <code>HAL</code> modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> using function: <code>dsHostInit()</code> before making any other <code>API</code> calls.  If <code>dsHostInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>The <code>caller</code> can call <code>dsGetCPUTemperature()</code>, <code>dsGetHostEDID()</code> and <code>dsGetSocIDFromSDK()</code> to query the needed information.</p> </li> <li> <p>De-initialized the <code>HAL</code> using the function: <code>dsHostTerm()</code></p> </li> </ol>"},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-host_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS HOST HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsHostInit()\n    Note over HAL: SOC can initialize the underlying subsystems if needed\n    HAL-&gt;&gt;Driver:Initializing SoC Power Manager\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetCPUTemperature()\n    Note over HAL: Returns the current CPU temp\n    HAL-&gt;&gt;Driver:Getting the current CPU temp\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetSocIDFromSDK()\n    Note over HAL: Returns the SoC ID\n    HAL-&gt;&gt;Driver:Getting the SoC ID\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetHostEDID()\n    Note over HAL: Returns the Host EDID\n    HAL-&gt;&gt;Driver:Getting the Host EDID\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:dsHostTerm()\n    HAL-&gt;&gt;Driver:Terminating SoC Power Manager\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/","title":"DEVICE SETTINGS Video Device HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Caller Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>API</code></li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>DS</code>     - Device Settings</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>EDID</code>   - Extended Display Information Data</li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>SoC</code>    - System on chip</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the Device Settings Video Device module.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Device Settings VIDEO DEVICE HAL];\nx[Device Settings VIDEO DEVICE HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p><code>Device Settings Video Device</code> <code>HAL</code> provides a set of <code>APIs</code> to initialize, query information about the <code>SoC</code>.</p> <p>The main purpose of this module is to facilitate communication between the <code>caller</code> and <code>HAL</code> interface, such that information about the zoom mode, HDR capabilities, Video encoding formats frame rate information and etc can be set and queried.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>This interface  must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput, and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize <code>dsVideoDevice</code> by calling <code>dsVideoDeviceInit()</code> before calling any other <code>APIs</code>. The <code>caller</code> is expected to have complete control over the life cycle of the this module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. <code>HAL</code> is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by the <code>HAL</code> must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions must not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<ul> <li>The <code>dsVideoDevice</code> <code>API</code> <code>dsRegisterFrameratePreChangeCB()</code> should facilitate asynchronous status notifications using the callback before the framerate is changed using the callback <code>dsRegisterFrameratePreChangeCB_t</code>. This callback should used before the framerate is changed.</li> <li>The <code>dsVideoDevice</code> <code>API</code> <code>dsRegisterFrameratePostChangeCB()</code> should facilitate asynchronous status notifications using the callback after the framerate is changed using the callback <code>dsRegisterFrameratePostChangeCB_t</code>. This callback should be used after the framerate has been changed.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module:</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the system.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for Device Settings as this module is a part of Device Settings and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li><code>DeviceSettings Video Device</code> <code>HAL</code> modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> using function: <code>dsVideoDeviceInit()</code> before making any other <code>API</code> calls.  If <code>dsVideoDeviceInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>The <code>caller</code> can call <code>dsGetVideoDevice()</code> to get the handle for a specific video device, to be used in the other function calls.</p> </li> <li> <p>The <code>caller</code> can call <code>dsSetDFC()</code>, <code>dsSetDisplayframerate()</code>, <code>dsSetFRFMode()</code> and <code>dsForceDisableHDRSupport()</code> to set the needed information.</p> </li> <li> <p>The <code>caller</code> can call <code>dsGetDFC()</code>, <code>dsGetHDRCapabilities()</code>, <code>dsGetSupportedVideoCodingFormats()</code>, <code>dsGetVideoCodecInfo()</code>, <code>dsGetFRFMode()</code>, <code>dsGetCurrentDisplayframerate()</code>, to query the needed information.</p> </li> <li> <p>Callbacks can be set with <code>dsRegisterFrameratePreChangeCB()</code> and <code>dsRegisterFrameratePostChangeCB()</code>.</p> <ul> <li><code>dsRegisterFrameratePreChangeCB()</code> is used before the framerate is changed.</li> <li><code>dsRegisterFrameratePostChangeCB()</code> is used after the framerate is changed.</li> </ul> </li> <li> <p>De-initialized the <code>HAL</code> using the function: <code>dsVideoDeviceTerm()</code></p> </li> </ol>"},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-video-device_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS VIDEO DEVICE HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsVideoDeviceInit()\n    Note over HAL: SoC initializes the Video Device subsystem\n    HAL-&gt;&gt;Driver: Allocates required resources for Video Device\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL: ds_Video_Device_SetMethods\n    Note over HAL: APIs to set the Video Device Parameters\n    HAL-&gt;&gt;Driver:Setting the Video Device Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL: ds_Video_Device_GetMethods\n    Note over HAL: APIs to get the Video Device Parameters\n    HAL-&gt;&gt;Driver:Getting the Video Device Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsRegisterFrameratePreChangeCB()\n    Note over HAL: Registers the callback for the pre-change framerate callback\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsRegisterFrameratePostChangeCB()\n    Note over HAL: Registers the callback for the post-change framerate callback\n    HAL--&gt;&gt;Caller:return\n    Driver--&gt;&gt;HAL:Frame rate about to change\n    Note over HAL: Framerate about to change\n    HAL--&gt;&gt;Caller:dsRegisterFrameratePreChangeCB_t callback returned\n    Driver--&gt;&gt;HAL:Framerate has changed\n    Note over HAL: Framerate has changed\n    HAL--&gt;&gt;Caller:dsRegisterFrameratePostChangeCB_t callback returned\n    Caller -&gt;&gt;HAL:dsVideoDeviceTerm()\n    HAL -&gt;&gt; Driver: Releases all the resources allocated during dsVideoDeviceInit()\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/","title":"Device Settings Video Port HAL Documentation","text":""},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Caller Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> <li><code>CPU</code>    - Central Processing Unit</li> <li><code>DS</code>     - Device Settings</li> <li><code>SoC</code>    - System on Chip</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>DTCP</code>   - Digital Transmission Content Protection</li> <li><code>HDCP</code>   - High-bandwidth Digital Content Protection</li> <li><code>HDR</code>    - High Dynamic Range</li> <li><code>SDR</code>    - Standard Dynamic Range</li> <li><code>EDID</code> - Extended Display Identification Data</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the <code>DS</code> Video Port stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Device Settings Video Port HAL];\nx[Device Settings Video Port HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p><code>DS</code> Video Port <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set information about the Video ports like getting  video port handle, fetching connected display information such as color depth, color space, matrix coefficients, quantization range, supported video resolutions using the video port handle. It also provides <code>APIs</code> to enable or disable content protection like <code>HDCP</code> and <code>DTCP</code>, to set the background color and preferred color depth of the video port.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>The interface must adeptly manage resources to prevent issues like memory leaks and excessive utilization. It must also meet performance goals for response time, throughput and resource use as per the platform's capabilities.</p> <p>Failure to meet these requirements will likely result in undefined and unexpected behavior.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize this interface by calling <code>dsVideoPortInit()</code> before calling any other <code>APIs</code>. The <code>caller</code> is expected to have complete control over the life cycle of this module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner. This interface is allowed to create internal threads for its operations without excessively consuming system resources. Any threads created by this interface must be handled gracefully and respective error codes must be returned if any corresponding <code>API</code> fails.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#memory-model","title":"Memory Model","text":"<p>This interface is not required to allocate any memory. Any pointers created by the interface must be cleaned up upon termination.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions must not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface must support asynchronous notifications operations:</p> <ul> <li><code>dsHDCPStatusCallback_t</code> is triggered when the connection status when the HDCP status of video port changes.</li> <li><code>dsVideoFormatUpdateCB</code> is triggered when the video format changes.</li> </ul> <p>This interface is allowed to establish its own thread context for its operation, ensuring minimal impact on system resources. Additionally, this interface is responsible for releasing the resources it creates for its operation once the respective operation concludes.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is not required to have any blocking calls. Synchronous calls must complete within a reasonable time period.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>The <code>API</code> must return error synchronously as a return argument. This interface is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. Caller is responsible to persist any settings related to the HAL.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements will be supported by the module.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface will ensure optimal use of memory and <code>CPU</code> according to the specific capabilities of the platform.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, and FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library for <code>DS</code> as Video Port module is a part of <code>DS</code> and must be named as <code>libdshal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#variability-management","title":"Variability Management","text":"<ul> <li>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</li> <li>Any modification must support backward compatibility for the generic operations like image upgrade and downgrade.</li> <li>This interface must return the dsERR_OPERATION_NOT_SUPPORTED error code, if any of the interface - <code>APIs</code> are not supported by the underlying hardware.</li> </ul>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The configuration settings file for <code>DS</code> Video Port can be used for adding platform specific configurations. The sample files are dsVideoPortSettings_template.h and dsVideoResolutionSettings_template.h</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> <code>dsVideoPortInit()</code> before making any other <code>APIs</code> calls.  If <code>dsVideoPortInit()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>The <code>caller</code> can call <code>dsEnableDTCP()</code>, <code>dsEnableHDCP()</code>, <code>dsEnableVideoPort()</code>, <code>dsSetResolution()</code>, <code>dsSetActiveSource()</code>, <code>dsSetForceDisable4KSupport()</code>, <code>dsSetHdmiPreference()</code>, <code>dsSetBackgroundColor()</code>, <code>dsSetForceHDRMode()</code> and <code>dsSetPreferredColorDepth()</code> to set the needed information.</p> </li> <li> <p>The <code>caller</code> can call <code>dsGetVideoPort()</code>, <code>dsGetSurroundMode()</code>, <code>dsGetResolution()</code>, <code>dsIsVideoPortEnabled()</code>, <code>dsIsDisplayConnected()</code>,  <code>dsIsDisplaySurround()</code>, <code>dsGetSurroundMode()</code>, <code>dsIsVideoPortActive()</code>, <code>dsIsDTCPEnabled()</code> , <code>dsIsHDCPEnabled()</code>, <code>dsGetResolution()</code>, <code>dsGetHDCPStatus()</code>, <code>dsGetHDCPProtocol()</code>, <code>dsGetHDCPReceiverProtocol()</code>, <code>dsGetHDCPCurrentProtocol()</code>, <code>dsGetTVHDRCapabilities()</code>, <code>dsGetForceDisable4KSupport()</code>, <code>dsGetVideoEOTF()</code>, <code>dsGetMatrixCoefficients()</code>, <code>dsGetColorDepth()</code> to query the needed information.</p> </li> <li> <p>Callbacks can be set with:</p> <ul> <li><code>dsRegisterHdcpStatusCallback()</code> is triggered when there is a change in HDCP status of the video port</li> <li><code>dsVideoFormatUpdateCB()</code> is triggered when there is a change in video format of the content</li> </ul> </li> <li> <p>De-initialize the <code>HAL</code> using <code>dsVideoPortTerm()</code>.</p> </li> </ol>"},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/device_settings/docs/pages/ds-video-port_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as DS Video Port HAL\n    participant Driver as SoC\n    Caller-&gt;&gt;HAL:dsVideoPortInit()\n    Note over HAL: SOC initializes the underlying Video Port sub-system\n    HAL-&gt;&gt;Driver:Initializes the Video Port sub-system\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetVideoPort()\n    Note over HAL: Gets the handle for video port\n    HAL-&gt;&gt;Driver:Getting the handle of video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsIsVideoPortEnabled()\n    Note over HAL: Indicates whether video port is enabled or not\n    HAL-&gt;&gt;Driver:Getting the status of the video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsIsDisplayConnected()\n    Note over HAL: Indicates whether video port is connected to display or not\n    HAL-&gt;&gt;Driver: Getting the connection status of display\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsIsDisplaySurround()\n    Note over HAL: Indicates whether connected display supports surround sound\n    HAL-&gt;&gt;Driver: Getting the surround capability of display connected to video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetSurroundMode()\n    Note over HAL: Gets the surround mode of display\n    HAL-&gt;&gt;Driver:Getting the surround mode of display connected to video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsEnableDTCP()\n    Note over HAL: Enables/Disables the DTCP for specified video port\n    HAL-&gt;&gt;Driver: DTCP is enabled / disabled based on input parameter\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsEnableHDCP()\n    Note over HAL: Enables/Disables the HDCP for specified video port\n    HAL-&gt;&gt;Driver: HDCP is enabled / disabled based on input parameter\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsSetResolution()\n    Note over HAL: Sets the resolution of video port\n    HAL-&gt;&gt;Driver: Setting the resolution of display corresponding to specified video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetResolution()\n    Note over HAL: Gets the resolution of video port\n    HAL-&gt;&gt;Driver:Getting the resolution of display corresponding to specified video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetHDCPReceiverProtocol()\n    Note over HAL: Gets the HDCP protocol version of Receiver/TV\n    HAL-&gt;&gt;Driver:Getting the  HDCP protocol version of display corresponding to specified video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetTVHDRCapabilities()\n    Note over HAL: Gets the HDR capabilities of TV\n    HAL-&gt;&gt;Driver:Getting the HDR capabilities of TV/Display corresponding to specified video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsSupportedTvResolutions()\n    Note over HAL: Gets the supported resolutions of TV\n    HAL-&gt;&gt;Driver:Getting the supported resolutions of TV corresponding to specified video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsGetVideoEOTF()\n    Note over HAL: Gets the current Electro-Optical Transfer Function (EOT) value\n    HAL-&gt;&gt;Driver:Getting the EOT function value of display corresponding to specified video port\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsRegisterHdcpStatusCallback()\n    Note over HAL: Creates the callback for getting the HDCP status on HDMI Ports\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:dsVideoFormatUpdateRegisterCB()\n    Note over HAL: Creates the callback for getting the video format updates\n    HAL--&gt;&gt;Caller:return\n    HAL--&gt;&gt;Caller:dsHDCPStatusCallback_t callback returned\n    Note over HAL: The HDCP status changed\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:dsVideoFormatUpdateCB callback returned\n    Note over HAL: Video Format changed\n    Driver--&gt;&gt;HAL:return\n    Caller -&gt;&gt;HAL:dsVideoPortTerm()\n    Note over HAL: Terminates the underlying Video Port sub-system\n    HAL-&gt;&gt;Driver:Terminates the underlying Video Port sub-system\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/device_settings_test/","title":"Unit Testing Suite For Device Settings HAL","text":""},{"location":"external_content/device_settings_test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Reference Documents</li> <li>Notes</li> </ul>"},{"location":"external_content/device_settings_test/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>L1</code>  - Functional Tests</li> <li><code>L2</code>  - Module functional Testing</li> <li><code>L3</code>  - Module testing with External Stimulus is required to validate and control device</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>API</code> - Application Programming Interface</li> <li><code>DS</code>  - Device Settings</li> <li><code>FPD</code> - Front Panel Display</li> <li><code>HDMIIn</code> - HDMI Input</li> <li><code>CompositeIn</code> - Composite Input</li> <li><code>High-Level Test Specification</code> : These specification will provide a broad overview of the system's functionality from the callers' perspective. It focuses on major use cases, system behavior, and overall caller experience.</li> <li><code>Low-Level Test Specification</code> : These specification will delve deeper into the technical details. They will define specific test cases with inputs, expected outputs, and pass/fail criteria for individual functionalities, modules, or APIs.</li> </ul>"},{"location":"external_content/device_settings_test/#description","title":"Description","text":"<p>This repository contains the Unit Test Suites (L1 &amp; L2) for the following submodules of Device Settings  <code>HAL</code> :</p> <ul> <li><code>DS</code> Audio <code>HAL</code></li> <li><code>DS</code> Video Device <code>HAL</code></li> <li><code>DS</code> Video Port <code>HAL</code></li> <li><code>DS</code> Display <code>HAL</code></li> <li><code>DS</code> Front Panel Display <code>HAL</code></li> <li><code>DS</code> Host <code>HAL</code></li> <li><code>DS</code> HDMI Input <code>HAL</code></li> <li><code>DS</code> Composite Input <code>HAL</code></li> </ul>"},{"location":"external_content/device_settings_test/#reference-documents","title":"Reference Documents","text":"SNo Document Name Document Description Document Link 1 Device Settings <code>HAL</code> This document provides specific information on each <code>DS</code> sub-module's <code>APIs</code> for which tests are written in this module <code>DS</code> <code>HAL</code> Guide 2 <code>DS</code> Audio Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Audio module. Refer dsAudio 3 <code>DS</code> Video Device Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Video Device module. Refer dsVideoDevice 4 <code>DS</code> Video Port  Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Video Port  module. Refer dsVideoPort 5 <code>DS</code> Display Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Display module. Refer dsDisplay 6 <code>DS</code> Front Panel Display Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Front Panel Display module. Refer dsFPD 7 <code>DS</code> Host Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Host module. Refer dsHost 8 <code>DS</code> HDMI Input Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> HDMI Input module. Refer dsHdmiIn 9 <code>DS</code> Composite Input Test Suits Specifications <code>L1</code>,<code>L2</code>,<code>L3</code> Test Specification Documentation for <code>DS</code> Composite Input module. Refer dsCompositeIn"},{"location":"external_content/device_settings_test/#l1-l2-l3-testprocedure-documents","title":"<code>L1</code> <code>L2</code> <code>L3</code> TestProcedure Documents","text":"<code>DS</code> Module L1 L2 TestProcedure docs L3 TestProcedure docs dsAudio ds-audio_High-Level_TestSpecification.md, ds-audio_L2_Low-Level_TestSpecification.md ds-audio_High-Level_TestSpecification.md, ds-audio_L3_Low-Level_TestSpecification.md, ds-audio_L3_TestProcedure.md dsDisplay ds-display-high-Level_TestSpec.md,  ds-display-L2-Low-Level_TestSpec.md ds-display-high-Level_TestSpec.md, ds-display_L3_Low-Level_TestSpecification.md, ds-display_L3_TestProcedure.md dsFPD ds-front-panel-display_High-Level_TestSpec.md, ds-front-panel-display_L2_Low-Level_TestSpecification.md ds-front-panel-display_High-Level_TestSpec.md, ds-front-panel-display_L3_Low-Level_TestSpecification.md, ds-front-panel-display_L3_TestProcedure.md dsHost ds-host_High-Level_TestSpecification.md, ds-host_L2_Low-Level_TestSpecification.md ds-host_High-Level_TestSpecification.md,ds-host_L3_TestProcedure.md, ds-host_L3_Low-Level_TestSpec.md dsCompositeIn ds-compositeIn-High-Level_TestSpec.md, ds-compositeIn-L2-Low-Level_TestSpec.md ds-compositeIn-High-Level_TestSpec.md, ds-compositeIn-L3-Low-Level-TestSpec.md, ds-compositeIn-L3-TestProcedure.md dsHdmiIn ds-hdmi-in-High-Level_TestSpec.md, ds-hdmi-in-L2-Low-Level_TestSpec.md ds-hdmi-in-High-Level_TestSpec.md, ds-Hdmi-In_L3_Low-Level_TestSpecification.mdds-hdmi-in_L3_Test-Procedure.md dsVideoDevice ds-video-device_High-Level_TestSpec.md, ds-video-device_L2-Low-Level_TestSpec.md ds-video-device_High-Level_TestSpec.md, ds-video-device_L3_Low-Level_TestSpecification.md, ds-video-device_L3_TestProcedure.md dsVideoPort ds-video-port_High-Level_TestSpec.md, ds-video-port_L2_Low-Level_TestSpecification.md ds-video-port_High-Level_TestSpec.md, ds-video-port_L3_Low-Level_TestSpecification.md, ds-video-port_L3_Test-Procedure.md"},{"location":"external_content/device_settings_test/#notes","title":"Notes","text":"<ul> <li>All APIs in each individual sub-module need to be implemented in this current version. If any API is not supported, please add stub implementation with return type dsERR_OPERATION_NOT_SUPPORTED for the same.</li> <li>Building against the actual library may introduce SOC dependencies. Hence, a template SKELETON library is created without SOC dependencies. On the real platform (target), it can be mounted, copied and bound with the actual library.</li> <li>When executing the binary, ensure to include a platform-specific profile file as an argument for the designated test cases. The following example illustrates this:</li> </ul> <p><code>bash  ./hal_test -p Sink_AudioSettings.yaml</code></p> <p>Alternatively, use the run.sh script with the profile file:</p> <p><code>bash ./run.sh -p /absolute/path/to/profile/file</code></p> <ul> <li>Profiles files defines the configuration for the platform available for sink and source</li> </ul> <code>DS</code> Module Sink Profile yaml Source Profile yaml dsAudio Sink_AudioSettings.yaml Source_AudioSettings.yaml dsDisplay Sink_4K_Display.yaml Source_4K_Display.yaml dsFPD Sink_FPD.yaml Source_FPD.yaml dsHost Sink_HostSettings.yaml Source_HostSettings.yaml dsCompositeIn Sink_CompositeInput.yaml <code>NA</code> dsHdmiIn Sink_HDMIIN.yaml Source_HDMIIN.yaml dsVideoDevice Sink_2K_VideoDevice.yaml Sink_4K_VideoDevice.yaml Source_VideoDevice.yaml dsVideoPort Sink_4K_VideoPort.yaml Source_4K_VideoPort.yaml <ul> <li>Install Python Environment and Activation Scripts please check theHPK Documentation</li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/device_settings_test/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/device_settings_test/CHANGELOG/#350","title":"3.5.0","text":"<ul> <li>gh #280 Updated profile,testcase for Dialog Enhancement <code>#281</code></li> <li>gh #268 CompositeIn L3 testcase for new API <code>#269</code></li> <li>gh #137 dshdmi in l1 l2 dsGetHdmiVersion <code>#147</code></li> <li>gh #270 dsFPD L3 issue fix <code>#271</code></li> <li>gh #227 updated Make file with target=linux <code>#278</code></li> <li>gh #272 change the correct value for bitwise operation <code>#273</code></li> <li>gh #137 Update ds-hdmi-in-High-Level_TestSpec.md <code>b9a1653</code></li> <li>gh #268 L3 testcase for new API <code>602ba66</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#340","title":"3.4.0","text":"<p>28 November 2024</p> <ul> <li>gh #266 Changing the UT Project version to 4.x <code>#267</code></li> <li>gh #262 updating the video port index for the L1 and L2 testcase <code>#265</code></li> <li>gh #260 dsDisplay L1 update <code>#261</code></li> <li>gh #263 : updated dsAudio L3 test procedure document <code>#264</code></li> <li>gh #251 dsHost: L3 Python test updates <code>#259</code></li> <li>Gh #245 dsFPD L3 Python update <code>#250</code></li> <li>gh #249 dsDisplay L3 Python update <code>#252</code></li> <li>gh #248  python l3 hdmiIn enhancement <code>#254</code></li> <li>gh #246 CompositeIn L3 enhancement changes <code>#255</code></li> <li>gh #244 dsVideoPort python improvements <code>#258</code></li> <li>gh #256  Remove Skeleton lib after build <code>#257</code></li> <li>gh #247 dsVideoDevice L3 python enhancement <code>#253</code></li> <li>gh #242 L1 test case for dsCompositeInRegisterVideoModeUpdateCB <code>#243</code></li> <li>gh #233 dsAudio Enhance python tests <code>#234</code></li> <li>gh #247 Python update (Need to test) <code>1b7db7a</code></li> <li>gh #248 HdmiIn L3 python testcases enhancement <code>50a19c8</code></li> <li>gh #262 updating the video port index for the L1 and L2 related test cases <code>932e4b8</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#330","title":"3.3.0","text":"<p>6 November 2024</p> <ul> <li>gh #198 dsVideoDevice L3 Python Test Code <code>#216</code></li> <li>gh #202 l3 hdmiin python testcases <code>#215</code></li> <li>gh #200 dsDisplay L3 Python test cases <code>#208</code></li> <li>gh #201 dsFPD L3 Python Test Code <code>#238</code></li> <li>gh #199 dsCompositeIn L3 Python Test code <code>#210</code></li> <li>gh #205 dsHost L3 Python Test Cases <code>#206</code></li> <li>gh #239 Updated the install script with ut_raft tag <code>#240</code></li> <li>Fix #192 upgraded review comments <code>#192</code></li> <li>Fix #192 - corrected version selection bug <code>#192</code></li> <li>fix #192 - corrected calling ut-core with correct params <code>#192</code></li> <li>gh #198 test case python code <code>5a277c0</code></li> <li>gh #198 addressed review comments <code>ba4350d</code></li> <li>gh #198 updated test cases <code>7d6a383</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#321","title":"3.2.1","text":"<p>5 November 2024</p> <ul> <li>gh #230 L1 Issue fixes - dsAudio <code>#232</code></li> <li>gh #229 VTS - L1 Issue fix -  dsVideoPort  <code>#231</code></li> <li>gh #217 L1 dsVideoDevice Issue fix <code>#218</code></li> <li>gh #236 dsHdmiIn L1 Issue Fix. <code>#237</code></li> <li>gh #192 make file upgrade correcting clean and framework make <code>#193</code></li> <li>Fix #192 upgraded review comments <code>#192</code></li> <li>Fix #192 - corrected version selection bug <code>#192</code></li> <li>fix #192 - corrected calling ut-core with correct params <code>#192</code></li> <li>update #192 - added debugging features <code>6c97a91</code></li> <li>updated #192 - corrected make of ut-core <code>f4940f7</code></li> <li>gh #217 dsVideoDevice L1 Issue fix <code>9f5c1f1</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#320","title":"3.2.0","text":"<p>16 October 2024</p> <ul> <li>gh #226 ds audio update python tests <code>#228</code></li> <li>gh #220: dsAudio L3 Test Procedure document <code>#221</code></li> <li>gh #224 dsVideoPort L3 test procedure documentation <code>#225</code></li> <li>gh #222 Update the README.md <code>#223</code></li> <li>gh #190 dsvideo port l3 C and Python testcase Implementation  <code>#196</code></li> <li>gh #186 : dsAudio L3 development code <code>#187</code></li> <li>gh #212  dsFPD L1 issue fix  <code>#214</code></li> <li>gh #211 l1 issue fix dsDisplay <code>#213</code></li> <li>gh #184: dsFPD  get led state test step update <code>#185</code></li> <li>gh#148 dsVideoDevice L3 test suit code <code>#153</code></li> <li>gh #203 l3 linking issue fix <code>#204</code></li> <li>gh #151 - FPD L3 C Test <code>#155</code></li> <li>gh #145 HdmiIn l3 testcases implementation <code>#149</code></li> <li>gh #194 dshost l3 remove warnings <code>#197</code></li> <li>gh #150 dsDisplay L3 Test case Development  <code>#152</code></li> <li>gh #154 VTS - L3 dsCompisiteIn C-Test Spec and Code Implementation <code>#156</code></li> <li>gh #169 dsDisplay : L3 Low level Test specification <code>#170</code></li> <li>gh #175 Test Spec Document - FPD L3  <code>#176</code></li> <li>gh #179 l3 ds video device test doc <code>#180</code></li> <li>gh #157 dshost l3 c test code generation <code>#177</code></li> <li>gh #171 ds hdmi in l3 highlevl spec <code>#178</code></li> <li>gh #173 L3 ds composite-In Low level Test specification and procedure document <code>#174</code></li> <li>gh #188 VideoPort Updated L3 python Overview <code>#189</code></li> <li>gh #159: dsAudio L3 Python test code <code>#164</code></li> <li>gh #181: L3 C Test: Issues after merging dsAudio dsVideo <code>#182</code></li> <li>gh #115 dsAudio: L3 Test case Development <code>#116</code></li> <li>gh #101 dsAudio: L3 Low level Test specification and procedure document <code>#102</code></li> <li>gh #99 dsVideoPort L3 low-level Spec &amp; implementation  <code>#103</code></li> <li>fix #159 - minor correction to description <code>#159</code></li> <li>gh #190 Updated dsVideoPort python class &amp; add testcase <code>34b7820</code></li> <li>gh #186: dsAudio L3 developement code <code>71c4801</code></li> <li>gh #186: dsAudio L3 developement code <code>7c81638</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#314","title":"3.1.4","text":"<p>20 September 2024</p> <ul> <li>gh #165 UT_ASSERT update for sting Comparison <code>#166</code></li> <li>Bumped CHANGELOG.md - 3.1.4 <code>da7f90f</code></li> <li>gh #165 UT_ASSERT Macro Update <code>1beb712</code></li> <li>Merge tag '3.1.3' into develop <code>29e88ac</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#313","title":"3.1.3","text":"<p>20 September 2024</p> <ul> <li>gh #141 VideoDevice Profile update issue fixes <code>#142</code></li> <li>gh #162: Add helpers folder to python <code>#163</code></li> <li>gh #160: Initial python setup layout <code>#161</code></li> <li>gh #143 Added supported Resolutions for Source device profile file <code>#144</code></li> <li>gh #143 Added supported Resolutions for Source device profile &amp; L2 code <code>9c8f0d8</code></li> <li>gh #141 Update l2 for FRF Mode <code>7d3cdee</code></li> <li>gh #141 L1 Profile Update <code>6832971</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#312","title":"3.1.2","text":"<p>15 August 2024</p> <ul> <li>gh #135 Corrected the kvp function to read number of indicators <code>#136</code></li> <li>Bumped CHANGELOG.md - 3.1.2 <code>8d9864d</code></li> <li>Merge tag '3.1.1' into develop <code>6a17314</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#311","title":"3.1.1","text":"<p>14 August 2024</p> <ul> <li>gh #133 FIx Logic for setFPColor and getFP Color <code>#134</code></li> <li>gh #133 Fixing logic for setFPColor and getFPColor <code>eafd91a</code></li> <li>gh #133 setFPColor, getFPColor logic update <code>2dc5c10</code></li> <li>updated the l1,l2 and yaml files with the review comments <code>4f47564</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#310","title":"3.1.0","text":"<p>13 August 2024</p> <ul> <li>gh #131 added run script &amp; Updated README.md <code>#132</code></li> <li>gh #94 Wrong size for Profile file string parsing <code>#95</code></li> <li>gh #112 code cleanup of dsFPD <code>#130</code></li> <li>gh #110 Code Cleanup of dsHdmiIn <code>#124</code></li> <li>gh #109 code clean up for audio <code>#128</code></li> <li>gh #108 L1 videoport code cleanup <code>#118</code></li> <li>gh #111 Code Cleanup of dsVideoDevice <code>#125</code></li> <li>gh #105 host code cleanup <code>#119</code></li> <li>gh #106 Code Cleanup of dsDisplay <code>#123</code></li> <li>gh #126 Updating source yaml file for display <code>#127</code></li> <li>gh #107 Code Cleanup of CompositeIn <code>#122</code></li> <li>gh #67 Test profile changes for dsFPD <code>#113</code></li> <li>gh #64 Test profile changes for HdmiIn <code>#73</code></li> <li>gh #63 Audio test profile modifications  <code>#114</code></li> <li>gh #120 Feature/gh120 kvp issue <code>#121</code></li> <li>gh #65 Test profile changes for VideoDevice <code>#104</code></li> <li>gh #60 Test profile changes for dsDisplay <code>#74</code></li> <li>gh #61 Test profile changes for dsCompositeIn <code>#80</code></li> <li>gh #89 dsFPD interface updates <code>#92</code></li> <li>gh #87 dshdmiIn interface updates <code>#91</code></li> <li>gh #82 Modified Audio l1 test cases as per latest interface  <code>#93</code></li> <li>gh #51 dsFPD : Enhanced error macro implementation  <code>#59</code></li> <li>gh #83 L1 videoport updated interface changes <code>#90</code></li> <li>gh #84 L1 dsVideoDevice updated interface changes <code>#96</code></li> <li>gh #50 dsCompositeIn: Enhanced error code macro implementation <code>#97</code></li> <li>gh #109 audio module review comments addressal <code>db343ed</code></li> <li>gh #110 Code Cleanup of  dsHdmin <code>249750f</code></li> <li>gh #110 Code Cleanup of  dsHdmin <code>e774ee0</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#301","title":"3.0.1","text":"<p>28 June 2024</p> <ul> <li>gh #78 update flag for source and sink <code>#79</code></li> <li>Bumped CHANGELOG.md - 3.0.1 <code>234c77c</code></li> <li>Merge tag '3.0.0' into develop <code>1f22556</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#300","title":"3.0.0","text":"<p>28 June 2024</p> <ul> <li>gh #76 Updated L2 code, README.md,doxygen <code>#77</code></li> <li>gh #23 ds fp test spec &amp; L2 code <code>#33</code></li> <li>gh #14 dsVideoPort High Level Test Spec &amp; L2 Code <code>#15</code></li> <li>gh #18 dsVideoDevice High Level Test Specification Documentation <code>#20</code></li> <li>gh #24 High Level spec &amp; L2 for Device Settings HDMI input &amp; L2 code <code>#32</code></li> <li>gh #11 DS Display HL changes and YAML changes <code>#48</code></li> <li>gh #7 updating the dsHost test specification and the code <code>#9</code></li> <li>gh #10 L2 code &amp; test spec  <code>#47</code></li> <li>gh #29  dsAudio - L2 Low level Specification and test implementation <code>#71</code></li> <li>gh #29: dsAudio - L2 Low level Specification and test implementation <code>20382e2</code></li> <li>gh #14 Update the L2 code and file names &amp; updated ut version <code>d86fc04</code></li> <li>gh #18 Updated Specification document and test cases <code>e681b80</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#210","title":"2.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #43 deviceSettings: Enhanced Error code for device settings <code>#45</code></li> <li>Updated with enhanced error code disabled checked in test_l1_dsAudio.c <code>#46</code></li> <li>updating the dsDisplay test spec <code>#13</code></li> <li>Adding testing scope changes for composite test spec <code>#16</code></li> <li>revert previous commit <code>b33cd08</code></li> <li>gh #43 remove DS_ASSERT_AUTO_TERM_NUMERICAL <code>0988071</code></li> <li>Enhanced Error code moved to kvp profiler <code>52242e0</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#200","title":"2.0.0","text":"<p>22 March 2024</p> <ul> <li>gh #21 L1 TCs for dsSetAudioMixerLevels API <code>#22</code></li> <li>gh #21 Replaced DS_ASSERT with UT_ASSERT and review comment addressal <code>63cee4e</code></li> <li>gh #21 NULL(Global handle) check moved to positive test <code>c390284</code></li> <li>Update test_l1_dsAudio.c <code>7f1db52</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#103","title":"1.0.3","text":"<p>12 December 2023</p> <ul> <li>Updated HAL and HALTEST supported version in README.md <code>8738deb</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>ef904b6</code></li> <li>Merge tag '1.0.2' into develop <code>8d6a5f5</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#102","title":"1.0.2","text":"<p>11 December 2023</p> <ul> <li>Fixed reference to License in src files <code>afa23b1</code></li> <li>Bumped CHANGELOG.md - 1.0.2 <code>ad72315</code></li> <li>Merge tag '1.0.1' into develop <code>66b92d5</code></li> </ul>"},{"location":"external_content/device_settings_test/CHANGELOG/#101","title":"1.0.1","text":"<p>11 December 2023</p> <ul> <li>baseline version <code>d0dca2e</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>c5a4cfb</code></li> <li>added profiles/include <code>6976044</code></li> </ul>"},{"location":"external_content/device_settings_test/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/","title":"Audio Settings High Level Test Specification Document","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>NA</code>     - Not Applicable</li> <li><code>Y</code>      - Yes</li> <li><code>DS</code>     - Device Settings</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> <li><code>CB</code>     - Call-back function (suffix)</li> <li><code>ARC</code>    - Audio Return Channel</li> <li><code>eARC</code>   - Enhanced Audio Return Channel</li> <li><code>SAD</code>    - Short Audio Descriptor</li> <li><code>SPDIF</code>  - Sony/Philips Digital Interface</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>LE</code>     - Loudness Equivalence</li> <li><code>DRC</code>    - Dynamic Range Control</li> <li><code>MI</code>     - Media Intelligent</li> <li><code>MS12</code>   - MultiStream 12</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>AC3</code>    - Audio Codec 3</li> <li><code>EAC3</code>   - Enhanced <code>AC3</code></li> <li><code>WMA</code>    - Windows Media Audio</li> <li><code>AAC</code>    - Advanced Audio coding</li> <li><code>DD</code>     - DOLBY Digital</li> <li><code>DDPLUS</code> - DOLBY Digital Plus</li> <li><code>DAP</code>    - Digital Audio Processing</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#introduction","title":"Introduction","text":"<p>This document provides an overview of the testing requirements for the Audio Settings module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <ul> <li>Interface of the test is available here - Audio Settings HAL header</li> <li><code>HAL</code> specification in this link - Audio Settings HAL Specification</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#module-description","title":"Module Description","text":"<p>The Audio device setting interface provides control to enable or disable Audio Output ports like TV Internal Speakers, <code>ARC</code>/<code>eARC</code>, Headphones, <code>SPDIF</code> and allows <code>caller</code> to configure or retrieve various audio parameters like <code>MS12</code> <code>DAP</code> Capabilities, <code>MS12</code> audio profile, stereo mode, audio gain, audio delay, fader control, primary language and secondary language.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#testing-scope","title":"Testing Scope","text":"# Test Functionality Description 01 Test Audio Port Test for audio port configuration 02 Test MS12 <code>DAP</code> Capabilities Test for MS12 <code>DAP</code> capabilities like compression, dialogue enhancement, volume mode, intelligent equalizer, bass enhancer Surround decode, <code>DRC</code> mode, Surround Virtualizer, <code>MI</code> Steering, Graphic equalizer, <code>LE</code> configuration 03 Test MS12 Capabilities Test for MS12 capabilities 04 Test <code>ARC</code> Support Sink Device Test for <code>ARC</code> Ports 05 Test Stereo Mode Support Test for Stereo mode configurations 06 Test Audio Gain and Mute Test for audio gain level configurations and mute functionality 07 Test Audio Delay Test for audio delay configuration 08 Test Atmos Mode Test for audio atmos capabilities 09 Test Audio Format Test for Audio Formats 10 Test Associated Audio Mixing Test for Associated Audio Mixing 11 Test Primary/Secondary Language Test for primary/secondary language configuration 12 Test Audio Mixer Levels Test for Primary and secondary Audio mixer levels"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements","title":"Emulator Requirements","text":"<p>Boot configuration: Various Audio ports, audio formats, Stereo modes and <code>Ms12</code> features supported by device</p> <ul> <li>Supported Audio Ports - dsAudioPortType_t</li> <li>Supported Audio Encoding Formats - dsAudioEncoding_t</li> <li>Supported Stereo Modes - dsSetStereoMode</li> <li>Supported <code>MS12</code> <code>DAP</code> Capabilities - dsMS12Capabilities_t</li> <li>Supported <code>MS12</code> Profiles - dsMS12AudioProfileList_t</li> <li>Supported <code>ARC</code> Types - dsAudioARCTypes_t</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#audio-format-requirements-for-playback","title":"Audio Format Requirements for Playback","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-audio-port","title":"Test Audio Port","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through supported audio ports, Enable/disable audio ports and retrieve status for verification dsGetAudioPort(), dsEnableAudioPort(), dsIsAudioPortEnabled() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Enable/disable audio ports and verify using external analyzer with stream playback dsGetAudioPort(), dsEnableAudioPort() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, get the handle for dsAUDIOPORT_TYPE_HEADPHONE port, check the connection status. Connection status should be false dsGetAudioPort(), dsAudioOutIsConnected() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, get the handle for dsAUDIOPORT_TYPE_HEADPHONE port, check the connection status by connecting/disconnecting the port connections. dsGetAudioPort(), dsAudioOutIsConnected() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, get the handle for dsAUDIOPORT_TYPE_HEADPHONE port, Check the connection status with call-back function by connecting/disconnecting the port connection dsGetAudioPort(), dsAudioOutRegisterConnectCB() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-audio-port","title":"Test Startup Requirement - Test Audio Port","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-audio-port","title":"Emulator Requirements - Test Audio Port","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-audio-port","title":"Control Plane Requirements - Test Audio Port","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-ms12-dap-capabilities","title":"Test MS12 <code>DAP</code> Capabilities","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Retrieve the supported MS12 DAP capabilities of the device and verify them with the configuration YAML file. If it is a sink device, retrieve the value from the 'Sink_AudioSettings.yaml' file using the path \"Ports/1/MS12_Capabilities\" supported by the SPEAKER port. If it is a source device, retrieve the value from the 'Source_AudioSettings.yaml' file using the path \"Ports/2/MS12_Capabilities\" supported by the HDMI port. dsGetAudioPort(), dsGetMS12Capabilities() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Set various compression levels for supported ports and retrieve compression levels for verification dsGetAudioPort(), dsSetAudioCompression(), dsGetAudioCompression() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test various compression levels with stream playback. Loop through supported audio ports, Set various compression levels for supported ports and verify with external analyzer dsGetAudioPort(), dsSetAudioCompression() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Dialog Enhancement for supported ports and retrieve Dialog Enhancement for verification dsGetAudioPort(), dsSetDialogEnhancement(), dsGetDialogEnhancement() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Dialog Enhancement for supported ports with stream playback. Loop through supported audio ports, Set Dialog Enhancement for supported ports and verify with external analyzer dsGetAudioPort(), dsSetDialogEnhancement() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set DOLBY Volume Mode for supported ports and retrieve DOLBY Volume Mode for verification dsGetAudioPort(), dsSetDolbyVolumeMode(), dsGetDolbyVolumeMode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test DOLBY Volume Mode for supported ports with stream playback. Loop through supported audio ports, Set DOLBY Volume Mode for supported ports and verify with external analyzer dsGetAudioPort(), dsSetDolbyVolumeMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Intelligent Equalizer Mode for supported ports and retrieve Intelligent Equalizer Mode for verification dsGetAudioPort(), dsSetIntelligentEqualizerMode(), dsGetIntelligentEqualizerMode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Intelligent Equalizer Mode with stream playback. Loop through supported audio ports, Set Intelligent Equalizer Mode for supported ports and verify with external analyzer dsGetAudioPort(), dsSetIntelligentEqualizerMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Volume leveller for supported ports and retrieve Volume leveller for verification dsGetAudioPort(), dsSetVolumeLeveller(), dsGetVolumeLeveller() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Volume leveller for supported ports with stream playback. Loop through supported audio ports, Set Volume leveller for supported ports and verify with external analyzer dsGetAudioPort(), dsSetVolumeLeveller() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Bass Enhancer for supported ports and retrieve Bass Enhancer for verification dsGetAudioPort(), dsSetBassEnhancer(), dsGetBassEnhancer() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Bass Enhancer for supported ports with stream playback. Loop through supported audio ports, Set Bass Enhancer for supported ports and verify with external analyzer dsGetAudioPort(), dsSetBassEnhancer() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Enable Surround Decoder for supported ports and retrieve Surround Decoder status for verification dsGetAudioPort(), dsEnableSurroundDecoder(), dsIsSurroundDecoderEnabled() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Surround Decoder for supported ports with stream playback. Loop through supported audio ports, Set Bass Enhancer for supported ports and verify with external analyzer dsGetAudioPort(), dsEnableSurroundDecoder() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set <code>DRC</code> Mode for supported ports and retrieve <code>DRC</code> Mode for verification dsGetAudioPort(), dsSetDRCMode(), dsGetDRCMode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test <code>DRC</code> Mode for supported ports with stream playback. Loop through supported audio ports, Set <code>DRC</code> Mode for supported ports and verify with external analyzer dsGetAudioPort(), dsSetDRCMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Surround Virtualizer for supported ports and retrieve Surround Virtualizer for verification dsGetAudioPort(), dsSetSurroundVirtualizer(), dsGetSurroundVirtualizer() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Surround Virtualizer for supported ports with stream playback. Loop through supported audio ports, Set Surround Virtualizer for supported ports and verify with external analyzer dsGetAudioPort(), dsSetSurroundVirtualizer() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set <code>MI</code> Steering for supported ports and retrieve <code>MI</code> Steering for verification dsGetAudioPort(), dsSetMISteering(), dsGetMISteering() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test <code>MI</code> Steering for supported ports with stream playback. Loop through supported audio ports, Set <code>MI</code> Steering for supported ports and verify with external analyzer dsGetAudioPort(), dsSetMISteering() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Graphic Equalizer for supported ports and retrieve Graphic Equalizer for verification dsGetAudioPort(), dsSetGraphicEqualizerMode(), dsGetGraphicEqualizerMode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test Graphic Equalizer for supported ports with stream playback. Loop through supported audio ports, Set Graphic Equalizer for supported ports and verify with external analyzer dsGetAudioPort(), dsSetGraphicEqualizerMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Enable/disable audio loudness equivalence and retrieve audio loudness equivalence status for verification dsGetAudioPort(), dsEnableLEConfig(), dsGetLEConfig() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Test audio loudness equivalence for supported ports with stream playback. Loop through supported audio ports, Enable/Disable audio loudness equivalence for supported ports and verify with external analyzer dsGetAudioPort(), dsEnableLEConfig() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-ms12-dap-capabilities","title":"Test Startup Requirement - Test MS12 <code>DAP</code> Capabilities","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-ms12-dap-capabilities","title":"Emulator Requirements - Test MS12 <code>DAP</code> Capabilities","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-ms12-dap-capabilities","title":"Control Plane Requirements - Test MS12 <code>DAP</code> Capabilities","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-ms12-capabilities","title":"Test MS12 Capabilities","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through the supported audio ports and check whether the port supports MS12 decode using the configuration YAML file. For a sink device, retrieve the value from the 'Sink_AudioSettings.yaml' file using the path \"Ports/1/IsMS12Decode\" supported by the SPEAKER port. For a source device, retrieve the value from the 'Source_AudioSettings.yaml' file using the path \"Ports/2/IsMS12Decode\" supported by the HDMI port. dsGetAudioPort(), dsIsAudioMS12Decode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through the supported audio ports and check whether the port supports MS11 decode using the configuration YAML file. For a sink device, retrieve the value from the 'Sink_AudioSettings.yaml' file using the path \"Ports/1/IsMS11Decode\" supported by the SPEAKER port. For a source device, retrieve the value from the 'Source_AudioSettings.yaml' file using the path \"Ports/2/IsMS11Decode\" supported by the HDMI port. dsGetAudioPort(), dsIsAudioMSDecode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Get the supported MS12 audio profiles and verify them with the configuration YAML file. For a sink device, retrieve the value from the 'Sink_AudioSettings.yaml' file using the path \"Ports/1/MS12_AudioProfiles\" supported by the SPEAKER port. For source devices, it is not supported. dsGetAudioPort(), dsGetMS12AudioProfileList() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Get Supported <code>MS12</code> Audio profiles, Loop through supported audio ports, set various audio profiles for supported ports and retrieve audio profile for verification dsGetAudioPort(), dsGetMS12AudioProfileList(), dsSetMS12AudioProfile(), dsGetMS12AudioProfile() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-ms12-capabilities","title":"Test Startup Requirement - Test MS12 Capabilities","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-ms12-capabilities","title":"Emulator Requirements - Test MS12 Capabilities","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-ms12-capabilities","title":"Control Plane Requirements - Test MS12 Capabilities","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-arc-support-sink-device","title":"Test <code>ARC</code> Support Sink Device","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Get the ARC port handle by looping through the supported audio ports, get the ARC type of the connected device, and verify it with the configuration YAML file. For a sink device, retrieve the value from the 'Sink_AudioSettings.yaml' file using the path \"Ports/2/Arc_Types\" as the sink device supports Arc_Types only on the HDMI_ARC port. It does not support for source device. dsGetAudioPort(), dsGetSupportedARCTypes() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> Get the <code>ARC</code> port handle by looping through supported audio ports, enable the <code>ARC</code> Port and check if the audio routed to <code>ARC</code> port using external analyzers dsGetAudioPort(), dsAudioEnableARC() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> Get the <code>ARC</code> port handle by looping through supported audio ports, enable the <code>ARC</code> Port, Set <code>SAD</code> for <code>ARC</code> port and verify using external analyzers dsGetAudioPort(), dsAudioEnableARC(), dsAudioSetSAD() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-arc-support","title":"Test Startup Requirement - Test <code>ARC</code> Support","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-arc-support","title":"Emulator Requirements - Test <code>ARC</code> Support","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-arc-support","title":"Control Plane Requirements - Test <code>ARC</code> Support","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-stereo-mode-support","title":"Test Stereo Mode Support","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through supported audio ports, Set Stereo mode for supported ports and retrieve Stereo mode for verification dsGetAudioPort(), dsSetStereoMode(), dsGetStereoMode() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Set various stereo modes for all supported ports and verify using the external analyzer dsGetAudioPort(), dsSetStereoMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set Stereo Auto mode for supported ports and retrieve it for verification dsGetAudioPort(), dsSetStereoAuto(), dsGetStereoAuto() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Set Auto Stereo mode for all supported ports and verify using the external analyzer dsGetAudioPort(), dsSetStereoAuto() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-stereo-mode-support","title":"Test Startup Requirement - Test Stereo Mode Support","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-stereo-mode-support","title":"Emulator Requirements - Test Stereo Mode Support","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-stereo-mode-support","title":"Control Plane Requirements - Test Stereo Mode Support","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-audio-gain-and-mute","title":"Test Audio Gain and Mute","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through supported audio ports, Set various Linear Audio Gain Values for supported ports and retrieve Audio Gain for verification dsGetAudioPort(), dsSetAudioGain(), dsGetAudioGain() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Set various Linear Audio Gain Values for all supported ports and verify levels using the external analyzer dsGetAudioPort(), dsSetAudioGain() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Set various Audio Levels for supported ports and retrieve Audio Level for verification dsGetAudioPort(), dsSetAudioLevel(), dsGetAudioLevel() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Set various Audio Level for all supported ports and verify using the external analyzer dsGetAudioPort(), dsSetAudioLevel() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> Loop through supported audio ports, Enable/disable audio mute for supported ports and retrieve Mute status for verification dsGetAudioPort(), dsSetAudioMute(), dsIsAudioMute() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Enable/disable audio mute and verify mute status using external analyzer dsGetAudioPort(), dsSetAudioMute() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-audio-gain-and-mute","title":"Test Startup Requirement - Test Audio Gain and Mute","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-audio-gain-and-mute","title":"Emulator Requirements - Test Audio Gain and Mute","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-audio-gain-and-mute","title":"Control Plane Requirements - Test Audio Gain and Mute","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-audio-delay","title":"Test Audio Delay","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through supported audio ports, Set Audio delay for supported ports and retrieve delay for verification dsGetAudioPort(), dsSetAudioDelay(), dsGetAudioDelay() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Set Audio delay for supported ports and measure audio-video delay using external analyzers dsGetAudioPort(), dsSetAudioDelay() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-audio-delay","title":"Test Startup Requirement - Test Audio Delay","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-audio-delay","title":"Emulator Requirements - Test Audio Delay","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-audio-delay","title":"Control Plane Requirements - Test Audio Delay","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-atmos-mode","title":"Test Atmos Mode","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through supported audio ports, Set Atmos for supported ports and analyze with external device dsAudioPortInit(), dsSetAudioAtmosOutputMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> For sink devices, get the ATMOS capabilities of dsAUDIOPORT_TYPE_SPEAKER (internal speaker) and verify them with the configuration YAML file. Retrieve the value from the 'Sink_AudioSettings.yaml' file using the path \"Ports/1/ATMOS_Capabilities\" as the SPEAKER port number is 1. It is not supported for source device. dsGetAudioPort(), dsGetSinkDeviceAtmosCapability() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Get the ATMOS capabilities of connected devices and verify with configuration file. dsGetAudioPort(), dsGetSinkDeviceAtmosCapability() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Register Atmos capability call-back, change the Atmos capabilities of connected device, and check whether the call-back is triggered or not dsAudioAtmosCapsChangeRegisterCB () <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-atmos-mode","title":"Test Startup Requirement - Test Atmos Mode","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-atmos-mode","title":"Emulator Requirements - Test Atmos Mode","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-atmos-mode","title":"Control Plane Requirements - Test Atmos Mode","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-audio-format","title":"Test Audio Format","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Get the audio format of stream played and verify with external analyzer dsGetAudioFormat() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>NA</code> Get the audio capabilities of the device and verify with configuration YAML file. If it is a sink device, the value to be retrieved from the 'Sink_AudioSettings.yaml' file with the path of \"Audio_Capabilities\". For the source devices, the value to be retrieved from the 'Source_AudioSettings.yaml' file with the path of \"Audio_Capabilities\". dsGetAudioCapabilities() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Register a call-back, Change the audio format of playback and check whether call-back is triggered or not dsAudioFormatUpdateRegisterCB(), dsGetAudioFormat() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-audio-format","title":"Test Startup Requirement - Test Audio Format","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-audio-format","title":"Emulator Requirements - Test Audio Format","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-audio-format","title":"Control Plane Requirements - Test Audio Format","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-associated-audio-mixing","title":"Test Associated Audio Mixing","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Loop through supported audio ports, Enable/disable Associated Audio Mixing for supported ports and retrieve it for verification dsGetAudioPort(), dsSetAssociatedAudioMixing(), dsGetAssociatedAudioMixing() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Enable Associated Audio Mixing for supported ports, Set various Fader Control values for supported ports and retrieve it for verification dsGetAudioPort(), dsSetAssociatedAudioMixing(), dsSetFaderControl(), dsGetFaderControl() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through supported audio ports, Test Associate Audio mixing and fader control with stream playback and verify with external analyzer dsGetAudioPort(), dsSetAssociatedAudioMixing(), dsSetFaderControl() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-associated-audio-mixing-test","title":"Test Startup Requirement - Associated Audio Mixing Test","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-associated-audio-mixing-test","title":"Emulator Requirements - Associated Audio Mixing Test","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-associated-audio-mixing-test","title":"Control Plane Requirements - Associated Audio Mixing Test","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-primarysecondary-language","title":"Test Primary/Secondary Language","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Set Primary Language and retrieve the same for verification dsGetAudioPort(), dsSetPrimaryLanguage(), dsGetPrimaryLanguage() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Set Primary Language with stream playback and verify with external analyzer dsGetAudioPort(), dsSetPrimaryLanguage() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Set Secondary Language and retrieve the same for verification dsGetAudioPort(), dsSetSecondaryLanguage(), dsGetSecondaryLanguage() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Set Primary Language with stream playback and verify with external analyzer dsGetAudioPort(), dsSetSecondaryLanguage() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-language-test","title":"Test Startup Requirement - Language Test","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-language-test","title":"Emulator Requirements - Language Test","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-language-test","title":"Control Plane Requirements - Language Test","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-audio-mixer-levels","title":"Test Audio Mixer Levels","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Set Audio mixer levels for Primary and system audio with stream playback and verify with external analyzer dsGetAudioPort(), dsSetAudioMixerLevels() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#test-startup-requirement-test-audio-mixer-levels","title":"Test Startup Requirement - Test Audio Mixer Levels","text":"<p>Playback of stream is required for the L3 testcases. Audio Format Requirements for Playback</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#emulator-requirements-test-audio-mixer-levels","title":"Emulator Requirements -Test Audio Mixer Levels","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_High-Level_TestSpecification/#control-plane-requirements-test-audio-mixer-levels","title":"Control Plane Requirements - Test Audio Mixer Levels","text":"<ul> <li>Control the external analyzer</li> <li>Control the port connections</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/","title":"Audio Settings L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DS</code>     - Device Settings</li> <li><code>ARC</code>    - Audio Return Channel</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>LE</code>     - Loudness Equivalence</li> <li><code>DRC</code>    - Dynamic Range Control</li> <li><code>MI</code>     - Media Intelligent</li> <li><code>MS12</code>   - MultiStream 12</li> <li><code>MS11</code>   - MultiStream 11</li> <li><code>DAP</code>    - Digital Audio Processing</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the Low Level L2 Test Specification and Procedure for the Device Settings Audio module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li>dsAudio HAL Interface - dsAudio.h</li> <li>High Level Test Specification - ds-audio_High-Level_TestSpecification.md</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsAudio_EnableDisableAndVerifyAudioPortStatus</code> Description Loop through supported audio ports, enable/disable audio ports and retrieve status for verification Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Enable audio port using <code>dsEnableAudioPort</code> handle = obtained from <code>dsGetAudioPort</code>, enabled = true <code>dsERR_NONE</code> Should be successful 04 Check if audio port is enabled using <code>dsIsAudioPortEnabled</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code>, enabled = <code>true</code> Should be successful 05 Disable audio port using <code>dsEnableAudioPort</code> handle = obtained from <code>dsGetAudioPort</code>, enabled = <code>false</code> <code>dsERR_NONE</code> Should be successful 06 Check if audio port is disabled using <code>dsIsAudioPortEnabled</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code>, enabled = <code>false</code> Should be successful 07 Terminate audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop: Call dsGetAudioPort &lt;br&gt; for each supported type}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsEnableAudioPort with handle and true]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[Call dsIsAudioPortEnabled with handle]\n    D --&gt;|dsERR_NONE and true|E[Call `dsEnableAudioPort` with handle and false]\n    E --&gt;|dsERR_NONE|F[Call dsIsAudioPortEnabled with handle]\n    F --&gt;|dsERR_NONE and false|B\n    F --&gt;|Fail|F1[Test case fail]\n    F1 --&gt; B\n    B --&gt;|End of loop|G[Call dsAudioPortTerm]\n    G --&gt;|dsERR_NONE|H[Test case success]\n    G --&gt;|Failure|G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsAudio_CheckHeadphoneConnectionStatus_sink</code> Description Loop through supported audio ports, get the handle for <code>dsAUDIOPORT_TYPE_HEADPHONE</code> port, check the connection status. Connection status should be false Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 If the port type is <code>dsAUDIOPORT_TYPE_HEADPHONE</code>, check the connection status using <code>dsAudioOutIsConnected</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 04 Assert that the connection status is false isConnected = <code>false</code> <code>false</code> Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports &lt;br&gt;call dsGetAudioPort}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C{Check if port type is &lt;br&gt; dsAUDIOPORT_TYPE_HEADPHONE}\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|Yes|D[Call dsAudioOutIsConnected with &lt;br&gt; handle from step 3]\n    C --&gt;|No|B\n    B --&gt;|End of loop|E[Call dsAudioPortTerm]\n    D --&gt;|dsERR_NONE and false output|B\n    D --&gt; |Fail|D1[Test case fail]\n    D1 --&gt; B\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsAudio_RetrieveAndVerifyMS12Capabilities</code> Description Retrieve the supported MS12 DAP capabilities of the device and verify them with the configuration file Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Get the MS12 capabilities using <code>dsGetMS12Capabilities</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 04 Compare MS12 capabilities from API and value retrieved from configuration file MS12 capabilities = <code>dsAudio/Port/[port number]/MS12_Capabilities</code> of configuration file Match Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsAudioPortInit API] -- dsERR_NONE --&gt; Step2{Loop through &lt;br&gt; supported audio ports &lt;br&gt;call dsGetAudioPort}\n    Step1 -- Not dsERR_NONE --&gt; Fail1[Test Case Failed]\n    Step2 -- dsERR_NONE and valid handle --&gt; Step3[Call dsGetMS12Capabilities API with the handle]\n    Step2 --&gt;|End of loop|Step6\n    Step2 --&gt;|Not dsERR_NONE or invalid handle|Step2\n    Step3 -- dsERR_NONE and valid capabilities --&gt; Step4[Retrieve MS12 capabilities from configuration file]\n    Step3 -- Not dsERR_NONE or invalid capabilities --&gt; Fail3[Test Case Failed]\n    Step4 --&gt; Step5[Compare capabilities from API and YAML file]\n    Step5 -- Match --&gt; Step2\n    Step5 -- Not Match --&gt; Fail4[Test Case Failed]\n    Fail4 --&gt; Step2\n    Step6 -- dsERR_NONE --&gt; End[Test Case Passed]\n    Step6 -- Not dsERR_NONE --&gt; Fail5[Test Case Failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-4","title":"Test 4","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetAudioCompression</code> Description Loop through supported audio ports, set various compression levels for supported ports and retrieve compression levels for verification Test Group 02 Test Case ID 004 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-4","title":"Test Procedure - Test 4","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 For each port, set various compression levels using <code>dsSetAudioCompression</code> handle = obtained from <code>dsGetAudioPort</code>, compression = 0 to 10. supported compressions = <code>dsAudio/Ports/[port number]/number_of_supported_compressions</code> from configuration file. compression types = <code>dsAudio/Ports/[port number]/compressions</code> of configuration file <code>dsERR_NONE</code> Should be successful 04 Retrieve the set compression level using <code>dsGetAudioCompression</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved compression levels are same compression = set value, getCompression = retrieved value compression should be equal to getCompression Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through the &lt;br&gt;supported audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|Not dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Set various compression level &lt;br&gt; by calling the API dsSetAudioCompression]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|E[Retrieve the compression level&lt;br&gt; call dsGetAudioCompression]\n    E --&gt;|dsERR_NONE and same compression level|B\n    E --&gt;|Fail|E1[Test case fail]\n    E1 --&gt; B\n    B --&gt;|End of loop|F[ call dsAudioPortTerm]\n    F --&gt;|dsERR_NONE|G[Test case success]\n    F --&gt;|Not dsERR_NONE|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-5","title":"Test 5","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetDialogEnhancement</code> Description Loop through supported audio ports, Set Dialog Enhancement for supported ports and retrieve Dialog Enhancement for verification Test Group 02 Test Case ID 005 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-5","title":"Test Procedure - Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 For each audio port, set the Dialog Enhancement level using <code>dsSetDialogEnhancement</code> handle = obtained from <code>dsGetAudioPort</code>, level = 0 to 16 <code>dsERR_NONE</code> Should be successful 04 For each audio port, get the Dialog Enhancement level using <code>dsGetDialogEnhancement</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 05 Verify the set and get Dialog Enhancement levels are same getLevel = obtained from <code>dsGetDialogEnhancement</code>, level = set in <code>dsSetDialogEnhancement</code> getLevel should be equal to level Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|!= dsERR_NONE|A1[Test case fail]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsSetDialogEnhancement with handle and level 0-16]\n    C --&gt;|dsERR_NONE|D[Call dsGetDialogEnhancement with handle]\n    D --&gt;|dsERR_NONE|E[Verify dialog enhancement values ]\n    E --&gt;|Match|B\n    E --&gt;|No Match|E1[Test case fail]\n    E1 --&gt; B\n    B --&gt;|End of loop|F[Call dsAudioPortTerm]\n    F --&gt;|dsERR_NONE|G[Test case success]\n    F --&gt;|!= dsERR_NONE|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-6","title":"Test 6","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetDolbyVolumeMode</code> Description Loop through supported audio ports, Set DOLBY Volume Mode for supported ports and retrieve DOLBY Volume Mode for verification Test Group 02 Test Case ID 006 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-6","title":"Test Procedure - Test 6","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set DOLBY Volume Mode for the retrieved audio port using <code>dsSetDolbyVolumeMode</code> handle = retrieved handle, mode = <code>true</code> <code>dsERR_NONE</code> Should be successful 04 Retrieve DOLBY Volume Mode for the set audio port using <code>dsGetDolbyVolumeMode</code> handle = retrieved handle <code>dsERR_NONE</code> and mode = <code>true</code> Should be successful 05 Set DOLBY Volume Mode for the retrieved audio port using <code>dsSetDolbyVolumeMode</code> handle = retrieved handle, mode = <code>false</code> <code>dsERR_NONE</code> Should be successful 06 Retrieve DOLBY Volume Mode for the set audio port using <code>dsGetDolbyVolumeMode</code> handle = retrieved handle dsERR_NONE and mode = <code>false</code> Should be successful 07 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|!=dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[dsSetDolbyVolumeMode true]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetDolbyVolumeMode]\n    D --&gt;|dsERR_NONE and mode true|E[dsSetDolbyVolumeMode false]\n    E --&gt;|dsERR_NONE|F[dsGetDolbyVolumeMode]\n    F --&gt;|dsERR_NONE and mode false|B\n    F --&gt;|Fail|F1[Test case fail]\n    F1 --&gt; B\n    B --&gt;|End of loop|G[dsAudioPortTerm]\n    G --&gt;|dsERR_NONE|H[Test case success]\n    G --&gt;|!=dsERR_NONE|G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-7","title":"Test 7","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetIntelligentEqualizerMode</code> Description Loop through supported audio ports, Set Intelligent Equalizer Mode for supported ports and retrieve Intelligent Equalizer Mode for verification Test Group 02 Test Case ID 007 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-7","title":"Test Procedure - Test 7","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set Intelligent Equalizer Mode for each supported port using <code>dsSetIntelligentEqualizerMode</code> handle = obtained from <code>dsGetAudioPort</code>, mode = 0 to 6 <code>dsERR_NONE</code> Should be successful 04 Retrieve Intelligent Equalizer Mode for each supported port using <code>dsGetIntelligentEqualizerMode</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved Intelligent Equalizer Mode are same mode = set mode, getMode = retrieved mode mode should be equal to getMode Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[dsAudioPortInit] --&gt;|dsERR_NONE|B{ Loop through supported audio ports &lt;br&gt; call dsGetAudioPort}\nA --&gt;|Failure|A_Fail[Test case fail]\nB --&gt;|dsERR_NONE|C[dsSetIntelligentEqualizerMode, mode 0-6]\nB --&gt;|Not dsERR_NONE or invalid handle|B\nC --&gt;|dsERR_NONE|D[dsGetIntelligentEqualizerMode]\nD --&gt;|dsERR_NONE|E[Compare get and set values]\nE --&gt;|Match|B\nE --&gt;|Fail|E1[Test case fail]\nE1 --&gt; B\nB --&gt;|End of loop|F[dsAudioPortTerm]\nF --&gt;|dsERR_NONE|G[Test case success]\nF --&gt;|Failure|F_Fail[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-8","title":"Test 8","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetVolumeLeveller</code> Description Loop through supported audio ports, set Volume leveller for supported ports and retrieve Volume leveller for verification Test Group 02 Test Case ID 008 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-8","title":"Test Procedure - Test 8","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set the volume leveller for the retrieved audio port using <code>dsSetVolumeLeveller</code> handle = retrieved handle, volLeveller = <code>dsERR_NONE</code> Should be successful 04 Retrieve the volume leveller for the same audio port using <code>dsGetVolumeLeveller</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved volume leveller are same volLevellerSet.mode = volLevellerGet.mode, volLevellerSet.level = volLevellerGet.level volLevellerSet.mode, volLevellerSet.level Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[dsSetVolumeLeveller]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetVolumeLeveller]\n    D --&gt; D1[Compare the Volume leveller]\n    D1 --&gt; |Fail|D2[Test case fail]\n    D2 --&gt; B\n    D1 --&gt;|dsERR_NONE and same structure|B\n    B --&gt;|End of loop|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-9","title":"Test 9","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetBassEnhancer</code> Description Loop through supported audio ports, Set Bass Enhancer for supported ports and retrieve Bass Enhancer for verification Test Group 02 Test Case ID 009 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-9","title":"Test Procedure - Test 9","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set Bass Enhancer for the retrieved audio port using <code>dsSetBassEnhancer</code> handle = retrieved handle, boost = 0 to 100 <code>dsERR_NONE</code> Should be successful 04 Retrieve Bass Enhancer for the same audio port using <code>dsGetBassEnhancer</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved Bass Enhancer values are same setBoost = retrieved boost setBoost Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop dsGetAudioPort &lt;br&gt; through audio ports }\n    A --&gt;|!= dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE|C[dsSetBassEnhancer boost 0-100]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetBassEnhancer]\n    D --&gt;|dsERR_NONE|E[Compare get and set values]\n    E --&gt;|Fail|E1[Test case fail]\n    E1 --&gt; B\n    E --&gt;|Match|B\n    B --&gt;|End of loop|F[dsAudioPortTerm]\n    F --&gt;|dsERR_NONE|G[Test case success]\n    F --&gt;|!= dsERR_NONE|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-10","title":"Test 10","text":"Title Details Function Name <code>test_l2_dsAudio_EnableAndVerifySurroundDecoder</code> Description Loop through supported audio ports, Enable Surround Decoder for supported ports and retrieve Surround Decoder status for verification Test Group 02 Test Case ID 010 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-10","title":"Test Procedure - Test 10","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Enable Surround Decoder for each supported port using <code>dsEnableSurroundDecoder</code> handle = obtained handle, enabled = <code>true</code> <code>dsERR_NONE</code> Should be successful 04 Retrieve Surround Decoder status for each port using <code>dsIsSurroundDecoderEnabled</code> handle = obtained handle, enabled = valid buffer <code>dsERR_NONE</code> and enabled = <code>true</code> Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|!= dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsEnableSurroundDecoder]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[Call dsIsSurroundDecoderEnabled]\n    D --&gt;|Not dsERR_NONE or enabled false|D1[Test case fail]\n    D1 --&gt; B\n    D --&gt;|dsERR_NONE and enabled true|B\n    B --&gt;|End of loop|E[Call dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|!= dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-11","title":"Test 11","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetDRCMode</code> Description Loop through supported audio ports, Set <code>DRC</code> Mode for supported ports and retrieve <code>DRC</code> Mode for verification Test Group 02 Test Case ID 011 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-11","title":"Test Procedure - Test 11","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 For each valid audio port handle, loop through all <code>DRC</code> modes (0 and 1), set the <code>DRC</code> mode using <code>dsSetDRCMode</code> handle = valid handle, mode = 0 or 1 <code>dsERR_NONE</code> Should be successful 04 For each set <code>DRC</code> mode, get the <code>DRC</code> mode using <code>dsGetDRCMode</code> handle = valid handle <code>dsERR_NONE</code> Should be successful 05 Verify the set and get <code>DRC</code> modes are equal getMode = mode mode Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through supported &lt;br&gt; audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|!= dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[dsSetDRCMode mode 0 to 1]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetDRCMode]\n    D --&gt;|dsERR_NONE and same mode as set|B\n    D --&gt;|not dsERR_NONE or mode not match|D1[Test case fail]\n    D1 --&gt; B\n    B --&gt;|End of loop|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|!= dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-12","title":"Test 12","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetSurroundVirtualizer</code> Description Loop through supported audio ports, Set Surround Virtualizer for supported ports and retrieve Surround Virtualizer for verification Test Group 02 Test Case ID 012 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-12","title":"Test Procedure - Test 12","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set Surround Virtualizer for the retrieved audio port using <code>dsSetSurroundVirtualizer</code> handle = retrieved handle, virtualizer = <code>dsERR_NONE</code> Should be successful 04 Retrieve Surround Virtualizer for the same audio port using <code>dsGetSurroundVirtualizer</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved Surround Virtualizer are same mode: (0-1), boost: (0-96 in steps of 16) <code>dsERR_NONE</code> Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through the &lt;br&gt; supported audio ports &lt;br&gt; call dsGetAudioPort }\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE and a valid handle|C[dsSetSurroundVirtualizer API]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetSurroundVirtualizer API]\n    D --&gt;|dsERR_NONE and values match|B\n    D --&gt;|not dsERR_NONE or values don't match|D1[Test case fail]\n    D1 --&gt; B\n    B --&gt;|End of loop|E[dsAudioPortTerm API]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-13","title":"Test 13","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetMISteering</code> Description Loop through supported audio ports, set <code>MI</code> Steering for supported ports and retrieve <code>MI</code> Steering for verification Test Group 02 Test Case ID 013 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-13","title":"Test Procedure - Test 13","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set <code>MI</code> Steering for the retrieved audio port using <code>dsSetMISteering</code> handle = retrieved handle, enabled = <code>true</code> <code>dsERR_NONE</code> Should be successful 04 Retrieve <code>MI</code> Steering for the audio port using <code>dsGetMISteering</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Verify the <code>MI</code> Steering status enabled = retrieved status <code>true</code> Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|!= dsERR_NONE|AF[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[dsSetMISteering]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetMISteering]\n    D --&gt;|dsERR_NONE and enabled = true|B\n    D --&gt;|not dsERR_NONE or enabled = false|D1[Test case fail]\n    D1 --&gt; B\n    B --&gt;|End of loop|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case pass]\n    E --&gt;|!= dsERR_NONE|EF[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-14","title":"Test 14","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetGraphicEqualizerMode</code> Description Loop through supported audio ports, Set Graphic Equalizer for supported ports and retrieve Graphic Equalizer for verification Test Group 02 Test Case ID 014 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-14","title":"Test Procedure - Test 14","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 For each audio port, set the Graphic Equalizer mode using <code>dsSetGraphicEqualizerMode</code> handle = obtained from <code>dsGetAudioPort</code>, mode = 0 to 3 <code>dsERR_NONE</code> Should be successful 04 For each audio port, get the Graphic Equalizer mode using <code>dsGetGraphicEqualizerMode</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 05 Verify the set and get Graphic Equalizer mode are same mode = set mode, getMode = obtained from <code>dsGetGraphicEqualizerMode</code> mode should be equal to getMode Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through audio ports &lt;br&gt; call dsGetAudioPort}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE|C[dsSetGraphicEqualizerMode mode 0 to 3]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetGraphicEqualizerMode]\n    D --&gt;|dsERR_NONE, set and get match|B\n    D --&gt;|not dsERR_NONE or set and get don't match|D1[Test case fail]\n    D1 --&gt; B\n    B --&gt;|End of loop|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-15","title":"Test 15","text":"Title Details Function Name <code>test_l2_dsAudio_EnableDisableAndRetrieveLEConfig</code> Description Loop through supported audio ports, enable/disable audio loudness equivalence and retrieve audio loudness equivalence status for verification Test Group 02 Test Case ID 015 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-15","title":"Test Procedure - Test 15","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Enable loudness equivalence configuration using <code>dsEnableLEConfig</code> handle = obtained handle, enable = <code>true</code> <code>dsERR_NONE</code> Should be successful 04 Retrieve loudness equivalence configuration using <code>dsGetLEConfig</code> handle = obtained handle <code>dsERR_NONE</code> and enable = <code>true</code> Should be successful 05 Disable loudness equivalence configuration using <code>dsEnableLEConfig</code> handle = obtained handle, enable = <code>false</code> <code>dsERR_NONE</code> Should be successful 06 Retrieve loudness equivalence configuration using <code>dsGetLEConfig</code> handle = obtained handle <code>dsERR_NONE</code> and enable = <code>false</code> Should be successful 07 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports &lt;br&gt; Call dsGetAudioPort}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsEnableLEConfig &lt;br&gt; with enable as true]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[Call dsGetLEConfig]\n    D --&gt;|dsERR_NONE and enable as true|E[Call dsEnableLEConfig  &lt;br&gt; with enable as false]\n    E --&gt;|dsERR_NONE|F[Call dsGetLEConfig]\n    F --&gt;|not dsERR_NONE or &lt;br&gt; enable as true|F1[Test case fail]\n    F1 --&gt; B\n    F --&gt;|dsERR_NONE and &lt;br&gt; enable as false|B\n    B --&gt;|End of loop|G[Call dsAudioPortTerm]\n    G --&gt;|dsERR_NONE|H[Test case success]\n    G --&gt;|Failure|G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-16","title":"Test 16","text":"Title Details Function Name <code>test_l2_dsAudio_CheckMS12DecodeSupport</code> Description Loop through the supported audio ports and check whether the port supports <code>MS12</code> decode using the configuration file Test Group 02 Test Case ID 016 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-16","title":"Test Procedure - Test 16","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Check if the port supports <code>MS12</code> decode using <code>dsIsAudioMS12Decode</code> handle <code>dsERR_NONE</code> Should be successful 04 Compare configuration value with <code>dsIsAudioMS12Decode</code> value from API MS12 support =  <code>dsAudio/Port/[port number]/IsMS12Decode</code> of configuration file Matches Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports}\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    B --&gt;|dsERR_NONE and valid handle|D[Call dsIsAudioMS12Decode]\n    D --&gt;|dsERR_NONE and boolean value|E[Retrieve value from configuration]\n    E --&gt; F[Compare configuration value with dsIsAudioMS12Decode value]\n    F --&gt;|Fail| F1[Test case fail]\n    F1 --&gt; B\n    F --&gt;|Match|B\n    B --&gt;|End of loop|I[Call dsAudioPortTerm]\n    I --&gt;|dsERR_NONE|J[Test case success]\n    A --&gt;|Not dsERR_NONE|K[Test case fail]\n    I --&gt;|Not dsERR_NONE|N[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-17","title":"Test 17","text":"Title Details Function Name <code>test_l2_dsAudio_CheckMS11DecodeSupport</code> Description Loop through the supported audio ports and check whether the port supports <code>MS11</code> decode using the configuration file. Test Group 02 Test Case ID 017 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-17","title":"Test Procedure - Test 17","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Check whether the port supports <code>MS11</code> decode using <code>dsIsAudioMSDecode</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 04 Compare configuration value with <code>dsIsAudioMSDecode</code> value from <code>API</code> MS11 Support =  <code>dsAudio/Port/[port number]/IsMS11Decode</code> of configuration file Matches Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[dsAudioPortInit] --&gt; B{For Each Audio Port}\nB --&gt; C[dsGetAudioPort for SPEAKER port]\nB --&gt;|Not dsERR_NONE or invalid handle|B\nC --&gt;|dsERR_NONE|D[dsIsAudioMSDecode]\nD --&gt;|dsERR_NONE|E[Compare value from configuration file]\nE --&gt;|Fail|E1[Test case fail]\nE1 --&gt; B\nE --&gt;|Match|B\nB--&gt;|End of loop|F[dsAudioPortTerm]\nF --&gt;|dsERR_NONE|H[Test case pass]\nF --&gt;|Not dsERR_NONE|F1[Test case fail]\nA --&gt;|Not dsERR_NONE|A1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-18","title":"Test 18","text":"Title Details Function Name <code>test_l2_dsAudio_VerifyMS12AudioProfiles_sink</code> Description Get the supported <code>MS12</code> audio profiles and verify them with the configuration file Test Group 02 Test Case ID 018 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-18","title":"Test Procedure - Test 18","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 02 Get the MS12 audio profile list using <code>dsGetMS12AudioProfileList</code> handle = valid handle, profiles = valid pointer <code>dsERR_NONE</code> Should be successful 04 Verify the retrieved audio profile list with the expected profile string MS12 audio profile count = <code>dsAudio/Port/[port number]/MS12_AudioProfileCount</code>, MS12 audio profiles =  <code>dsAudio/Port/[port number]/MS12_AudioProfiles</code> of configuration file profiles.audioProfileList = valid profile list Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[dsAudioPortInit] --&gt; B{For Each Audio Port}\nB --&gt;|Not dsERR_NONE or invalid handle|B\nB --&gt;|dsERR_NONE and valid handle|C{Check if port supports &lt;br&gt; MS12 audioprofiles}\nC --&gt;|Yes|D[dsGetMS12AudioProfileList]\nC --&gt;|No|B\nD --&gt;|dsERR_NONE|E[Compare value from configuration file]\nE --&gt; |don't match|E1[Test case fail]\nE1 --&gt; B\nE --&gt;|Match|B\nB--&gt;|End of loop|F[dsAudioPortTerm]\nF --&gt;|dsERR_NONE|H[Test case pass]\nF --&gt;|Not dsERR_NONE|F1[Test case fail]\nA --&gt;|Not dsERR_NONE|A1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-19","title":"Test 19","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetMS12AudioProfile_sink</code> Description Get Supported <code>MS12</code> Audio profiles, loop through supported audio ports, set various audio profiles for supported ports and retrieve audio profile for verification. Test Group 02 Test Case ID 019 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-19","title":"Test Procedure - Test 19","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Get <code>MS12</code> audio profile list using <code>dsGetMS12AudioProfileList</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 04 Loop through all profiles and set <code>MS12</code> audio profile using <code>dsSetMS12AudioProfile</code> handle = obtained from <code>dsGetAudioPort</code>, profile = profileName <code>dsERR_NONE</code> Should be successful 05 Get <code>MS12</code> audio profile using <code>dsGetMS12AudioProfile</code> handle = obtained from <code>dsGetAudioPort</code> <code>dsERR_NONE</code> Should be successful 06 Assert that the set and get profiles are equal profile = obtained from <code>dsGetMS12AudioProfile</code>, profileName = set in <code>dsSetMS12AudioProfile</code> <code>True</code> Should be successful 07 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through supported audio ports}\nA --&gt;|Failure|A1[Test case fail]\nB --&gt;|dsERR_NONE and valid handle|BC{Check if port supports &lt;br&gt; MS12 audioprofiles}\nB --&gt;|Not dsERR_NONE or invalid handle|B\nBC --&gt;|Yes|C[dsGetMS12AudioProfileList]\nBC --&gt;|No|B\nC --&gt;|dsERR_NONE|D[Loop through supported audio profiles]\nD --&gt;|dsERR_NONE|E[Call dsSetMS12AudioProfile for each profile]\nE --&gt;|dsERR_NONE|F[Call dsGetMS12AudioProfile for each profile]\nF --&gt;|Comparison Fails|F1[Test case fail]\nF1--&gt;B\nF --&gt;|dsERR_NONE|B\nB --&gt;|End of loop|G[Call dsAudioPortTerm]\nG --&gt;|dsERR_NONE|H[Test case success]\nG --&gt;|Failure|G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-20","title":"Test 20","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetStereoMode</code> Description Loop through supported audio ports, set Stereo mode for supported ports and retrieve Stereo mode for verification Test Group 02 Test Case ID 020 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-20","title":"Test Procedure - Test 20","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set the stereo mode for the retrieved audio port handle using <code>dsSetStereoMode</code> handle = retrieved handle, supported Stereo modes = <code>dsAudio/Port/[port number]/stereo_modes</code> of configuration file <code>dsERR_NONE</code> Should be successful 04 Get the stereo mode for the same audio port handle using <code>dsGetStereoMode</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Assert that the retrieved stereo mode is the same as the set stereo mode mode = retrieved mode mode = getmode Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports}\n    A --&gt;|!= dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsSetStereoMode &lt;br&gt; with various stereo modes]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[Call dsGetStereoMode with handle]\n    D --&gt;|Comparison Fails|D1[Test case fail]\n    D1 --&gt; B\n    D --&gt;|dsERR_NONE, set and get matches|B\n    B --&gt;|End of loop|E[Call dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|!= dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-21","title":"Test 21","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetStereoAuto_sink</code> Description Loop through supported audio ports, set Stereo Auto mode for supported ports and retrieve it for verification Test Group 02 Test Case ID 021 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-21","title":"Test Procedure - Test 21","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Check if the port support Stereo auto mode from the <code>Port/[port number]/stereo_auto_mode</code> of configuration file. Set Stereo Auto mode for the retrieved audio port using <code>dsSetStereoAuto</code> handle = retrieved handle, autoMode = 1 <code>dsERR_NONE</code> Should be successful 04 Retrieve the Stereo Auto mode for the same audio port using <code>dsGetStereoAuto</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved Stereo Auto mode are same getAutoMode = retrieved auto mode, autoMode = 1 getAutoMode should be equal to autoMode Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through supported &lt;br&gt; audio ports}\nB --&gt;|dsERR_NONE|C[Call dsSetStereoAuto &lt;br&gt; with autoMode=true]\nB --&gt;|Not dsERR_NONE or invalid handle|B\nC --&gt;|dsERR_NONE|D[Call dsGetStereoAuto with handle]\nD --&gt;|Comparison Fail|D1[Test case fail]\nD1 --&gt; B\nD --&gt;|dsERR_NONE &amp; get and set matches|B\nB --&gt;|End of loop|E[Call dsAudioPortTerm]\nE --&gt;|dsERR_NONE|F[Test case pass]\nE --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-22","title":"Test 22","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetAudioGain_sink</code> Description Loop through supported audio ports, set various Linear Audio Gain Values for supported ports and retrieve Audio Gain for verification Test Group 02 Test Case ID 022 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-22","title":"Test Procedure - Test 22","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set various Linear Audio Gain Values for supported ports using <code>dsSetAudioGain</code> handle = valid handle, gain = -2080 to 480 in steps of 10 <code>dsERR_NONE</code> Should be successful 04 Retrieve Audio Gain for verification using <code>dsGetAudioGain</code> handle = valid handle <code>dsERR_NONE</code>, gain = set gain value Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE|C[dsSetAudioGain with &lt;br&gt;various gain values]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[dsGetAudioGain to &lt;br&gt; retrieve the audio gain value]\n    D --&gt; |Comparison Fail|D1[Test case fail]\n    D1 --&gt; B\n    D --&gt;|dsERR_NONE and &lt;br&gt; gain value matches|B\n    B --&gt;|End of loop|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-23","title":"Test 23","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetAudioLevel_sink</code> Description Loop through supported audio ports, set various Audio Levels for supported ports and retrieve Audio Level for verification Test Group 02 Test Case ID 023 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-23","title":"Test Procedure - Test 23","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set various Audio Levels for the obtained audio port handle using <code>dsSetAudioLevel</code> handle = obtained handle, level = 0 to 100 in steps of 10 <code>dsERR_NONE</code> Should be successful 04 Retrieve the Audio Level for the set level using <code>dsGetAudioLevel</code> handle = obtained handle <code>dsERR_NONE</code>, level = set level Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through the &lt;br&gt; supported audio ports}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Set various audio levels &lt;br&gt; dsSetAudioLevel]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    C --&gt;|dsERR_NONE|D[Retrieve the audio level &lt;br&gt; dsGetAudioLevel]\n    D --&gt;|Comparison Fail|D1[Test case fail]\n    D1 --&gt; B\n    D --&gt;|dsERR_NONE and same audio level|B\n    B --&gt;|End of loop|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case pass]\n    E --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-24","title":"Test 24","text":"Title Details Function Name <code>test_l2_dsAudio_AudioMuteVerification</code> Description Loop through supported audio ports, enable/disable audio mute for supported ports and retrieve Mute status for verification Test Group 02 Test Case ID 024 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-24","title":"Test Procedure - Test 24","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set audio mute to true using <code>dsSetAudioMute</code> handle = obtained handle, mute = true <code>dsERR_NONE</code> Should be successful 04 Verify audio mute status using <code>dsIsAudioMute</code> handle = obtained handle, mute = pointer to mute status <code>dsERR_NONE</code>, mute = <code>true</code> Should be successful 05 Set audio mute to false using <code>dsSetAudioMute</code> handle = obtained handle, mute = <code>false</code> <code>dsERR_NONE</code> Should be successful 06 Verify audio mute status using <code>dsIsAudioMute</code> handle = obtained handle, mute = pointer to mute status <code>dsERR_NONE</code>, mute = <code>false</code> Should be successful 07 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; supported audio ports}\nB -- dsERR_NONE &amp; valid handle --&gt; C[Call dsSetAudioMute with mute=true]\nB --&gt;|Not dsERR_NONE or invalid handle|B\nC -- dsERR_NONE --&gt; D[Call dsIsAudioMute]\nD -- dsERR_NONE &amp; muted=true --&gt; E[Call dsSetAudioMute with mute=false]\nE -- dsERR_NONE --&gt; F[Call dsIsAudioMute]\nF --&gt;|mute != false| F1[Test case fail]\nF1 --&gt; B\nF -- dsERR_NONE &amp; muted=false --&gt; B\nB -- End of loop --&gt; G[Call dsAudioPortTerm]\nG -- dsERR_NONE --&gt; H[Test case success]\nG -- Not dsERR_NONE --&gt; G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-25","title":"Test 25","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetAudioDelay</code> Description Loop through supported audio ports, set Audio delay for supported ports and retrieve delay for verification Test Group 02 Test Case ID 025 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-25","title":"Test Procedure - Test 25","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Set the audio delay for the retrieved audio port using <code>dsSetAudioDelay</code> handle = retrieved handle, delay = 100ms <code>dsERR_NONE</code> Should be successful 04 Retrieve the audio delay for the same audio port using <code>dsGetAudioDelay</code> handle = retrieved handle <code>dsERR_NONE</code> Should be successful 05 Verify the set and retrieved audio delay are same setDelay = 100ms, getDelay = retrieved delay getDelay should be equal to setDelay Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[ dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through the &lt;br&gt; supported audio ports}\n    B --&gt;|dsERR_NONE|D[ call dsSetAudioDelay &lt;br&gt;with delay value]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    D --&gt;|dsERR_NONE|E[call dsGetAudioDelay ]\n    E --&gt;|dsERR_NONE|F[Verify audio delay matches &lt;br&gt; the set audio delay]\n    F --&gt; F1[Test case fail]\n    F1 --&gt;|Comparison Fail| B\n    F --&gt; B\n    B --&gt;|End of Loop|G[ call dsAudioPortTerm]\n    G --&gt;|dsERR_NONE|H[Test case success]\n    A --&gt;|Failure|I[Test case fail]\n    G --&gt;|Failure|M[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-26","title":"Test 26","text":"Title Details Function Name <code>test_l2_dsAudio_VerifyAtmosCapabilities_sink</code> Description For sink devices, get the ATMOS capabilities and verify them with the configuration file Test Group 02 Test Case ID 026 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-26","title":"Test Procedure - Test 26","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported audio ports and get audio port using <code>dsGetAudioPort</code> supported number of audio ports = <code>dsAudio/Number_of_supported_ports</code> field and port id = <code>dsAudio/Port/[port number]/Typeid</code> of configuration file <code>dsERR_NONE</code> Should be successful 03 Get the ATMOS capability of the sink device using <code>dsGetSinkDeviceAtmosCapability</code> handle=valid handle <code>dsERR_NONE</code> Should be successful 04 Verify the ATMOS capability of the sink device ATMOS capabilities = <code>dsAudio/Port/[port number]/ATMOS_Capabilities</code> of configuration file Matches Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[ dsAudioPortInit] --&gt;|dsERR_NONE|B{Loop through the &lt;br&gt; supported audio ports}\n    B --&gt;|dsERR_NONE|D[call dsGetSinkDeviceAtmosCapability]\n    B --&gt;|Not dsERR_NONE or invalid handle|B\n    D --&gt;|dsERR_NONE|E[Verify the ATMOS Capabilities with the configuration file]\n    E --&gt; |Comparison Fail|E1[Test case fail]\n    E1 --&gt; B\n    E --&gt; B\n    B --&gt;|End of Loop|G[ call dsAudioPortTerm]\n    G --&gt;|dsERR_NONE|H[Test case success]\n    A --&gt;|Failure|I[Test case fail]\n    G --&gt;|Failure|M[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-27","title":"Test 27","text":"Title Details Function Name <code>test_l2_dsAudio_GetAudioCapabilities</code> Description Get the audio capabilities of the device and verify with configuration file Test Group 02 Test Case ID 027 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-27","title":"Test Procedure - Test 27","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the audio port using <code>dsGetAudioPort</code> type = Any supported port from the configuration file <code>dsAudio/Port/[port number]/Typeid</code> <code>dsERR_NONE</code> Should be successful 03 Get the audio capabilities using <code>dsGetAudioCapabilities</code> with the handle obtained from previous step handle = obtained from step 02 <code>dsERR_NONE</code> Should be successful 04 Verify the obtained capabilities with the expected value from the configuration file Read audio capabilities from the <code>Audio_Capabilities</code> of configuration file capabilities = obtained from step 03 Should be successful 05 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|return dsERR_NONE|B[Call dsGetAudioPort with &lt;br&gt; supported port]\n    A --&gt;|return not dsERR_NONE|A1[Test case fail]\n    B --&gt;|return dsERR_NONE|C[Call dsGetAudioCapabilities]\n    B --&gt;|return not dsERR_NONE|B1[Test case fail]\n    C --&gt;|return dsERR_NONE|D[Compare obtained audio capabilities with yaml file]\n    C --&gt;|return not dsERR_NONE|C1[Test case fail]\n    D --&gt;|Values match|E[Call dsAudioPortTerm]\n    D --&gt;|Values do not match|D1[Test case fail]\n    E --&gt;|return dsERR_NONE|F[Test case success]\n    E --&gt;|return not dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-28","title":"Test 28","text":"Title Details Function Name <code>test_l2_dsAudio_EnableDisableRetrieveAudioMixing</code> Description Loop through supported audio ports, Enable/disable Associated Audio Mixing for supported ports and retrieve it for verification Test Group 02 Test Case ID 028 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-28","title":"Test Procedure - Test 28","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the audio port using <code>dsGetAudioPort</code> type = Any supported port from the configuration file <code>dsAudio/Port/[port number]/Typeid</code> <code>dsERR_NONE</code> Should be successful 03 Enable Associated Audio Mixing for the retrieved port using <code>dsSetAssociatedAudioMixing</code> handle = retrieved handle, mixing = true <code>dsERR_NONE</code> Should be successful 04 Retrieve the Associated Audio Mixing status using <code>dsGetAssociatedAudioMixing</code> handle = retrieved handle, mixing = pointer to bool <code>dsERR_NONE</code> and mixing = <code>true</code> Should be successful 05 Disable Associated Audio Mixing for the retrieved port using <code>dsSetAssociatedAudioMixing</code> handle = retrieved handle, mixing = <code>false</code> <code>dsERR_NONE</code> Should be successful 06 Retrieve the Associated Audio Mixing status using <code>dsGetAssociatedAudioMixing</code> handle = retrieved handle, mixing = pointer to bool <code>dsERR_NONE</code> and mixing = <code>false</code> Should be successful 07 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsAudioPortInit] --&gt;|dsERR_NONE|B[Get audio port]\n    A --&gt;|Failure|AF[Test case fail]\n    B --&gt;|dsERR_NONE|C[Call dsSetAssociatedAudioMixing to &lt;br&gt; enable and disable audio mixing]\n    C --&gt; |!dsERR_NONE|C1[Test case fail]\n    C --&gt;|dsERR_NONE|D[Call dsGetAssociatedAudioMixing to &lt;br&gt; retrieve audio mixing status]\n    D --&gt; |Comparison Fail|D1[Test case fail]\n    D --&gt;|dsERR_NONE &amp; get and set matches|E[dsAudioPortTerm]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Failure|EF[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-29","title":"Test 29","text":"Title Details Function Name <code>test_l2_dsAudio_AudioPortControl</code> Description Loop through supported audio ports, Enable Associated Audio Mixing for supported ports, Set various Fader Control values for supported ports and retrieve it for verification Test Group 02 Test Case ID 029 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-29","title":"Test Procedure - Test 29","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the audio port using <code>dsGetAudioPort</code> type = Any supported port from the configuration file <code>dsAudio/Port/[port number]/Typeid</code> <code>dsERR_NONE</code> Should be successful 03 Enable Associated Audio Mixing for the retrieved port using <code>dsSetAssociatedAudioMixing</code> handle = retrieved handle, mixing = true <code>dsERR_NONE</code> Should be successful 04 Set various Fader Control values for the retrieved port using <code>dsSetFaderControl</code> handle = retrieved handle, mixerbalance = -32 to 32 in steps of 8 <code>dsERR_NONE</code> Should be successful 05 Retrieve the Fader Control value for verification using <code>dsGetFaderControl</code> handle = retrieved handle, getMixerbalance = buffer to store the retrieved value <code>dsERR_NONE</code>, getMixerbalance = mixerbalance Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[dsAudioPortInit] --&gt;|dsERR_NONE|B[Get audio port]\nB --&gt;|dsERR_NONE|C[dsSetAssociatedAudioMixing]\nC --&gt; |!dsERR_NONE|C1[Test case fail]\nC --&gt;|dsERR_NONE|D[dsSetFaderControl]\nD --&gt; |!dsERR_NONE|D1[Test case fail]\nD --&gt;|dsERR_NONE|E[dsGetFaderControl]\nE --&gt; |Comparison Fail|E1[Test case fail]\nE --&gt;|dsERR_NONE &amp; &lt;br&gt;get and set matches|I[dsAudioPortTerm]\nI --&gt;|dsERR_NONE|J[Test case success]\nI --&gt;|!= dsERR_NONE|K[Test case fail]\nA --&gt;|!= dsERR_NONE|L[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-30","title":"Test 30","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetPrimaryLanguage</code> Description Set Primary Language and retrieve the same for verification Test Group 02 Test Case ID 030 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-30","title":"Test Procedure - Test 30","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the audio port using <code>dsGetAudioPort</code> type = Any supported port from the configuration file <code>dsAudio/Port/[port number]/Typeid</code> <code>dsERR_NONE</code> Should be successful 03 Set the primary language using <code>dsSetPrimaryLanguage</code> with handle and valid language code handle = obtained handle, setLang = \"eng\" <code>dsERR_NONE</code> Should be successful 04 Get the primary language using <code>dsGetPrimaryLanguage</code> with handle handle = obtained handle, getLang = valid buffer <code>dsERR_NONE</code> Should be successful 05 Verify the set and get languages are same setLang = \"eng\", getLang = obtained language setLang should be equal to getLang Should be successful 06 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsAudioPortInit] --&gt;|dsERR_NONE|B[Call dsGetAudioPort]\nA --&gt;|!=dsERR_NONE|A1[Test case fail]\nB --&gt;|dsERR_NONE and valid handle|C[Call dsSetPrimaryLanguage]\nB --&gt;|!=dsERR_NONE or invalid handle|B1[Test case fail]\nC --&gt;|dsERR_NONE|D[Call dsGetPrimaryLanguage]\nC --&gt;|!=dsERR_NONE|C1[Test case fail]\nD --&gt;|dsERR_NONE and same language code|E[Call dsAudioPortTerm]\nD --&gt;|!=dsERR_NONE or different language code|D1[Test case fail]\nE --&gt;|dsERR_NONE|F[Test case success]\nE --&gt;|!=dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-31","title":"Test 31","text":"Title Details Function Name <code>test_l2_dsAudio_SetAndGetSecondaryLanguage</code> Description Set Secondary Language and retrieve the same for verification Test Group 02 Test Case ID 031 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L2_Low-Level_TestSpecification/#test-procedure-test-31","title":"Test Procedure - Test 31","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the audio port using <code>dsAudioPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the audio port using <code>dsGetAudioPort</code> type = Any supported port from the configuration file <code>dsAudio/Port/[port number]/Typeid</code> <code>dsERR_NONE</code> Should be successful 03 Set the secondary language using <code>dsSetSecondaryLanguage</code> handle = obtained handle, language = \"eng\" <code>dsERR_NONE</code> Should be successful 04 If setting secondary language fails, terminate the audio port using <code>dsAudioPortTerm</code> and return None <code>dsERR_NONE</code> Should be successful 05 Get the secondary language using <code>dsGetSecondaryLanguage</code> handle = obtained handle, language = valid buffer <code>dsERR_NONE</code> Should be successful 06 Verify the set and get languages are same setLang = \"eng\", getLang = obtained language setLang should be equal to getLang Should be successful 07 Terminate the audio port using <code>dsAudioPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsAudioPortInit] --&gt;|dsERR_NONE|B[Call dsGetAudioPort]\nA --&gt;|!=dsERR_NONE|A1[Test case fail]\nB --&gt;|dsERR_NONE|C[Call dsSetSecondaryLanguage]\nB --&gt;|!=dsERR_NONE|B1[Test case fail]\nC --&gt;|dsERR_NONE|D[Call dsGetSecondaryLanguage]\nC --&gt;|!=dsERR_NONE|C1[Test case fail]\nD --&gt;|dsERR_NONE &amp; get and set same|E[Call dsAudioPortTerm]\nD --&gt;|!=dsERR_NONE|D1[Test case fail]\nE --&gt;|dsERR_NONE|F[Test case pass]\nE --&gt;|!=dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/","title":"Audio Settings L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>References</li> <li>Audio Streams Requirement</li> <li>Level 3 Test Procedure</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DS</code>     - Device Settings</li> <li><code>ARC</code>    - Audio Return Channel</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>LE</code>     - Loudness Equivalence</li> <li><code>DRC</code>    - Dynamic Range Control</li> <li><code>MI</code>     - Media Intelligent</li> <li><code>MS12</code>   - MultiStream 12</li> <li><code>MS11</code>   - MultiStream 11</li> <li><code>DAP</code>    - Digital Audio Processing</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>WAV</code>    - Waveform</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>NA</code>     - Not Applicable</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Test Procedure for the Device Settings Audio module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li>dsAudio HAL Interface - dsAudio.h</li> <li>High Level Test Specification - ds-audio_High-Level_TestSpecification.md</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#audio-streams-requirement","title":"Audio Streams Requirement","text":"# Stream Name Description 01 tones_string_48k_stereo.ac3 <code>AC3</code> format audio with tones (single notes) across various frequencies 02 Dolby_stream_supports_Dialogue_Enhancer <code>AC4</code> format audio with speech frequencies, designed to test the dialogue enhancer feature 03 music_8k_stereo.ac3 <code>AC3</code> format audio with music, used to test features like the equalizer 04 tone_500Hz_compress_48k_stereo.ac3 <code>AC3</code> format with a 500Hz tone, which alternates between two volume levels (-25dB and -5dB), useful for compression and dynamic range testing 05 tone_bassrange_150Hz_48k_stereo.ac3 <code>AC3</code> format with a 150Hz tone at -10dB 06 Dolby_atmos_stream_supports_surround_mode Dolby <code>AC4</code>, <code>EAC3_ATMOS</code>, and <code>AC4_ATMOS</code> formats to test surround sound mode 07 tones_string_48k_stereo.wav <code>WAV</code> (<code>PCM</code>) format with tones across various frequencies 08 tones_string_48k_stereo.eac3 <code>EAC3</code> format with tones across various frequencies 09 tones_string_48k_stereo.aac <code>AAC</code> format with tones across various frequencies 10 tones_string_48k_stereo.ogg <code>VORBIS</code> format with tones across various frequencies 11 tones_string_48k_stereo.wma <code>WMA</code> format with tones across various frequencies 12 Audio_supports_MAT_format Dolby <code>MAT</code> format 13 Dolby_audio_supports_TRUEHD_format Dolby <code>TRUEHD</code> format 14 DolbyDigitalPlus_atmos_audio Dolby <code>EAC3_ATMOS</code> format 15 TRUEHD_atmos_audio Dolby <code>TRUEHD_ATMOS</code> format 16 MAT_atmos_audio Dolby <code>MAT_ATMOS</code> format 17 Dolby_atmos_audio Dolby <code>AC4_ATMOS</code> format 18 Dolby_stream_supports_AVsync Dolby stream specifically designed to test <code>AV</code> synchronization 19 Dolby_stream_supports_Multi-Language <code>AC4</code> format with three language tracks (Chinese, English, and Spanish) and additional audio options, used to test multi-language audio capabilities 20 primary_audio_48k_2ch.ac3 <code>AC3</code> format with two-channel audio (stereo) containing dialogue 21 system_audio_48k_2ch.wav <code>WAV</code> (<code>PCM</code>) format with two-channel audio containing dialogue"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Below are top test use-case for the audio port.</p> # Test-case Description HAL APIs Source Sink Streams Number 1 Enable/disable audio ports Play the predefined audio streams. Iterate through the supported audio ports, enabling or disabling them, and check if the stream is being played through each port <code>dsEnableAudioPort()</code> <code>Y</code> <code>Y</code> 01 2 Verify the Headphone connection status Enable the headphone port and verify the connection status by disconnecting and reconnecting the port. Additionally, confirm if the callback is triggered <code>dsAudioOutIsConnected()</code> <code>N</code> <code>Y</code> <code>NA</code> 3 Verify MS12 Audio Compression Loop through the ports which supports Audio Compression and verify <code>dsSetAudioCompression()</code> <code>Y</code> <code>Y</code> 01 4 Verify MS12 <code>DAP</code> Dialog enhancement Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Dialog enhancement <code>dsSetDialogEnhancement()</code> <code>Y</code> <code>Y</code> 02 5 Verify MS12 <code>DAP</code> Dolby Volume mode Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Dolby Volume mode <code>dsSetDolbyVolumeMode()</code> <code>Y</code> <code>Y</code> 01 6 Verify MS12 <code>DAP</code> Intelligent Equalizer Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify the Intelligent Equalizer <code>dsSetIntelligentEqualizerMode()</code> <code>Y</code> <code>Y</code> 03 7 Verify MS12 <code>DAP</code> Volume leveller Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Volume leveller <code>dsSetVolumeLeveller()</code> <code>Y</code> <code>Y</code> 04 8 Verify MS12 <code>DAP</code> Bass enhancer Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Bass enhancer <code>dsSetBassEnhancer()</code> <code>Y</code> <code>Y</code> 05 9 Verify MS12 <code>DAP</code> Surround Decoder Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Surround Decoder <code>dsEnableSurroundDecoder()</code> <code>Y</code> <code>Y</code> 06 10 Verify MS12 <code>DAP</code> <code>DRC</code> Mode Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify <code>DRC</code> Mode <code>dsSetDRCMode()</code> <code>Y</code> <code>Y</code> 04 11 Verify MS12 <code>DAP</code> Surround Virtualizer Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Surround Virtualizer <code>dsSetSurroundVirtualizer()</code> <code>Y</code> <code>Y</code> 06 12 Verify MS12 <code>DAP</code> <code>MI</code> Steering Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify <code>MI</code> Steering <code>dsSetMISteering()</code> <code>Y</code> <code>Y</code> 01 13 Verify MS12 <code>DAP</code> Graphics Equalizer Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify Graphics Equalizer <code>dsSetGraphicEqualizerMode()</code> <code>Y</code> <code>Y</code> 01 14 Verify MS12 <code>DAP</code> <code>LE</code> Config Loop through the ports which supports <code>MS12</code> <code>DAP</code> Capabilities and verify <code>LE</code> Config <code>dsEnableLEConfig()</code> <code>Y</code> <code>Y</code> 04 15 Test <code>ARC</code> Port Enable the <code>ARC</code> port, retrieve the connected device's capabilities, and verify them <code>dsGetSupportedARCTypes()</code> <code>N</code> <code>Y</code> <code>NA</code> 16 Test <code>ARC</code> Port <code>SAD</code> Enable the <code>ARC</code> port, set the set the <code>SAD</code> and verify <code>dsAudioSetSAD()</code> <code>N</code> <code>Y</code> <code>NA</code> 17 Test output mode Play the predefined audio streams. Iterate through the audio ports which supports stereo modes, set various stereo modes and verify <code>dsSetStereoMode()</code> <code>Y</code> <code>Y</code> 01, 07, 08 18 Test Audio Level Play the predefined audio streams. Iterate through the audio ports, set the gain and verify <code>dsSetAudioLevel()</code> <code>N</code> <code>Y</code> 01 19 Test Audio Gain Play the predefined audio streams. set the gain for Speaker port and verify <code>dsSetAudioGain()</code> <code>N</code> <code>Y</code> 01 20 Test Audio Mute Play the predefined audio streams. Iterate through the audio ports, set the Mute, Un-mute and verify <code>dsSetAudioMute()</code> <code>Y</code> <code>Y</code> 01 21 Test Audio Delay Play the predefined audio streams. Iterate through the audio ports, set the delay and verify <code>dsSetAudioDelay()</code> <code>Y</code> <code>Y</code> 18 22 Test Audio Format Play the predefined audio streams. verify the audio format using <code>API</code>. Additionally, confirm if the callback is triggered <code>dsGetAudioFormat()</code> <code>Y</code> <code>Y</code> 01, 07, 08, 09, 10, 11, 12, 13, 14, 15, 16, 17 23 Test Associated Audio Mixing Play the predefined audio streams. Set the mixer levels and verify <code>dsSetAssociatedAudioMixing()</code>, <code>dsSetFaderControl()</code> <code>Y</code> <code>Y</code> 19 24 Test Primary/Secondary Language Play the predefined audio streams. Set the primary and secondary languages and verify <code>dsSetPrimaryLanguage()</code>, <code>dsSetSecondaryLanguage()</code> <code>Y</code> <code>Y</code> 19 25 Test Audio Mixer Levels Play the predefined audio streams. Set the mixer levels for primary and system audio and verify <code>dsSetAudioMixerLevels()</code> <code>N</code> <code>Y</code> 20, 21 26 Test MS12 Audio Profiles Play the predefined audio streams. Set the MS12 profiles and verify <code>dsSetMS12AudioProfile()</code> <code>N</code> <code>Y</code> 03"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsAudio L3 Python test cases:</p> <pre><code>---\ntitle: dsAudio - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- dsAudioHelperClass : inherits\n    dsAudioHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsAudio : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsAudio \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsAudio</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsAudio_Settings</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file dsAudio_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsAudio_test_suite.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/","title":"dsAudio HAL L3 Python Test Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Streams Required</li> <li>Test Cases</li> <li>dsAudio_L3_Runall_Sink.py</li> <li>dsAudio_L3_Runall_Source.py</li> <li>dsaudio_test01_enabledisableandverifyaudioportstatus.py</li> <li>dsaudio_test02_portconnectionstatus.py</li> <li>dsaudio_test03_ms12audiocompression.py</li> <li>dsaudio_test04_ms12dialogueenhancer.py</li> <li>dsaudio_test05_ms12dolbyvolume.py</li> <li>dsaudio_test06_ms12intelligentequalizer.py</li> <li>dsaudio_test07_ms12volumeleveller.py</li> <li>dsaudio_test08_ms12bassenhancer.py</li> <li>dsaudio_test09_ms12surrounddecoder.py</li> <li>dsaudio_test10_ms12drcmode.py</li> <li>dsaudio_test11_ms12surroundvirtualizer.py</li> <li>dsaudio_test12_ms12misteering.py</li> <li>dsaudio_test13_ms12graphicequalizer.py</li> <li>dsaudio_test14_ms12leconfig.py</li> <li>dsaudio_test15_arcport.py</li> <li>dsaudio_test16_arcsad.py</li> <li>dsaudio_test17_outputmode.py</li> <li>dsaudio_test18_audiolevel.py</li> <li>dsaudio_test19_speakeraudiogain.py</li> <li>dsaudio_test20_muteunmute.py</li> <li>dsaudio_test21_audiodelay.py</li> <li>dsaudio_test22_audioformat.py</li> <li>dsaudio_test23_associatemix.py</li> <li>dsaudio_test24_primarysecondarylanguage.py</li> <li>dsaudio_test25_audiomix.py</li> <li>dsaudio_test26_ms12audioprofiles.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>ARC</code>    - Audio Return Channel</li> <li><code>eARC</code>   - Enhanced Audio Return Channel</li> <li><code>SAD</code>    - Short Audio Descriptor</li> <li><code>SPDIF</code>  - Sony/Philips Digital Interface</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>LE</code>     - Loudness Equivalence</li> <li><code>DRC</code>    - Dynamic Range Control</li> <li><code>MI</code>     - Media Intelligent</li> <li><code>MS12</code>   - MultiStream 12</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>AC3</code>    - Audio Codec 3</li> <li><code>EAC3</code>   - Enhanced <code>AC3</code></li> <li><code>WMA</code>    - Windows Media Audio</li> <li><code>AAC</code>    - Advanced Audio coding</li> <li><code>DD</code>     - DOLBY Digital</li> <li><code>DDPLUS</code> - DOLBY Digital Plus</li> <li><code>MAT</code>    - Metadata-enhanced Audio Transmission</li> <li><code>DAP</code>    - Digital Audio Processing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> <li><code>avr</code>    - Audio Video Receiver</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_player Plays the stream required for test case ssh_player_secondary Plays a secondary stream, if required for test case ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player_secondary:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"http://localhost:8000/\"    # download location for the CPE device\n        httpProxy:   # Local Proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file:</p> <ul> <li>Set the path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device.</li> <li> <p>Add <code>soc_vendor</code> inorder to run prerequisites required for the player in the path <code>&lt;PATH&gt;/ut/host/tests/raft/framework/plugins/ut_raft/configs/utPlayerConfig.yml</code></p> <pre><code>intel: # soc ID\n  gstreamer: # player Name\n    prerequisites: # Prerequisites if any to run the player\n      - export XDG_RUNTIME_DIR=\"/tmp\"\n      - westros-init &amp;\n</code></pre> </li> <li> <p>Specify the device profile path in <code>test/profile</code></p> </li> <li>Update <code>streams_download_url</code> with the URL from which the streams will be downloaded</li> <li>Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</li> </ul> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../../profiles/sink/Sink_AudioSettings.yaml\"\n            streams_download_url: \"&lt;URL_Path&gt;\" #URL path from which the streams are downloaded to the device\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: dsAudio_L3_testSetup.yml</p> <p>Streams required for each test case was provided in this file. This path is appended with <code>streams_download_url</code> entry from Device Configuration File</p> <p>If a test case requires multiple streams or needs to be validated using several streams, ensure that all necessary streams are added sequentially for that specific test case.</p> <pre><code>dsAudio:\n  description: \"dsAudio Device Settings test setup\"\n  assets:\n    device:\n      test01_EnableDisableAndVerifyAudioPortStatus:\n        streams:\n          - \"streams/tones_string_48k_stereo.ac3\"\n      test02_PortConnectionStatus:\n        streams:\n      test03_MS12AudioCompression:\n        streams:\n          - \"streams/tones_string_48k_stereo.ac3\"\n      test25_AudioMix:\n        streams:\n          - \"streams/primary_audio_48k_2ch.ac3\"\n          - \"streams/system_audio_48k_2ch.wav\"\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: dsAudio_testConfig.yml</p> <p>Execute command to run te HAL binary was provided in this file.</p> <pre><code>dsAudio:\n    description: \"dsAudio Device Settings testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#streams-required","title":"Streams Required","text":"<p>Refer ds-audio_L3_Low-Level_TestSpecification.md for the stream details</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_l3_runall_sinkpy","title":"dsAudio_L3_Runall_Sink.py","text":"<p>This python file runs all the tests supported by <code>sink</code> devices</p> <pre><code>python dsAudio_L3_Runall_Sink.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_l3_runall_sourcepy","title":"dsAudio_L3_Runall_Source.py","text":"<p>This python file runs all the tests supported by <code>source</code> devices</p> <pre><code>python dsAudio_L3_Runall_Source.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test01_enabledisableandverifyaudioportstatuspy","title":"dsAudio_test01_EnableDisableAndVerifyAudioPortStatus.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>Yes: User interaction is necessary to confirm audio playback status (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Play Stream #1 and confirm that audio is heard through the supported ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test enables the specified audio ports, plays the audio stream, and subsequently disables the ports</p> <p>Success Criteria</p> <ul> <li>User should hear audio through the enabled port during playback</li> <li>User should not hear any audio when the port is disabled.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsAudio_test01_EnableDisableAndVerifyAudioPortStatus.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Audio Playback Verification:</p> <p>The test will play the designated audio stream and prompt the user with the following:</p> </li> <li> <p>Question: \"Is audio playing on the enabled audio port? (Y/N)\"</p> </li> <li>Press Y if audio is heard (this will mark the step as PASS).</li> <li> <p>Press N if no audio is heard (this will mark the step as FAIL).</p> </li> <li> <p>Audio Status Confirmation (Port Disabled):</p> </li> </ul> <p>After confirming audio playback, the test will disable the audio port and prompt the user again:</p> <ul> <li>Question: \"Is audio playing when the port is disabled? (Y/N)\"</li> <li>Press N if no audio is heard (this will mark the step as PASS).</li> <li> <p>Press Y if audio is heard (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available audio ports, enabling/disabling each one and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test02_portconnectionstatuspy","title":"dsAudio_test02_PortConnectionStatus.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test02","title":"Platform Supported - test02","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<ul> <li>Yes (This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<ul> <li>Verify the Headphone connection status.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<ul> <li>This test checks whether the headphones are connected or disconnected.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li>Run the test file: <code>dsAudio_test02_PortConnectionStatus.py</code></li> <li>Execution process:</li> </ul> <p>Upon execution, the test will:</p> <ul> <li>Download all the required artifacts.</li> <li>Copy them to the target directory.</li> <li> <p>Automatically start the test execution.</p> </li> <li> <p>User prompt for action:</p> </li> </ul> <p>During the test, the user will be prompted to connect or disconnect the headphones. When prompted:</p> <ul> <li>The message \"Connect/Disconnect the HEADPHONES and press Enter\" will appear.</li> <li> <p>The user must physically connect or disconnect the headphones as requested, then press Enter to proceed.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test03_ms12audiocompressionpy","title":"dsAudio_test03_MS12AudioCompression.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test03","title":"Platform Supported - test03","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Verify the changes in audio compression levels across the supported audio ports for Stream #1.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test03","title":"Expected Results - test03","text":"<p>The test will evaluate the audio compression levels for various settings. The user should notice a change in audio playback as different compression levels are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsAudio_test03_MS12AudioCompression.py</code></p> </li> <li> <p>Execution process:</p> </li> </ul> <p>The test will:</p> <ul> <li>Download all the required artifacts and audio streams.</li> <li>Copy them to the target directory.</li> <li> <p>Automatically start the test execution.</p> </li> <li> <p>Play the audio stream:</p> </li> </ul> <p>Test starts the audio stream playback specified in the test setup configuration file, and the user will be prompted to assess the applied audio compression levels on the supported ports.</p> <ul> <li>User interaction for verification:</li> </ul> <p>For each iteration:</p> <ul> <li>The test will ask: \"Is the audio compression level applied to the supported ports? (Y/N) ?\"</li> <li>If the compression level is noticeable, the user should press Y to confirm (passing that step).</li> <li> <p>If not, press N (failing the step).</p> </li> <li> <p>Iterating through compression levels:</p> </li> </ul> <p>The test will repeat for different audio compression levels. The user must confirm each response accordingly.</p> <ul> <li>Completion and results:</li> </ul> <p>After all iterations are complete and the user provides the required responses, the test will conclude and display the final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test04_ms12dialogueenhancerpy","title":"dsAudio_test04_MS12DialogueEnhancer.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test04","title":"Platform Supported - test04","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>Verify the impact of the dialogue enhancer levels on the supported audio ports for Stream #2.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>This test will evaluate the dialogue enhancer levels. The user should notice an improvement in audio clarity as different enhancement levels are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsAudio_test04_MS12DialogueEnhancer.py</code></p> </li> <li> <p>Execution process:</p> </li> </ul> <p>The test will:</p> <ul> <li>Download all required artifacts and audio streams.</li> <li>Copy them to the target directory.</li> <li> <p>Automatically begin the test execution.</p> </li> <li> <p>Play the audio stream:</p> </li> </ul> <p>Test starts the audio stream playback specified in the test setup configuration file, and the user will be prompted to verify whether the Dialogue Enhancer level has been applied.</p> <ul> <li>User interaction for verification:</li> </ul> <p>For each iteration:</p> <ul> <li>The test will ask: \"Is the Dialogue Enhancer level applied to the supported ports? (Y/N) ?\"</li> <li>If the enhancer is noticeable, the user should press Y to confirm (passing that step).</li> <li> <p>If not, press N (failing the step).</p> </li> <li> <p>Iterating through enhancement levels:</p> </li> </ul> <p>The test will iterate through various dialogue enhancer levels, and the user must confirm the response for each level.</p> <ul> <li>Completion and results:</li> </ul> <p>After receiving all user inputs, the test will conclude and provide a final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test05_ms12dolbyvolumepy","title":"dsAudio_test05_MS12DolbyVolume.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test05","title":"Platform Supported - test05","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test05","title":"User Input Required - test05","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<p>Verify the audio playback with Dolby Volume enabled/disabled (TRUE/FALSE) for all supported audio ports for Stream #1.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test05","title":"Expected Results - test05","text":"<p>The test evaluates the effect of Dolby Volume on audio playback. The user should notice a clear difference in audio output when Dolby Volume is toggled between TRUE and FALSE.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>dsAudio_test05_MS12DolbyVolume.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the designated audio stream.</p> </li> <li> <p>During playback, the test will prompt the user to verify whether Dolby Volume (TRUE/FALSE) is applied to the supported ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt, the user should assess the audio output and respond:</p> <ul> <li>If the Dolby Volume (TRUE/FALSE) change is noticeable, the user should press Y to confirm that it was applied (this will pass the step).</li> <li> <p>If not, press N (this will fail the step).</p> </li> <li> <p>Completion:</p> </li> </ul> <p>After receiving all necessary user inputs, the test case will conclude and display the final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test06_ms12intelligentequalizerpy","title":"dsAudio_test06_MS12IntelligentEqualizer.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test06","title":"Platform Supported - test06","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test06","title":"User Input Required - test06","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test06","title":"Acceptance Criteria - test06","text":"<p>Verify the audio playback for different Intelligent Equalizer modes on all supported audio ports for Stream #3.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test06","title":"Expected Results - test06","text":"<p>The test evaluates the various modes of the Intelligent Equalizer. The user should observe clear differences in audio quality as different equalizer modes are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test06","title":"Test Steps - test06","text":"<ul> <li> <p>Run the Test</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test06_MS12IntelligentEqualizer.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically:</p> <ul> <li>Download all required artifacts and audio streams.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Start the test execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the test will prompt the user to verify whether the Intelligent Equalizer mode has been successfully applied to the supported ports (Y/N)?</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt, The user must assess the audio output and respond:</p> <ul> <li>If the Intelligent Equalizer mode is applied and noticeable, the user should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Iteration Through Modes:</p> </li> </ul> <p>The test will iterate through various Intelligent Equalizer modes, and the user will be prompted to confirm their observations for each mode.</p> <ul> <li>Completion:</li> </ul> <p>After collecting all user inputs for the different equalizer modes, the test case will conclude and display the final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test07_ms12volumelevellerpy","title":"dsAudio_test07_MS12Volumeleveller.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test07","title":"Platform Supported - test07","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test07","title":"User Input Required - test07","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test07","title":"Acceptance Criteria - test07","text":"<p>Verify the behavior of the Volume Leveller across different modes and levels for supported audio ports for Stream #4.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test07","title":"Expected Results - test07","text":"<p>This test will evaluate the impact of various Volume Leveller settings. The user should observe distinct changes in audio transitions when the stream shifts from low to high frequency.</p> <p>The Expected Resultss for the different modes are as follows:</p> <ul> <li>Mode 0 (Volume Leveller OFF): No change in the audio transition.</li> <li>Mode 2 (Volume Leveller AUTO): Noticeable change in audio transition as the volume adjusts automatically.</li> <li>Mode 1 (Volume Leveller ON): The transition will be less abrupt, as the leveller reduces audio peaks if the level increases.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test07","title":"Test Steps - test07","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test07_MS12VolumeLeveller.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically:</p> <ul> <li>Download all required artifacts and audio streams.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Start the test execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>The user will be prompted to confirm whether the Volume Leveller mode and level are applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt:</p> <ul> <li>The test will ask: \"Is the Volume Leveller mode and level applied to the supported ports? (Y/N)\"</li> <li>If the leveller is functioning as expected, the user should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Iteration Through Modes and Levels:</p> </li> </ul> <p>The test will iterate through the different Volume Leveller Modes (0, 1, 2) and Levels (0, 5, 10), and the user must confirm their observations for each setting.</p> <ul> <li>Completion:</li> </ul> <p>After collecting all user inputs for the various modes and levels, the test will conclude and display the final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test08_ms12bassenhancerpy","title":"dsAudio_test08_MS12BassEnhancer.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test08","title":"Platform Supported - test08","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test08","title":"User Input Required - test08","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test08","title":"Acceptance Criteria - test08","text":"<p>Verify the functionality of the Bass Enhancer at various boost levels for all supported audio ports for Stream #5.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test08","title":"Expected Results - test08","text":"<p>This test will assess the Bass Enhancer by applying different boost values. The user should be able to detect an enhancement in the bass levels when these boost values are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test08","title":"Test Steps - test08","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test08_MS12BassEnhancer.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically:</p> <ul> <li>Download all required artifacts and audio streams.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin the test execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether the Bass Boost level is applied to the supported ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt:</p> <ul> <li>The test will ask: \"Is the Bass Boost level applied to the supported ports? (Y/N)\"</li> <li>If the user detects enhanced bass, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Iteration Through Boost Levels:</p> </li> </ul> <p>The test will iterate through multiple Bass Boost levels, and the user must confirm their observations for each level.</p> <ul> <li>Completion:</li> </ul> <p>After collecting all user inputs for the various bass boost levels, the test case will conclude and display the final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test09_ms12surrounddecoderpy","title":"dsAudio_test09_MS12SurroundDecoder.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test09","title":"Platform Supported - test09","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test09","title":"User Input Required - test09","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test09","title":"Acceptance Criteria - test09","text":"<p>Verify the status of the Surround Decoder Mode for supported audio ports for Stream #6.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test09","title":"Expected Results - test09","text":"<p>This test will evaluate the functionality of the Surround Decoder Mode. The user should observe a noticeable change in audio playback when the surround decoder is enabled or disabled.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test09","title":"Test Steps - test09","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test09_MS12SurroundDecoder.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically:</p> <ul> <li>Download all required artifacts and the audio stream.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin the test execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether the Surround Decoder mode (TRUE/FALSE) is applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt:</p> <ul> <li>The test will ask: \"Is the Surround Decoder mode applied to the supported ports? (Y/N)\"</li> <li>If the user detects the feature is working as expected for TRUE/FALSE mode, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Completion:</p> </li> </ul> <p>After collecting user inputs, the test will conclude and display the final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test10_ms12drcmodepy","title":"dsAudio_test10_MS12DRCMode.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test10","title":"Platform Supported - test10","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test10","title":"User Input Required - test10","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test10","title":"Acceptance Criteria - test10","text":"<p>Play Stream #4 and verify the Dynamic Range Compression (DRC) Modes for all supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test10","title":"Expected Results - test10","text":"<p>This test evaluates the functionality of DRC Modes. The user should notice a distinct change in audio output when different DRC modes are applied.</p> <p>DRC Modes:</p> <ul> <li>Mode 0 = Line Mode -- Balances the volume during high-frequency audio playback.</li> <li>Mode 1 = RF Mode -- Enhances the volume for low-frequency audio playback.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test10","title":"Test Steps - test10","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test10_MS12DRCMode.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically:</p> <ul> <li>Download all required artifacts and the audio stream.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin test execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether the DRC Mode (Line or RF) is applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt:</p> <ul> <li>The test will ask: \"Is the DRC Mode applied to the supported ports ? (Y/N)\"</li> <li>If the user detects the mode is applied, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>DRC Mode Iteration:</p> </li> </ul> <p>The test will loop through the available DRC modes. The user must confirm their observations for each mode.</p> <ul> <li>Completion:</li> </ul> <p>Once all user inputs are collected, the test case concludes and provides a final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test11_ms12surroundvirtualizerpy","title":"dsAudio_test11_MS12SurroundVirtualizer.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test11","title":"Platform Supported - test11","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test11","title":"User Input Required - test11","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test11","title":"Acceptance Criteria - test11","text":"<p>Play Stream #6 and verify the Surround Virtualizer modes for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test11","title":"Expected Results - test11","text":"<p>This test evaluates the functionality of the Surround Virtualizer by checking different modes and levels. The user should observe a noticeable change in the audio experience when these modes and levels are applied.</p> <p>Surround Virtualizer Modes:</p> <ul> <li>Mode 0 = OFF (No virtual surround effect)</li> <li>Mode 2 = Auto Mode (Automatically adjusts the surround effect based on the audio content)</li> <li>Mode 1 = ON (Enables virtual surround)</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test11","title":"Test Steps - test11","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test11_MS12SurroundVirtualizer.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Automatically download all required artifacts and the audio stream.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether the Surround Virtualizer Mode and levels are applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt:</p> <ul> <li>The test will ask: \"Is the Surround Virtualizer Mode and level applied to the supported ports? (Y/N)\"</li> <li>If the user detects the mode or level is applied, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Surround Virtualizer Mode Iteration:</p> </li> <li> <p>The test will loop through the available Surround Virtualizer Modes and levels.</p> </li> <li> <p>The user must confirm their observations for each combination.</p> </li> <li> <p>Completion:</p> </li> </ul> <p>Once all user inputs are collected, the test case will conclude and display a final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test12_ms12misteeringpy","title":"dsAudio_test12_MS12MISteering.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test12","title":"Platform Supported - test12","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test12","title":"User Input Required - test12","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test12","title":"Acceptance Criteria - test12","text":"<p>Play Stream #1 and verify the MI Steering functionality for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test12","title":"Expected Results - test12","text":"<p>This test evaluates the MI Steering feature by enabling and disabling it. The user should observe a distinct change in the audio output when this functionality is applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test12","title":"Test Steps - test12","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test12_MS12MISteering.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Automatically download all necessary artifacts and the audio stream.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether MI Steering (TRUE/FALSE) is applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt:</p> <ul> <li>The test will ask: \"Is MI Steering applied to the supported ports? (Y/N)\"</li> <li>If the user detects the MI Steering feature (TRUE/FALSE) is applied, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Completion:</p> </li> </ul> <p>Once all user inputs are gathered, the test will conclude with a final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test13_ms12graphicequalizerpy","title":"dsAudio_test13_MS12GraphicEqualizer.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test13","title":"Platform Supported - test13","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test13","title":"User Input Required - test13","text":"<p>Yes (This wil be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test13","title":"Acceptance Criteria - test13","text":"<p>Play Stream #1 and verify the functionality of the Graphic Equalizer Modes for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test13","title":"Expected Results - test13","text":"<p>This test evaluates the different modes of the Graphic Equalizer. The user should be able to detect an audible change in the sound output when each mode is applied.</p> <p>Graphic Equalizer Modes:</p> <ul> <li>Mode 0: Off (No effect on audio output)</li> <li>Mode 1: Open (Wider soundstage, emphasis on clarity)</li> <li>Mode 2: Rich (Deeper, fuller sound profile)</li> <li>Mode 3: Focused (More concentrated, detailed sound)</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test13","title":"Test Steps - test13","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test13_MS12GraphicEqualizer.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Automatically download all required artifacts and the audio stream.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether the Graphic Equalizer mode is applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> <li> <p>For each mode, the test will ask: \"Is the Graphic Equalizer mode applied to the supported ports? (Y/N)\"</p> </li> <li>If the user detects the mode is applied correctly, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Mode Iteration:</p> </li> </ul> <p>The test will iterate through all Graphic Equalizer modes (Off, Open, Rich, Focused). The user should confirm their response for each mode.</p> <ul> <li>Completion:</li> </ul> <p>Once all user inputs are collected, the test concludes with a final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test14_ms12leconfigpy","title":"dsAudio_test14_MS12LEConfig.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test14","title":"Platform Supported - test14","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test14","title":"User Input Required - test14","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test14","title":"Acceptance Criteria - test14","text":"<p>Play Stream #4 and verify the functionality of the LE Config for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test14","title":"Expected Results - test14","text":"<p>This test evaluates the LE Config functionality. The user should notice changes in the audio output as the stream transitions from low frequency to high frequency when LE Config is enabled or disabled.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test14","title":"Test Steps - test14","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test14_MS12LEConfig.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Automatically download all required artifacts and the audio stream.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Begin execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the specified audio stream.</p> </li> <li> <p>During playback, the user will be prompted to confirm whether LE Config (TRUE/FALSE) is applied to the supported audio ports.</p> </li> <li> <p>User Interaction:</p> </li> <li> <p>For each configuration, the test will ask: \"Is the LE Config (TRUE/FALSE) applied to the supported ports? (Y/N)\"</p> </li> <li>If the user confirms that LE Config (TRUE/FALSE) is applied correctly, they should press Y (this passes the step).</li> <li> <p>If not, press N (this fails the step).</p> </li> <li> <p>Completion:</p> </li> </ul> <p>Once all user inputs are collected, the test concludes with a final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test15_arcportpy","title":"dsAudio_test15_ARCPort.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test15","title":"Platform Supported - test15","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test15","title":"User Input Required - test15","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test15","title":"Acceptance Criteria - test15","text":"<p>Verify the HDMI ARC/eARC port connection status.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test15","title":"Expected Results - test15","text":"<p>This test checks the status of the HDMI ARC or eARC connection. The user will be required to connect or disconnect the ARC/eARC port and confirm the status.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test15","title":"Test Steps - test15","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test15_ARCPort.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Automatically download all necessary artifacts.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Start execution.</p> </li> <li> <p>ARC/eARC Port Interaction:</p> </li> <li> <p>During the test, the user will be prompted to connect or disconnect the ARC/eARC port.</p> </li> <li> <p>Once the action is performed, the user must press ENTER to proceed.</p> </li> <li> <p>User Confirmation:</p> </li> </ul> <p>The test may prompt the user multiple times to interact with the ARC/eARC connection, asking for confirmation of the status.</p> <ul> <li>Completion:</li> </ul> <p>If all user interactions and responses are successfully received, the test will conclude with a final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test16_arcsadpy","title":"dsAudio_test16_ARCSAD.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test16","title":"Platform Supported - test16","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test16","title":"User Input Required - test16","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test16","title":"Acceptance Criteria - test16","text":"<p>Verify the SAD (Short Audio Descriptor) functionality for the HDMI ARC audio port.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test16","title":"Expected Results - test16","text":"<p>This test will send SAD values to the ARC device, and the user is required to verify that these values are correctly received and applied on the ARC device.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test16","title":"Test Steps - test16","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test16_ARCSAD.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Automatically download all necessary artifacts.</li> <li>Copy them to the target directory on the device.</li> <li> <p>Initiate the test execution.</p> </li> <li> <p>SAD Value Transmission:</p> </li> <li> <p>The test will send SAD values (Short Audio Descriptors) to the connected ARC device.</p> </li> <li> <p>The user will be prompted to verify if the values were received and applied on the ARC device.</p> </li> <li> <p>User Confirmation:</p> </li> <li> <p>After each SAD value is transmitted, the test will prompt the user with the question: \"Was the SAD value sent to the ARC device? (Y/N)\".</p> </li> <li>If the SAD value was received, the user should press Y to pass the step.</li> <li> <p>If the value was not received, the user should press N to fail the step.</p> </li> <li> <p>Iterate through SAD Values:</p> </li> </ul> <p>The test will loop through multiple SAD values, and for each value, the user will be asked to confirm whether it was successfully transmitted and received.</p> <ul> <li>Completion:</li> </ul> <p>Once all the SAD values have been processed and user responses are collected, the test case will conclude with a final result: PASS or FAIL based on the user's inputs.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test17_outputmodepy","title":"dsAudio_test17_OutputMode.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test17","title":"Platform Supported - test17","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test17","title":"User Input Required - test17","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test17","title":"Acceptance Criteria - test17","text":"<p>Play Streams #7, #1, and #8 and verify the audio output mode for all supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test17","title":"Expected Results - test17","text":"<p>This test will play different audio output modes for streams on the supported audio ports. The user should verify the audio output format when various output modes are applied.</p> Stream OutputMode (Format) tones_string_48k_stereo.wav STEREO (PCM), PASSTHRU (PCM) tones_string_48k_stereo.ac3 STEREO (PCM), DD (DD), PASSTHRU (DD) tones_string_48k_stereo.eac3 STEREO (PCM), DD (DD), DDPLUS (DD+), PASSTHRU (DD+)"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test17","title":"Test Steps - test17","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and execute the Python script: <code>dsAudio_test17_OutputMode.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will:</p> <ul> <li>Download all necessary artifacts and streams.</li> <li>Copy the files to the target directory.</li> <li> <p>Begin the test execution.</p> </li> <li> <p>Audio Output Verification:</p> </li> <li> <p>The test will play the specified streams and prompt the user to verify if the output mode on the supported ports is in the correct format.</p> </li> <li>The user will be asked: \"For the currently playing stream is the output mode on the supported port was in the correct format? (Y/N)\"</li> <li>If the format is correct for the output mode, the user should press Y (this passes the step).</li> <li> <p>If the format is incorrect, the user should press N (this fails the step).</p> </li> <li> <p>Iterate through Output Modes and Streams:</p> </li> </ul> <p>The test will loop through different streams and output modes, and for each combination, the user should confirm whether the audio format is correct.</p> <ul> <li>Completion:</li> </ul> <p>Once all the streams and output modes have been tested and user responses are collected, the test case will conclude with a final result: PASS or FAIL based on the user\u2019s inputs.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test18_audiolevelpy","title":"dsAudio_test18_AudioLevel.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test18","title":"Platform Supported - test18","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test18","title":"User Input Required - test18","text":"<p>Yes (This will be automated later)</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test18","title":"Acceptance Criteria - test18","text":"<p>Play Stream #1 and verify the audio level functionality across supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test18","title":"Expected Results - test18","text":"<p>This test evaluates the incremental adjustment of audio levels. The user should observe a noticeable increase in volume as the test applies different audio levels.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test18","title":"Test Steps - test18","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test18_AudioLevel.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> <li> <p>The test will automatically download all necessary artifacts and streams, copying them to the target directory before starting the execution.</p> </li> <li> <p>Play the Stream:</p> </li> <li> <p>The test will play Stream and prompt the user to confirm if the specified volume level is applied to the supported audio ports.</p> </li> <li> <p>The user should press Y if the volume level is correctly applied (this will pass the step) or N if it is not (this will fail the step).</p> </li> <li> <p>Iterate Through Audio Levels:</p> </li> </ul> <p>The test will continue iterating through various audio levels. The user should respond at each prompt to confirm whether the volume level is applied.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Once the test receives all user responses, it will conclude and output the final test result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test19_speakeraudiogainpy","title":"dsAudio_test19_SpeakerAudioGain.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test19","title":"Platform Supported - test19","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test19","title":"User Input Required - test19","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test19","title":"Acceptance Criteria - test19","text":"<p>Play Stream #1 and verify the audio gain values for the speaker output port.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test19","title":"Expected Results - test19","text":"<p>This test assesses different audio gain values for the speaker. The user should notice distinct volume changes as varying audio gain levels are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test19","title":"Test Steps - test19","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test19_SpeakerAudioGain.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, copying them to the target directory before execution begins.</p> <ul> <li> <p>Play the Stream:</p> </li> <li> <p>The test will play Stream and prompt the user to confirm whether the correct volume gain value is applied to the speaker port.</p> </li> <li> <p>The user should press Y if the gain value is correctly applied (this passes the step) or N if it is not (this fails the step).</p> </li> <li> <p>Iterate Through Audio Gain Values:</p> </li> </ul> <p>The test will iterate through multiple audio gain values, and the user will need to verify each level, confirming if the volume changes accordingly.</p> <ul> <li>Test Completion</li> </ul> <p>After gathering all user responses, the test will conclude and display the final test result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test20_muteunmutepy","title":"dsAudio_test20_MuteUnMute.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test20","title":"Platform Supported - test20","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test20","title":"User Input Required - test20","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test20","title":"Acceptance Criteria- test20","text":"<p>Play Stream #1 and verify the Mute and Unmute functionalities for the supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test20","title":"Expected Results - test20","text":"<p>The test will play the stream and evaluate the mute/unmute functionality on supported audio ports.</p> <ul> <li>When muted, the user should not hear any audio.</li> <li>When unmuted, the user should hear the audio clearly.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test20","title":"Test Steps - test20","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test20_MuteUnMute.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, copying them to the target directory before execution begins.</p> <ul> <li> <p>Play the Stream and Respond to Prompts:</p> </li> <li> <p>The test will play Stream and prompt the user with the following question for each supported port:</p> <ul> <li>\"Is audio playing on the supported port ? (Y/N)\"</li> <li>In the Mute case: The user should press N if no sound is heard (this passes the step), otherwise Y (this fails the step).</li> <li>In the Unmute case: The user should press Y if audio is heard (this passes the step), otherwise N (this fails the step).</li> </ul> </li> <li> <p>Iterate Through Supported Ports:</p> </li> </ul> <p>The test will loop through each supported audio port (e.g., speakers, HDMI ARC, SPDIF, etc.), and the user must confirm if the mute/unmute functionality is working as expected.</p> <ul> <li>Test Completion:</li> </ul> <p>After gathering all user responses for each audio port, the test will conclude and display the final test result.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test21_audiodelaypy","title":"dsAudio_test21_AudioDelay.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test21","title":"Platform Supported - test21","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test21","title":"User Input Required - test21","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test21","title":"Acceptance Criteria - test21","text":"<p>Play Stream #18 and verify the Audio Delay functionality for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test21","title":"Expected Results - test21","text":"<ul> <li>The test will play the stream and apply different delay values to evaluate the Audio Delay feature on the supported audio ports.</li> <li>The user should be able to notice the delay in audio relative to the video playback for various delay values.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test21","title":"Test Steps - test21","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test21_AudioDelay.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, copying them to the target directory before the execution begins.</p> <ul> <li> <p>Play the Stream and Respond to Prompts:</p> </li> <li> <p>The test will play Stream and prompt the user with the following question for each supported port:</p> <ul> <li>\"Is the audio delay value applied to the supported port? (Y/N)\"</li> <li>The user should press Y if the audio delay is correctly observed (this passes the step), or N if the delay is not observed (this fails the step).</li> </ul> </li> <li> <p>Iterate Through Different Audio Delay Values:</p> </li> </ul> <p>The test will loop through different audio delay values (e.g., increasing or decreasing delay) and evaluate them across all supported audio ports. The user must confirm if the delay is noticeable and accurate for each configuration.</p> <ul> <li>Test Completion:</li> </ul> <p>After receiving all user responses for each audio delay setting and port, the test will conclude and display the final test result.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test22_audioformatpy","title":"dsAudio_test22_AudioFormat.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test22","title":"Platform Supported - test22","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test22","title":"User Input Required - test22","text":"<p>No (Fully automated test case).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test22","title":"Acceptance Criteria - test22","text":"<p>Play the Streams #7, #1, #8, #9, #10, #11, #19, #12, #13, #14, #15, #16, #17 sequentially, and the test case will automatically verify the audio formats based on device feedback.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test22","title":"Expected Results - test22","text":"<ul> <li>This test will automatically play streams with different audio formats and verify the formats based on the callbacks reported by the device.</li> <li>The system should accurately detect and validate the audio format of each stream, confirming whether the format matches the expected result.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test22","title":"Test Steps - test22","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test22_AudioFormat.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams and copy them to the designated target directory before starting the execution.</p> <ul> <li> <p>Stream Playback and Automated Verification:</p> </li> <li> <p>The test case will sequentially play the predefined streams on the device.</p> </li> <li> <p>As each stream is played, the device will report callbacks indicating the detected audio format.</p> </li> <li> <p>Result Evaluation:</p> </li> <li> <p>The test case will automatically verify the audio format based on the reported callbacks from the device and evaluate whether the correct format is detected for each stream.</p> </li> <li> <p>Each step will be marked PASS or FAIL based on whether the expected audio format matches the actual format reported.</p> </li> <li> <p>Test Completion:</p> </li> </ul> <p>Once all streams have been tested, the test will conclude and provide a final result (PASS/FAIL) based on the overall success or failure of the format verification.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test23_associatemixpy","title":"dsAudio_test23_AssociateMix.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test23","title":"Platform Supported - test23","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test23","title":"User Input Required - test23","text":"<p>Yes (This will be Automated later)</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test23","title":"Acceptance Criteria - test23","text":"<p>Play Stream #19 and verify the associate audio mixing functionality for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test23","title":"Expected Results - test23","text":"<p>This test will play a stream containing two audio tracks (main and associate) and adjust the fader control values to test audio mixing.</p> <ul> <li>when mixing is false, user should hear only main Audio</li> <li>When the mixing is TRUE and fader control value is set to -32, the user should hear only the main audio.</li> <li>When the mixing is TRUE and fader control value is set to 32, the user should hear only the associate audio.</li> <li>When the mixing is TRUE and fader control value is set to 0, the user should hear both the main and associate audios mixed together.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test23","title":"Test Steps - test23","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test23_AssociateMix.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, then copy them to the designated target directory before starting the execution.</p> <ul> <li> <p>Stream Playback and User Verification:</p> </li> <li> <p>The test will play the stream containing both main and associate audio tracks and prompt the user to verify if the audio mixing and fader control are working correctly.</p> </li> <li> <p>The test will ask the user: \"Is audio playing on the supported port with mixing (TRUE/FALSE) and fader control value (Y/N)?\"</p> </li> <li> <p>Test Loop:</p> </li> </ul> <p>The test will continue through a loop, testing the different fader control values (-32, 0, 32). The user must respond accordingly to each scenario.</p> <ul> <li> <p>Mixing and Fader Control Verification:</p> </li> <li> <p>If Mixing is False, Press Y (this pass the step) if only main audio audio is heard other N (this fails the step).</p> </li> <li> <p>If Mixing is True and:</p> <ul> <li> <p>For fader value -32:</p> </li> <li> <p>The user should hear only the main audio.</p> </li> <li> <p>If the main audio is heard, press Y (this pass the step), otherwise press N (this fails the step).</p> </li> <li> <p>For fader value 32:</p> </li> <li> <p>The user should hear only the associate audio.</p> </li> <li> <p>If the associate audio is heard, press Y (this pass the step), otherwise press N (this fails the step).</p> </li> <li> <p>For fader value 0:</p> </li> <li> <p>The user should hear both the main and associate audios mixed together.</p> </li> <li>If both audios are heard, press Y (this pass the step), otherwise press N (this fails the step).</li> </ul> </li> <li> <p>Test Completion:</p> </li> </ul> <p>Once all user responses are received, the test case will conclude and provide a final result. If all steps pass, the test ends with Result: PASS/FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test24_primarysecondarylanguagepy","title":"dsAudio_test24_PrimarySecondaryLanguage.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test24","title":"Platform Supported - test24","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test24","title":"User Input Required - test24","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test24","title":"Acceptance Criteria - test24","text":"<p>Play Stream #19 and verify the primary and secondary language functionality for the supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test24","title":"Expected Results - test24","text":"<ul> <li>This test will play a stream containing multiple PIDs (Program Identifiers) associated with different languages.</li> <li>The test will switch between different languages for both primary and secondary audio streams, and the user should verify that the audio is being played in the selected language.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test24","title":"Test Steps - test24","text":"<ul> <li> <p>Run the Test Script</p> </li> <li> <p>Select the Python file <code>dsAudio_test24_PrimarySecondaryLanguage.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, and copy them to the target directory before starting the execution.</p> <ul> <li> <p>Stream Playback and Language Verification:</p> </li> <li> <p>The test will play the stream containing multiple audio tracks in different languages.</p> </li> <li>The test will prompt the user to verify if the correct primary and secondary languages are applied to the audio port:</li> <li>\"Is audio playing on supported port with applied primary/secondary language ? (Y/N)\"</li> <li>The user must respond based on what they hear:</li> <li>If the audio is playing in the correct language, press Y to pass the step.</li> <li> <p>If the audio is not in the correct language, press N this fails the step.</p> </li> <li> <p>Language Switching Loop:</p> </li> <li> <p>The test will iterate through various language configurations for both primary and secondary audio tracks.</p> </li> <li> <p>After each language change, the user will be prompted to verify the language and respond accordingly.</p> </li> <li> <p>Test Completion:</p> </li> </ul> <p>Once all user responses are received, the test will conclude and provide a final result. If all language configurations are verified correctly, the test will end with Result: PASS/FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test25_audiomixpy","title":"dsAudio_test25_AudioMix.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test25","title":"Platform Supported - test25","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test25","title":"User Input Required - test25","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test25","title":"Acceptance Criteria - test25","text":"<p>Play Streams #20 and #21 and verify the audio mixing volume levels for supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test25","title":"Expected Results - test25","text":"<p>This test will play multiple streams simultaneously, adjusting different mixing volume levels for both the primary and system audio tracks. The user should hear both audio sources with the applied volume settings.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test25","title":"Test Steps - test25","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test25_AudioMix.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, copying them to the target directory before execution begins.</p> <ul> <li> <p>Stream Playback and Volume Mixing Verification:</p> </li> <li> <p>The test will start playing the stream and prompt the user to verify if the audio mixing and volume settings are correctly applied:</p> </li> <li>\"Is the audio playing on supported port with Mixing and applied primary and system volume levels ? (Y/N)\"</li> <li>If the user hears the correct audio mixing with the applied volume levels, they should press Y to pass the step.</li> <li> <p>If the volume levels are not correctly applied, the user should press N this fails the step.</p> </li> <li> <p>Volume Mixing Loop:</p> </li> <li> <p>The test will iterate through various combinations of volume levels for both the primary and system audio tracks.</p> </li> <li> <p>After each change in the volume levels, the user will be prompted to verify the audio mix and respond accordingly.</p> </li> <li> <p>Test Completion:</p> </li> <li> <p>Once all user responses are collected, the test will end, providing a final result.</p> </li> <li>If all volume levels for the primary and system audios are verified successfully, the test will end with Result: PASS. Otherwise, it will conclude with Result: FAIL.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#dsaudio_test26_ms12audioprofilespy","title":"dsAudio_test26_MS12AudioProfiles.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#platform-supported-test26","title":"Platform Supported - test26","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#user-input-required-test26","title":"User Input Required - test26","text":"<p>Yes (This will be Automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#acceptance-criteria-test26","title":"Acceptance Criteria - test26","text":"<p>Play Stream #3 and verify the MS12 Audio Profile modes for the supported audio ports.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#expected-results-test26","title":"Expected Results - test26","text":"<ul> <li> <p>This test will play the stream and apply different MS12 Audio Profile modes. The user should notice a change in the audio output when these modes are applied.</p> </li> <li> <p>MS12 Audio Profile Modes:</p> </li> <li>Mode: Off</li> <li>Mode: User</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsAudio/ds-audio_L3_TestProcedure/#test-steps-test26","title":"Test Steps - test26","text":"<ul> <li> <p>Run the Test Script:</p> </li> <li> <p>Select the Python file <code>dsAudio_test26_MS12AudioProfiles.py</code> and execute it.</p> </li> <li> <p>Download and Prepare Artifacts:</p> </li> </ul> <p>The test will automatically download all required artifacts and streams, copying them to the target directory before execution begins.</p> <ul> <li> <p>Stream Playback and Profile Mode Verification:</p> </li> <li> <p>The test will play the stream and prompt the user:</p> </li> <li>\"Is the MS12 Audio Profile mode applied to the supported port ? (Y/N)\"</li> <li>If the correct audio profile mode is applied and the user notices the change in audio, they should press Y to pass the step.</li> <li> <p>If no change is noticed or the mode is not applied, the user should press N this fails the step.</p> </li> <li> <p>Profile Mode Loop:</p> </li> <li> <p>The test will iterate through different MS12 Audio Profile modes (Off, User).</p> </li> <li> <p>After each mode is applied, the user will be prompted to verify the change in audio and respond accordingly.</p> </li> <li> <p>Test Completion:</p> </li> <li> <p>Once all user responses are collected, the test will conclude.</p> </li> <li>If all profile modes are verified successfully, the test will end with Result: PASS. If any of the modes fail, the test will conclude with Result: FAIL.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/","title":"Device Settings CompositeIn High Level Test Specification Document","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>   - Hardware Abstraction layer</li> <li><code>API</code>   - Application programming interface</li> <li><code>RDK</code>   - Reference Design Kit</li> <li><code>dsComposite</code> - Device Settings Composite</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the high level testing requirements for the <code>dsComposite</code> module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, emulator requirements, control plane requirements and expected deliverables.</p> <ul> <li>Interface of the test is available in this link -  https://github.com/rdkcentral/rdk-halif-device_settings/blob/main/include/dsCompositeIn.h</li> <li>Hal Specification in this link - https://github.com/rdkcentral/rdk-halif-device_settings/blob/main/docs/pages/ds-composite-in_halSpec.md</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#module-description","title":"Module Description","text":"<p>High level overview:</p> <ul> <li><code>dsComposite</code> provides a variety of APIs for accessing information regarding the Composite Inputs on sink devices.</li> <li>It facilitates interaction with Composite Input ports, aiding in their configuration and utilization within the system. This information is then passed to the caller.</li> <li>For the sink devices, to retrieve the available Composite Input information, an external device must be connected.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Test Description 1 Get Number of Inputs The test aims to verify the availability of Composite Input ports by confirming the number present. 2 Get the Input Status The test is to verify the status of all Composite Input ports 3 Set the Composite port The test is to set the Composite Input port for Presentation 4 Scale the Composite Input Video The test scales the COMPOSITE input video, ensuring that the width and height, determined by the x and y coordinates respectively, do not surpass the current resolution limits of the device. 5 Callback for connection Status The test aims to verify the Callback function used for notifying applications of the COMPOSITE In hot plug/unplug status. 6 Callback for Signal Change The test aims to verify the callback function used to inform applications about changes in the signal status of the Composite In.(NoSignal/UnstableSignal/NotSupportedSignal/StableSignal) 7 Callback for Status Change The test validates the functionality of the callback function designed to notify applications of Composite Input status change events.(Port,IsPresented flag status) 8 Callback for Video Mode Change The test validates the functionality of the callback function designed to notify applications of Composite Input video mode change events.(Port,resolution status) -----------"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#get-number-of-inputs","title":"Get Number of Inputs","text":"Description HAL APIs L2 L3 Control plane requirements Ensure that the function returns the expected number of COMPOSITE input ports by comparing the input port values parsed from the configuration YAML file 'Panel_CompositeInput.yaml'. The value to be retrieved from the YAML is 'composite_input_configurations/number_of_ports'. dsCompositeInGetNumberOfInputs Y N N"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-get-number-of-inputs","title":"Emulator Requirement - Get Number of Inputs","text":"<p>Emulator will boot with the port informations coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-get-number-of-inputs","title":"Control Plane Requirement - Get Number of Inputs","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#get-the-input-status","title":"Get the Input Status","text":"Description HAL APIs L2 L3 Control plane requirements Verify the status of the Composite Input by ensuring it is in disable status. dsCompositeInGetStatus Y N N Verify the status of the Composite Input by ensuring it is enabled, connected to the source, and that the composite input port is active. dsCompositeInGetStatus N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-get-the-input-status","title":"Test Startup Requirement - Get the Input Status","text":"<p>Connection of the source device with the CompositeIn.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-get-the-input-status","title":"Emulator Requirement - Get the Input Status","text":"<p>Emulator will boot with the port informations coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-get-the-input-status","title":"Control Plane Requirement - Get the Input Status","text":"<p>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#set-the-composite-port","title":"Set the Composite port","text":"Description HAL APIs L2 L3 Control plane requirements Loop through the all composite ports, verify that the function successfully sets the specified COMPOSITE Input port when there is no connection of source device, and check the disable status of the port information using \"Get status\". dsCompositeInSelectPort, dsCompositeInGetStatus Y N N Loop through the all composite ports, verify that the function successfully sets the specified COMPOSITE Input port as active for presentation, and check the port information using \"Get status\". dsCompositeInSelectPort, dsCompositeInGetStatus N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-set-the-composite-port","title":"Test Startup Requirement - Set the Composite port","text":"<p>Connection of the source device with the CompositeIn.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-set-the-composite-port","title":"Emulator Requirement - Set the Composite port","text":"<p>Emulator will boot with the port informations coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-set-the-composite-port","title":"Control Plane Requirement - Set the Composite port","text":"<ul> <li>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#scale-the-composite-input-video","title":"Scale the Composite Input Video","text":"Description HAL APIs L2 L3 Control plane requirements Verify that the function successfully scales the COMPOSITE input video when valid coordinates and dimensions are provided within the current resolution limits. Based on video resolution need to check whether the coordinates are in range dsCompositeInSelectPort(), dsCompositeInScaleVideo() N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-scale-the-composite-input-video","title":"Test Startup Requirement - Scale the Composite Input Video","text":"<p>The test begins by setting up the video analyzer, and the video should be played. </p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-scale-the-composite-input-video","title":"Emulator Requirement - Scale the Composite Input Video","text":"<p>Emulator will boot with the port informations coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-scale-the-composite-input-video","title":"Control Plane Requirement - Scale the Composite Input Video","text":"<ul> <li>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</li> <li>The Control Plane handles the changing of various resolutions.</li> <li>The Control Plane checks and validates the coordinates and dimensions by comparing the values from the video analyzer.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#callback-for-connection-status","title":"Callback for connection Status","text":"Description HAL APIs L2 L3 Control plane requirements Verify that the callback function properly updates the connection/disconnection status flag and notifies the application when a COMPOSITE Input port is connected or disconnected. dsCompositeInRegisterConnectCB N Y Y Verify that the callback function properly updates the isPresented status in <code>dsCompositeInStatus_t</code>, if the connected port is active and presents video after being connected. dsCompositeInRegisterConnectCB N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-callback-for-connection-status","title":"Test Startup Requirement - Callback for connection Status","text":"<p>Connection of the source device with the CompositeIn.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-callback-for-connection-status","title":"Emulator Requirement - Callback for connection Status","text":"<p>Emulator will boot with the port information coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-callback-for-connection-status","title":"Control Plane Requirement - Callback for connection Status","text":"<p>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#callback-for-signal-change","title":"Callback for Signal Change","text":"Description HAL APIs L2 L3 Control plane requirements Verify that the callback function properly notifies the application whenever there is a change in the signal statuses (e.g., NoSignal, UnstableSignal, NotSupportedSignal, StableSignal) for the composite Input port. dsCompositeInRegisterSignalChangeCB N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-callback-for-signal-change","title":"Test Startup Requirement - Callback for Signal Change","text":"<p>Connection of the source device with the CompositeIn.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-callback-for-signal-change","title":"Emulator Requirement - Callback for Signal Change","text":"<p>Emulator will boot with the port informations coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-callback-for-signal-change","title":"Control Plane Requirement - Callback for Signal Change","text":"<ul> <li>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</li> <li>Provide resolution changes or configurations changes on the connected device that affects the output signal.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#callback-for-status-change","title":"Callback for Status Change","text":"Description HAL APIs L2 L3 Control plane requirements Verify that the callback function properly triggers whenever the dsCompositeInStatus_t is updated and notifies the application of the Composite Input Status Change event. dsCompositeInRegisterStatusChangeCB N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-callback-for-status-change","title":"Test Startup Requirement - Callback for Status Change","text":"<p>Connection of the source device with the CompositeIn.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-callback-for-status-change","title":"Emulator Requirement - Callback for Status Change","text":"<p>Emulator will boot with the port informations coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-callback-for-status-change","title":"Control Plane Requirement - Callback for Status Change","text":"<p>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#callback-for-video-mode-change","title":"Callback for video mode change","text":"Description HAL APIs L2 L3 Control plane requirements Verify that the callback function properly updates the video mode changes and notifies the application when a COMPOSITE Input video mode changes after the composite signal is stable dsCompositeInRegisterVideoModeUpdateCB N Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#test-startup-requirement-callback-for-video-mode-change","title":"Test Startup Requirement - Callback for video mode change","text":"<p>Launching of the source device with the CompositeIn connected.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#emulator-requirement-callback-for-video-mode-change","title":"Emulator Requirement - Callback for video mode change","text":"<p>Emulator will boot with the port information and its video mode change information received from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-High-Level_TestSpec/#control-plane-requirement-callback-for-video-mode-change","title":"Control Plane Requirement - Callback for video mode change","text":"<ul> <li>Connecting and disconnecting source devices in the CompositeIn will be handled by the Control Plane.</li> <li>Provide resolution changes or configurations changes on the connected device that changes the video mode info.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/","title":"Device Settings Composite Input L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the Low Level L2 Test Specification and Procedure for the Device Settings Composite Input module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - ds-compositeIn-High-Level_TestSpec.md</li> <li><code>HAL Interface file</code> - dsCompositeIn Header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsCompositeIn_GetNumberOfInputs</code> Description Ensure that the function returns the expected number of COMPOSITE input ports by comparing the input port values parsed from the configuration YAML file for the platform under test. The value to be retrieved from the YAML is <code>dsCompositeIn/composite_input_configurations/number_of_ports</code>. Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the COMPOSITE Input module using <code>dsCompositeInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the number of COMPOSITE Input ports using <code>dsCompositeInGetNumberOfInputs</code> numInputs = valid buffer <code>dsERR_NONE</code> Should be successful 03 Compare the value returned by <code>dsCompositeInGetNumberOfInputs</code> with the value retrieved from the YAML file numInputs, <code>dsCompositeIn/composite_input_configurations/number_of_ports</code> from configuration file They should match Should be successful 04 Terminate the COMPOSITE Input module using <code>dsCompositeInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsCompositeInInit] --&gt;|Success| B[Parse 'Panel_CompositeInput.yaml']\nA --&gt;|Failure| A1[Test case fail: dsCompositeInInit failed]\nB --&gt;|Success| C[Call dsCompositeInGetNumberOfInputs]\nB --&gt;|Failure| B1[Test case fail: Parsing YAML file failed]\nC --&gt;|Success| E[Compare num of ports values]\nC --&gt;|Failure| C1[Test case fail: dsCompositeInGetNumberOfInputs failed]\nE --&gt;|Success| F[Call dsCompositeInTerm]\nE --&gt;|Failure| E1[Test case fail]\nF --&gt;|Success| G[Test case success]\nF --&gt;|Failure| F1[Test case fail: dsCompositeInTerm failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsCompositeIn_VerifyCompositeInputStatus</code> Description Verify the status of the Composite Inputs by ensuring it is in disable status. Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Composite Input using <code>dsCompositeInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the status of the Composite Input using <code>dsCompositeInGetStatus</code> status = valid buffer <code>dsERR_NONE</code> Should be successful 03 Check if the Composite Input is presented or not isPresented = false false Should be successful 04 Loop through and check if each of the Composite Input Port existing on the platform is connected or not status.isPortConnected[Port No] = false false Should be successful 05 Check the active port of the Composite Input status.activePort = <code>dsCOMPOSITE_IN_PORT_NONE</code> <code>dsCOMPOSITE_IN_PORT_NONE</code> Should be successful 06 Terminate the Composite Input using <code>dsCompositeInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsCompositeInInit] --&gt;|dsERR_NONE| Step2[Call dsCompositeInGetStatus]\n    Step1 --&gt;|Failure| Fail1[Test Case Failed: dsCompositeInInit failed]\n    Step2 --&gt;|dsERR_NONE| Step3[Check 'isPresented' field]\n    Step2 --&gt;|Failure| Fail2[Test Case Failed: dsCompositeInGetStatus failed]\n    Step3 --&gt;|isPresented = false| Step4Loop{Loop through each port as per test profile} --&gt; Step4\n    Step3 --&gt;|Failure| Fail3[Test Case Failed: isPresented field check failed]\n    Step4[Check 'isPortConnected' field] --&gt;|Failure| Fail4[Test Case Failed: isPortConnected field check failed] --&gt;     Step5LoopCheck[Loop check]\n    Step4 --&gt;|Passed| Pass1[isPortConnected field check passed] --&gt; Step5LoopCheck[Loop check]\n    Step5LoopCheck --&gt;|More ports| Step4Loop\n    Step5LoopCheck --&gt;|Loop ends| Step6[Check 'activePort' field]\n    Step6 --&gt;|activePort = dsCOMPOSITE_IN_PORT_NONE| Step7[Call dsCompositeInTerm]\n    Step6 --&gt;|Failure| Fail5[Test Case Failed: activePort field check failed]\n    Step7 --&gt;|dsERR_NONE| Step8[Test Case Passed]\n    Step7 --&gt;|Failure| Fail6[Test Case Failed: dsCompositeInTerm failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsCompositeIn_VerifyCompositeInPortSelectionAndStatus</code> Description Loop through all the existing composite ports on the platform, verify that the function successfully sets the specified COMPOSITE Input port when there is no connection of source device, and check the disable status of the port information using Get status. Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L2-Low-Level_TestSpec/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the COMPOSITE Input module using <code>dsCompositeInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through the supported COMPOSITE Input ports on the platform based on the get number of Inputs and select each port using <code>dsCompositeInSelectPort</code> port = <code>dsCompositeInGetNumberOfInputs</code> <code>dsERR_NONE</code> Should be successful 03 Get the status of the selected COMPOSITE Input port using <code>dsCompositeInGetStatus</code> status = valid buffer <code>dsERR_NONE</code> Should be successful 04 Check if the active port is the selected port ,if the port is not presented and if the port is not connected activePort = port, isPresented = false, isPortConnected = false activePort = port, isPresented = false, isPortConnected = false Should be successful 05 Terminate the COMPOSITE Input module using <code>dsCompositeInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsCompositeInInit] --&gt;|Success| B{Loop through &lt;br&gt; all composite &lt;br&gt; ports}\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|dsCOMPOSITE_IN_PORT_0 to dsCOMPOSITE_IN_PORT_MAX| C[Call dsCompositeInSelectPort &lt;br&gt; with current port]\n    C --&gt;|Success| D[Verify function sets &lt;br&gt; specified COMPOSITE &lt;br&gt; Input port]\n    D --&gt; E[Call dsCompositeInGetStatus]\n    E --&gt;|Success| F[Check disable status of the port]\n    F --&gt; G{End of Loop?}\n    G --&gt;|No| B\n    G --&gt;|Yes| H[Call dsCompositeInTerm]\n    H --&gt;|Success| I[Test case success]\n    H --&gt;|Failure| H1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/","title":"Device Settings Composite Input L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test</li> <li>YAML File Inputs</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Device Settings Composite Input module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DS</code>     - Device Settings</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>NA</code>     - Not Applicable</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#references","title":"References","text":"<ul> <li> <p><code>High Level Test Specification</code> - ds-compositeIn-High-Level_TestSpec.md</p> </li> <li> <p><code>HAL Interface file</code> - dsCompositeIn Header 4.0.0</p> </li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"# Streams Name Streams description 1 vts_SDR_stream Format: SDR,Resolution: 1920 x 1080 <p>Below are top test use-case for the Composite Input.</p> # Test-case Description Focus APIs 1 Verify the CompositeIn port connection with callbacks Connect/disconnect the CompositeIn source device on each of compositeIn port and check the callbacks is triggered when the connection status changes <code>dsCompositeInRegisterConnectCB()</code> 2 Verify the CompositeIn active port status with callbacks Connect a CompositeIn source device, select the CompositeIn port and check the callbacks is triggered when the active status changes(i.e like isPresented, activeport) <code>dsCompositeInRegisterStatusChangeCB()</code> 3 Scale the video and verify Play the video stream(<code>vts_SDR_stream</code>) in CompositeIn source device connected to the active CompositeIn port and scale the video resolution <code>dsCompositeInScaleVideo()</code> 4 Verify the CompositeIn Signal change with callback Connect a CompositeIn source device, select the CompositeIn port and check the callback is triggered when the change in signal status occurs(i.e like no signal , unstable signal, stable signal) <code>dsCompositeInRegisterSignalChangeCB()</code> 5 Verify the CompositeIn video mode change with callback Connect a CompositeIn source device, select the CompositeIn port, and verify that the callback is triggered when there is a change in the video mode on the source device <code>dsCompositeInRegisterVideoModeUpdateCB()</code>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsCompositeIn L3 Python test cases:</p> <pre><code>---\ntitle: dsCompositeIn - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- dsCompositeInHelperClass : inherits\n    dsCompositeInHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsCompositeIn : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsCompositeIn \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testConfig.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsCompositeIn</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-Low-Level-TestSpec/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsCompositeIn_Settings</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams etc.</li> <li> <p>Example configuration file dsCompositeIn_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsCompositeIn_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/","title":"dscompositeIn HAL L3 Python Test Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Run Test Cases</li> <li>Test Cases</li> <li>dsCompositeIn_test1_VerifyConnect_Callback.py</li> <li>dsCompositeIn_test2_VerifyStatus_Callback.py</li> <li>dsCompositeIn_test3_ScaleAndVerify_Video.py</li> <li>dsCompositeIn_test4_VerifySignal_Callback.py</li> <li>dsCompositeIn_test5_VerifyVideoMode_Callback.py</li> <li>dsCompositeIn_L3_Runall_Sink.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>     - Hardware Abstraction Layer</li> <li><code>L3</code>      - Level 3 Testing</li> <li><code>DUT</code>     - Device Under Test</li> <li><code>RAFT</code>    - Rapid Automation Framework for Testing</li> <li><code>YAML</code>    - YAML Ain't Markup Language</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file:</p> <ul> <li>Set the folder path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device.</li> <li>Specify the device profile path in <code>test/profile</code></li> <li>Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</li> </ul> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../../profiles/sink/Sink_CompositeInput.yaml\"\n            streams_download_url: \"&lt;URL_Path&gt;\" #URL path from which the streams are downloaded to the device\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: dscompositeIn_L3_testSetup.yml</p> <p>Provide the streams for each test case. This path is appended with <code>streams_download_url</code> entry from Device Configuration File</p> <p>If a test case requires multiple streams or needs to be validated using several streams, ensure that all necessary streams are added sequentially for that specific test case.</p> <pre><code>dscompositeIn:\n  description: \"dscompositeIn Device Settings test setup\"\n  assets:\n    device:\n        test1_VerifyConnect_Callback:\n          streams:\n        test2_VerifyStatus_Callback:\n          streams:\n        test3_ScaleAndVerify_Video:\n          streams:\n        test4_VerifySignal_Callback:\n          streams:\n        test5_VerifyVideoMode_Callback:\n          streams:\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: dsCompositeIn_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#dscompositein_test1_verifyconnect_callbackpy","title":"dsCompositeIn_test1_VerifyConnect_Callback.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>Yes: User interaction is necessary to connect/disconnect the Composite Source device (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Connect the external device and check if 'DUT' recognizes the events Disconnect the external device and check if 'DUT' recognizes the event</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test registers the event and checks for  the event call back.</p> <p>Success Criteria</p> <ul> <li>The device should recognize the connect/Disconnect event.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsCompositeIn_test1_VerifyConnect_Callback.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will Request the User to connect the Source device to the Composite In port:</p> </li> <li> <p>Question: \"Connect the compositeIn source device to Port port_type and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Device connect Confirmation:</p> </li> <li> <p>The test will check if the event has reached the device.</p> </li> <li>If the event is detected will mark the step as PASS</li> <li> <p>If the event is not detected will mark the step as FAIL</p> </li> <li> <p>Device Disconnect prompt:</p> <p>The test will Request the User to disconnect the Source device to the Composite In port:</p> </li> <li> <p>Question: \"Disconnect the compositeIn source device to Port port_type and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Device disconnect Confirmation:</p> </li> <li> <p>The test will check if the event has reached the device.</p> </li> <li>If the event detected will mark the step as PASS</li> <li> <p>If the event not detected will mark the step as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available  ports, connecting/disconnecting each one and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#dscompositein_test2_verifystatus_callbackpy","title":"dsCompositeIn_test2_VerifyStatus_Callback.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#platform-support-test02","title":"Platform Support - test02","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>Yes: User interaction is necessary to check the connect status of the Composite Source device (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<p>The test detects the status of the Source device connected to the Composite In port</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test registers the event and checks for  the event call back.</p> <p>Success Criteria</p> <ul> <li>The device should recognize the status of the port connected.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsCompositeIn_test2_VerifyStatus_Callback.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will Request the User to connect the Source device to the Composite In port:</p> </li> <li> <p>Question: \"Connect the compositeIn source device to Port port_type and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Device status Confirmation:</p> </li> <li> <p>The test will select the port and check if the device status event has reached the device.</p> </li> <li>If the event is detected will mark the step as PASS</li> <li> <p>If the event is not detected will mark the step as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available  ports, selecting each port and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all the ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#dscompositein_test3_scaleandverify_videopy","title":"dsCompositeIn_test3_ScaleAndVerify_Video.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#platform-support-test03","title":"Platform Support - test03","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>Yes: User interaction is necessary to check the composite connection with the source device and to verify the video scaling (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Test checks if video scaling happens on video from the Source device connected to the Composite In port</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#expected-results-test03","title":"Expected Results - test03","text":"<p>The test scales the video playing from compositeIn source device</p> <p>Success Criteria</p> <ul> <li>The user should see video scaling happening in 'DUT'.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsCompositeIn_test3_ScaleAndVerify_Video.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will Request the User to connect the Source device to the Composite In port:</p> </li> <li> <p>Question: \"Connect the compositeIn source device to Port port_type and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>The device changes the scale and requests user to confirm:</p> </li> <li> <p>Question: \"Check video scaled on port_type and press (Y/N)\"</p> </li> <li>Press Y if the user sees the video scaling. (this will mark the step as PASS).</li> <li> <p>Press N if the user cannot see the video scaling. (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for Scaling factor:</p> </li> </ul> <p>The test will iterate through all available scaling parameters and set scaling accordingly..</p> <ul> <li>Repeat for All Ports:</li> </ul> <p>The test will iterate through all available ports.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#dscompositein_test4_verifysignal_callbackpy","title":"dsCompositeIn_test4_VerifySignal_Callback.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#platform-support-test04","title":"Platform Support - test04","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>Yes: User interaction is necessary to connect/Disconnect the device (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>The test detects the signal status of the compositeIn signal.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>The test checks the signal change in the composite source</p> <p>Success Criteria</p> <ul> <li>Test identifies the signal change.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsCompositeIn_test4_VerifySignal_Callback.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will Request the User to connect the Source device to the Composite In port:</p> </li> <li> <p>Question: \"Connect the compositeIn source device to Port port_type and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Signal change confirmation:</p> </li> <li> <p>The test will check if the event has reached the device.</p> </li> <li>If the event is detected will mark the step as PASS</li> <li> <p>If the event is not detected will mark the step as FAIL</p> </li> <li> <p>Device Disconnect/Standby prompt:</p> <p>The test will Request the User to disconnect the Source device to the Composite In port or make Source device to standby mode:</p> </li> <li> <p>Question: \"Check if CompositeIn source is disconnected to port_type/set to standby and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Signal change confirmation:</p> </li> <li> <p>The test will check if the event has reached the device.</p> </li> <li>If the event is detected will mark the step as PASS</li> <li> <p>If the event is not detected will mark the step as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available ports.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#dscompositein_test5_verifyvideomode_callbackpy","title":"dsCompositeIn_test5_VerifyVideoMode_Callback.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#platform-support-test05","title":"Platform Support - test05","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#user-input-required-test05","title":"User Input Required - test05","text":"<p>Yes: User interaction is necessary to connect/Disconnect the device (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<p>The test detects the video mode change of the compositeIn video.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#expected-results-test05","title":"Expected Results - test05","text":"<p>The test checks the video mode change in the composite source</p> <p>Success Criteria</p> <ul> <li>Test identifies the video mode change.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsCompositeIn_test5_VerifyVideoMode_Callback.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will Request the User to connect the Source device to the Composite In port:</p> </li> <li> <p>Question: \"Connect the compositeIn source device to Port port_type and press Y: \"</p> </li> <li> <p>Press Y if the user connected the device and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Device connect confirmation:</p> </li> <li> <p>The test will check if the event has reached the device.</p> </li> <li>If the event is detected will mark the step as PASS</li> <li> <p>If the event is not detected will mark the step as FAIL</p> </li> <li> <p>Source video resolution change prompt:</p> <p>The test will Request the User to change the resolution of video on Source device connected to the Composite In port:</p> </li> <li> <p>Question: \"Change the resolution of video played from CompositeIn source device connected to port_type and press Y: \"</p> </li> <li> <p>Press Y if the user changed the resolution and acknowledged it. (this will mark the step as PASS).</p> </li> <li> <p>Source video resolution change confirmation:</p> </li> <li> <p>The test will check if the event has reached the device.</p> </li> <li>If the event is detected will mark the step as PASS</li> <li> <p>If the event is not detected will mark the step as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available ports.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsCompositeIn/ds-compositeIn-L3-TestProcedure/#dscompositein_l3_runall_sinkpy","title":"dsCompositeIn_L3_Runall_Sink.py","text":"<p>This python file runs all the tests supported by <code>sink</code> devices</p> <pre><code>python dsCompositeIn_L3_Runall_Sink.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/","title":"Device Settings Display L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the Low Level L2 test Specification and Procedure for the Device settings Display module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>     - Hardware Abstraction layer</li> <li><code>EDID</code>    - Extended Display Identification</li> <li><code>HDMI</code>    - High-Definition Multimedia Interface</li> <li><code>API</code>     - Application programming interface</li> <li><code>HAL</code>     - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>      - Unit Test(s)</li> <li><code>OEM</code>     - Original Equipment Manufacture</li> <li><code>SoC</code>     - System on a Chip</li> <li><code>DS</code>      - Device Settings</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsDisplay_TestSpecificaion.md</li> <li><code>HAL Interface file</code> - dsDisplay.h</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsDisplay_RetrieveAndValidateEDID_sink</code> Description For the sink device, retrieve EDID information for the display type 'dsVIDEOPORT_TYPE_INTERNAL' using GetEDID and GetEDIDBytes, then validate the values against the data available in the \"Panel_4K_Display.yaml\" profile file. The values to be validated are the 'EDID_Data/productCode' for GetEDID and the 'EDID_Data/edidBytes'(which stands for Manufacturer ID) at bytes 8 and 9 against the values available in the profile file for GetEDIDBytes. Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the display using <code>dsDisplayInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the display handle using <code>dsGetDisplay</code> for the <code>dsVIDEOPORT_TYPE_INTERNAL</code> type type = <code>dsVIDEOPORT_TYPE_INTERNAL</code>, index = 0 <code>dsERR_NONE</code> Should be successful 03 Retrieve EDID information using <code>dsGetEDID</code> handle = obtained from step 02 <code>dsERR_NONE</code> Should be successful 04 Validate with the product code data available in the profile file product code, <code>dsDisplay/EDID_Data/productCode</code> Value matches Should be successful 05 Retrieve EDID bytes using <code>dsGetEDIDBytes</code> handle = obtained from step 02, edidBytes = valid buffer, length = valid buffer <code>dsERR_NONE</code> Should be successful 06 Validate with the Manufacturer ID at bytes 8 and 9 against the values available in the profile file Manufacturer ID , <code>dsDisplay/EDID_Data/edidBytes</code> Value matches Should be successful 07 Terminate the display using <code>dsDisplayTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsDisplayInit] --&gt;|dsERR_NONE| B[Call dsGetDisplay]\n    A --&gt;|!= dsERR_NONE| A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle| C[Parse 'Panel_CompositeInput.yaml']\n    C--&gt; D[Call dsGetEDID]\n    B --&gt;|!= dsERR_NONE or invalid handle| B1[Test case fail]\n    D --&gt;|dsERR_NONE and valid dsDisplayEDID_t| E[Compare productcode values]\n    D --&gt;|!= dsERR_NONE or invalid dsDisplayEDID_t| D1[Test case fail]\n    E --&gt; F[Call dsGetEDIDBytes]\n    F --&gt;|dsERR_NONE and valid buffer and length &gt;= 0| G[Compare Manufacturer ID values]\n    F --&gt;|!= dsERR_NONE or invalid buffer or length &lt; 0| F1[Test case fail]\n    G --&gt; H[Call dsDisplayTerm]\n    H --&gt;|dsERR_NONE| I[Test case success]\n    H --&gt;|!= dsERR_NONE| H1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsDisplay_TestDefaultAspectRatio_source</code> Description Test the default aspect ratio (16:9) without any TV connected on source devices. Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-L2-Low-Level_TestSpec/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the display using <code>dsDisplayInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the display handle using <code>dsGetDisplay</code> with <code>dsVIDEOPORT_TYPE_HDMI</code> and index 0 <code>dsVIDEOPORT_TYPE_HDMI</code>, 0 <code>dsERR_NONE</code> Should be successful 03 Get the display aspect ratio using <code>dsGetDisplayAspectRatio</code> with the handle obtained from <code>dsGetDisplay</code> handle obtained from <code>dsGetDisplay</code> and aspectRatio = valid buffer <code>dsERR_NONE</code>, <code>dsVIDEO_ASPECT_RATIO_16x9</code> Should be successful 04 Verify that the aspect ratio is <code>dsVIDEO_ASPECT_RATIO_16x9</code> None <code>dsVIDEO_ASPECT_RATIO_16x9</code>, <code>dsDisplay/AspectRatio</code> Should be successful 05 Terminate the display using <code>dsDisplayTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsDisplayInit] --&gt;|dsERR_NONE| B[Call dsGetDisplay]\nB --&gt;|dsERR_NONE| C[Call dsGetDisplayAspectRatio]\nC --&gt;|dsERR_NONE| D[Verify aspect ratio is dsVIDEO_ASPECT_RATIO_16x9]\nD --&gt;|Verified| E[Call dsDisplayTerm]\nE --&gt;|dsERR_NONE| F[Test case success]\nA --&gt;|!=dsERR_NONE| G[Test case fail]\nB --&gt;|!=dsERR_NONE| H[Test case fail]\nC --&gt;|!=dsERR_NONE| I[Test case fail]\nD --&gt;|Not Verified| J[Test case fail]\nE --&gt;|!=dsERR_NONE| K[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/","title":"Device Settings Display High Level Test Specification Document","text":""},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>       - Hardware Abstraction layer</li> <li><code>EDID</code>      - Extended Display Identification</li> <li><code>API</code>       - Application programming interface</li> <li><code>CPU</code>       - Central processing unit</li> <li><code>RDK</code>       - Reference Design Kit</li> <li><code>dsDisplay</code> - Device Settings Display</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>EDID</code> Specifications - https://en.wikipedia.org/wiki/Extended_Display_Identification_Data</li> <li>Python <code>EDID</code> decoder library is available here - https://pypi.org/project/pyedid/</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the high level testing requirements for the dsDisplay module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, emulator requirements, control plane requirements and expected deliverables.</p> <ul> <li>Interface of the test is available in this link - https://github.com/rdkcentral/rdk-halif-device_settings/blob/main/include/dsDisplay.h</li> <li><code>HAL</code> Specification in this link - https://github.com/rdkcentral/rdk-halif-device_settings/blob/main/docs/pages/ds-display_halSpec.md</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#module-description","title":"Module Description","text":"<p>High level overview:</p> <ul> <li><code>dsDisplay</code> offers a range of APIs for retrieving information about the Display Device.</li> <li>Data is retrieved from the Display Device and HDMI. This data is passed to the caller.</li> <li>In order to retrieve HDMI information, an external device must be connected.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Test Description 1 Get EDID Information Test validates the accuracy and functionality of the display device module's functions (dsGetEDID and dsGetEDIDBytes) in retrieving the Extended Display Identification Data (EDID) from connected display devices 2 Get Aspect Ratio Test provides the aspect ratio of the display device 3 Callback Registration for Display Related Events To verify the callback registration for display related events. The display events are Display connected event, Display disconnected event, Rx Sense ON event, Rx Sense OFF event, HDCP protocol version change event -----------"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#get-edid-information","title":"Get EDID Information","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements The Get EDID Information test aims to verify the functionality of the display device module's dsGetEDID and dsGetEDIDBytes functions, which are responsible for retrieving the Extended Display Identification Data (EDID) from connected display devices. This test ensures that the module can accurately retrieve and interpret EDID information, providing essential data about the display's capabilities and characteristics. dsGetEDID(), dsGetEDIDBytes() N Y Y N N For the sink device, retrieve EDID information for the 'dsVIDEOPORT_TYPE_INTERNAL' type using GetEDID and GetEDIDBytes, then validate the values against the data available in the profile file. The values to be validated are the 'EDID_Data/productCode' for GetEDID and the 'EDID_Data/edidBytes'(which stands for Manufacturer ID) at bytes 8 and 9 against the values available in the profile file \"Panel_4K_Display.yaml\" for GetEDIDBytes. dsGetEDID(), dsGetEDIDBytes() Y N N Y N"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#test-startup-requirement-get-edid-information","title":"Test Startup Requirement - Get EDID Information","text":"<p>Launch the test with the predefined configuration set of results.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#emulator-requirement-get-edid-information","title":"Emulator Requirement - Get EDID Information","text":"<p>Emulator will boot with the EDID coming from the configuration file.</p> # Description 1 EDID for a panel TV <p>TODO: Generate a list of sample list for 5 to 6 different TV's. Generate a list of TV's from the office for the different EDIDs and store the binaries of the test. It can use it as samples.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#control-plane-requirement-get-edid-information","title":"Control Plane Requirement - Get EDID Information","text":"<p>Switching between the EDIDs of multiple TVs controlled by the control plane</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#get-aspect-ratio","title":"Get Aspect Ratio","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Test the default aspect ratio (16:9) without any TV connected. dsGetDisplayAspectRatio() Y N Y N N Adjust and test the different aspect ratios (4:3, 16:9) to ensure they provide the expected aspect ratio. dsGetDisplayAspectRatio() N Y Y N Y"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#emulator-requirement-get-aspect-ratio","title":"Emulator Requirement - Get Aspect Ratio","text":"<p>Emulator will boot with the Aspect ratio coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#control-plane-requirement-get-aspect-ratio","title":"Control Plane Requirement - Get Aspect Ratio","text":"<p>Maintains the configuration of various aspect ratios and provides them whenever a user is supposed to make a change.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#callback-registration-for-display-related-events","title":"Callback Registration for Display Related Events","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Test the 'Display connected' event. Upon connecting the display device, the callback should trigger the event dsRegisterDisplayEventCallback() N Y Y Y Y Test the 'Display disconnected' event. Upon disconnecting the display device, the callback should trigger the event dsRegisterDisplayEventCallback() N Y Y N Y Test the 'Rx Sense ON' event by verifying the presence of a signal from the receiving device; the callback should be triggered when the signal is detected dsRegisterDisplayEventCallback() N Y Y N Y Test the 'Rx Sense OFF' event by verifying the absense of a signal from the receiving device; the callback should be triggered when the signal is detected dsRegisterDisplayEventCallback N Y Y N Y Test the 'HDCP protocol version change' event by verifying if there is a change in the HDCP protocol version used for content protection; the callback should be triggered upon detection of the protocol change dsRegisterDisplayEventCallback() N Y Y N N"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#test-startup-requirement-callback-registration-for-display-related-events","title":"Test Startup Requirement - Callback Registration for Display Related Events","text":"<p>Launch the test with the configured HDCP 1.x and HDCP 2.x keys.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#emulator-requirement-callback-registration-for-display-related-events","title":"Emulator Requirement - Callback Registration for Display Related Events","text":"<p>Emulator will boot with the predefined set of HDCP keys coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display-high-Level_TestSpec/#control-plane-requirement-callback-registration-for-display-related-events","title":"Control Plane Requirement - Callback Registration for Display Related Events","text":"<ul> <li>The control plane will generate events for HDMI connection and disconnection. It also supplies signals to the receiving devices to initiate the Rx Sense ON/Rx Sense OFF events.</li> <li>The Control Plane will handle connection/disconnection, measuring the timing between both and ensuring it meets the expected time.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/","title":"Display Settings L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>References</li> <li>Level 3 Test Procedure</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>  - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>   - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>L3</code>   - Level 3 Testing</li> <li><code>DS</code>   - Device Settings</li> <li><code>EDID</code> - Extended Display Identification Data</li> <li><code>DUT</code>  - Device Under Test</li> <li><code>RAFT</code> - Rapid Automation Framework for Testing</li> <li><code>Y</code>    - yes supported</li> <li><code>NA</code>   - Not Supported</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Test Procedure for the Device Settings Display module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>Display Interface file</code> - dsDisplay.h</li> <li><code>High Level Test Specification</code> - ds-display_High-Level_TestSpecification.md</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Below are the top test use cases for the display.</p> # Test-case Description HAL APIs Source Sink 1 Verify Display Events with callbacks Connect/disconnect the display device on each port and verify that the callbacks are triggered for display connected, display disconnected, Rx Sense ON, Rx Sense OFF, and HDCP protocol version change events <code>dsRegisterDisplayEventCallback()</code> <code>Y</code> <code>Y</code> 2 Retrieves and interprets EDID information Connect various pre-defined displays to the device, retrieve their EDID information, and compare it against the expected EDID data <code>dsGetEDID()</code> <code>Y</code> <code>NA</code> 3 Gets the EDID buffer and EDID length Verify that the edid buffer contains the expected EDID data, and the length is accurate <code>dsGetEDIDBytes()</code> <code>Y</code> <code>NA</code> 4 Gets Aspect Ratio Verify that the aspect ratio of the display is correctly retrieved and matches the expected value for a given configuration <code>dsGetDisplayAspectRatio()</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsDisplay L3 Python test cases:</p> <pre><code>---\ntitle: dsDisplay- Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- L3_TestClasses : inherits\n    ut_raft &lt;|-- dsDisplayHelperClass : inherits\n    dsDisplayHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsDisplay : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsDisplay \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testConfig.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsDisplay</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsDisplay_Settings</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file dsDisplay_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsDisplay_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/","title":"Device Settings Display L3 Test Case and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Setting Up Test Environment</li> <li>Run Test Cases</li> <li>Test Case Procedure</li> <li>dsDisplay_test01_VerifyDisplayConnectCallBackTest.py</li> <li>dsDisplay_test02_TestVerifyDisplayEdid.py</li> <li>dsDisplay_test03_AspectRatioVerificationTest.py</li> <li>dsDisplay_test04_TestVerifyDisplayEdidBytes.py</li> <li>dsDisplay_L3_Runall_Source.py</li> <li>dsDisplay_L3_Runall_Sink.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#overview","title":"Overview","text":"<p>This document describes the VTS Level 3 Test scenarios and the execution process for the Device Setting Display Module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>  - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>   - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> <li><code>HDMI</code> - High-Definition Multimedia Interface</li> <li><code>EDID</code> - Extended Display Identification Data</li> <li><code>RAFT</code> - Rapid Automation Framework for Testing</li> <li><code>Y</code>    - yes supported</li> <li><code>NA</code>   - Not Supported</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#references","title":"References","text":"<ul> <li> <p><code>High Level Test Specification</code> - dsDisplay High Level TestSpec</p> </li> <li> <p><code>dsDisplay L3 Low Level Test Specification</code> - dsDisplay L3 Low Level TestSpec</p> </li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases. ssh_hal_test Executes the HAL binary for the test case. <p>```yaml rackConfig:   - dut:       ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device       description: \"stb device under test\"       platform: \"stb\"       consoles:         - default:             type: \"ssh\"             port: 10022             username: \"root\"             ip: \"XXX.XXX.XXX\" # IP address of the device             password: ' '         - ssh_hal_test:             type: \"ssh\"             port: 10022             username: \"root\"             ip: \"XXX.XXX.XXX\" # IP address of the device             password: ' '       outbound:         download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device         upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location         upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"         httpProxy:   # Local proxy if required         workspaceDirectory: './logs/workspace'   # Local working directory</p> <pre><code>#### Device Configuration File\n\nExample Device configuration File: [deviceConfig.yml](../../../host/tests/configs/deviceConfig.yml)\n\nFor more details refer [RAFT](https://github.com/rdkcentral/python_raft/blob/1.0.0/README.md) and [example_device_config.yml](https://github.com/rdkcentral/python_raft/blob/1.0.0/examples/configs/example_device_config.yml)\n\nUpdate the target directory where `HAL` binaries will be copied into the device. Also, map the profile to the source/sink settings `YAML` file path.\n\nEnsure the platform should match with the `DUT` platform in [Rack Configuration](#rack-configuration-file)\n\n```yaml\ndeviceConfig:\n  cpe1:\n    platform: \"stb\"    # Must match the platform in example_rack_config.yml\n    model: \"uk\"\n    target_directory: \"/tmp\"  # Path where HAL binaries are copied in device\n    test:\n      profile: \"../../../../profiles/source/Source_4K_Display.yaml\"\n      player:\n        tool: \"gstreamer\"\n        prerequisites:\n          - export xxxx    # Pre-commands required to play the stream\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Update the artifact paths from which the binaries should be copied to the device.</p> <p>Set the execution paths for each test case.</p> <ul> <li>Example configuration file: dsDisplay_L3_testSetup.yml.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Update the execute command according to the device path where <code>HAL</code> binaries are copied and Update the test suite for each level test case</p> <ul> <li>Example configuration file: dsDisplay_testConfig.yml.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#test-case-procedure","title":"Test Case Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#dsdisplay_test01_verifydisplayconnectcallbacktestpy","title":"dsDisplay_test01_VerifyDisplayConnectCallBackTest.py","text":"<p>Overview:</p> <p>This test verifies display event callbacks by connecting and disconnecting a display device on each supported video port, ensuring that appropriate callbacks are triggered for display connection, disconnection, Rx Sense ON, Rx Sense OFF, and HDCP protocol version change events.</p> <p>Platform Supported:</p> <ul> <li>Source</li> <li>Sink</li> </ul> <p>User Input Required:</p> <p>Yes: User input is required to manually change the display status (connect/disconnect) during the test execution, with the prompt question <code>Change the {port} status to {event} and press Enter:</code> (This will be automated later).</p> <p>Acceptance Criteria:</p> <p>The test will pass if each display event triggers the expected callback for every supported display port.</p> <p>Expected Results:</p> <p>The test will raise events for connecting and disconnecting the display and verify that the expected callbacks are received for each event. The test will pass if all expected callbacks are detected; otherwise, it will fail.</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsDisplay_test01_VerifyDisplayConnectCallBackTest.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsDisplay_test01_VerifyDisplayConnectCallBackTest.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li> <p>The test will download all required artifacts, copy them to the target directory, and start execution.</p> </li> <li> <p>Callback Event Verification:</p> </li> <li> <p>Prompting the user to change display status for each supported port (connect/disconnect)</p> </li> <li>Capture and verify the device's callback status to confirm receipt of the expected event callback.</li> <li> <p>For each event, verify the following:</p> <ul> <li>dsDISPLAY_EVENT_CONNECTED</li> <li>dsDISPLAY_EVENT_DISCONNECTED</li> <li>dsDISPLAY_RXSENSE_ON</li> <li>dsDISPLAY_RXSENSE_OFF</li> <li>dsDISPLAY_HDCPPROTOCOL_CHANGE</li> </ul> </li> <li> <p>Completion and results:</p> </li> </ul> <p>After verifying all callback statuses, the test will conclude and display the final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#dsdisplay_test02_testverifydisplayedidpy","title":"dsDisplay_test02_TestVerifyDisplayEdid.py","text":"<p>Overview:</p> <p>This test case is designed for Source devices and focuses on retrieving and verifying the <code>EDID</code> by connecting various pre-defined displays to each supported video port. The test compares the <code>EDID</code> data retrieved from the connected displays against expected values to ensure accurate identification. It uses the dsDisplay_test_MonitorDetails.yml file, which contains the details of the connected monitors for verification.</p> <p>Platform Supported:</p> <ul> <li>Source</li> </ul> <p>User Input Required:</p> <p>Yes: User input is required to manually connect the display to the specified port, with the prompt question <code>Connect Device: {display} to Port: {port} and Press Enter:</code> (This will be automated later).</p> <p>Acceptance Criteria:</p> <p>This test retrieves and verifies <code>EDID</code> by connecting various pre-defined displays to each supported video port. It then compares the retrieved <code>EDID</code> data against expected values to ensure accurate display identification.</p> <p>Expected Results:</p> <p>Connect each specified display device, retrieve <code>EDID</code> data, and confirm that the retrieved monitor names match the expected values defined in dsDisplay_test_MonitorDetails.yml, returning a pass/fail status based on the comparison.</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsDisplay_test02_TestVerifyDisplayEdid.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsDisplay_test02_TestVerifyDisplayEdid.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li> <p>The test will download all required artifacts, copy them to the target directory, and start execution.</p> </li> <li> <p>Display Device Verification:</p> </li> <li> <p>For each available video port, the test prompts the user to connect the specified display device (LG, Philips, Sony, Samsung).</p> </li> <li>The test will retrieve the <code>EDID</code> information from the connected display device and verify it against the expected details, such as the monitor name, for each display device.</li> <li> <p>It will confirm that the <code>monitorName</code> field in the retrieved <code>EDID</code> matches the expected monitor name specified in dsDisplay_test_MonitorDetails.yml.</p> </li> <li> <p>Completion and Results:</p> </li> </ul> <p>After verifying the <code>EDID</code> information for all connected display devices, the test will conclude and display the final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#dsdisplay_test03_aspectratioverificationtestpy","title":"dsDisplay_test03_AspectRatioVerificationTest.py","text":"<p>Overview:</p> <p>This test retrieves and verifies the aspect ratio of the display on each supported video port. For each specified aspect ratio, the test checks that the retrieved aspect ratio matches the expected value, ensuring that the display correctly adapts to the given configuration.</p> <p>Platform Supported:</p> <ul> <li>Source</li> </ul> <p>User Input Required:</p> <p>Yes: User input is required to manually set the aspect ratio for the specified port, with the prompt question <code>Set the aspect ratio {aspectRatio} to Port: {port} and Press Enter:</code> (This will be automated later).</p> <p>Acceptance Criteria:</p> <p>Verify that the display\u2019s aspect ratio is correctly retrieved for each configured setting (16x9, 4x3).</p> <p>Expected Results:</p> <p>The test will set various aspect ratios, retrieve the current aspect ratio from the display, and confirm that it matches the expected value. The test will pass if all aspect ratios are correctly identified; otherwise, it will fail.</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsDisplay_test03_AspectRatioVerificationTest.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsDisplay_test03_AspectRatioVerificationTest.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li> <p>The test will download the required artifacts, then copy them to the target directory.</p> </li> <li> <p>Aspect Ratio Verification</p> </li> <li>For each video port, the user will be prompted to set the specified aspect ratio on the port and confirm by pressing Enter.</li> <li>The test will retrieve the aspect ratio from the connected display device.</li> <li> <p>The retrieved aspect ratio will be compared to the expected value for each configuration.</p> </li> <li> <p>Completion and Results:</p> </li> </ul> <p>If all expected aspect ratios are verified for each port, the test will conclude and display the final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#dsdisplay_test04_testverifydisplayedidbytes","title":"dsDisplay_test04_TestVerifyDisplayEdidBytes","text":"<p>Overview:</p> <p>This test case is designed for Source devices and focuses on retrieving and verifying the <code>EDID</code> bytes by connecting various pre-defined displays to each supported video port. The test parses the <code>EDID</code> bytes retrieved from the connected displays against expected values to ensure accurate identification. It uses the dsDisplay_test_MonitorDetails.yml file, which contains the details of the connected monitors for verification.</p> <p>Platform Supported:</p> <ul> <li>Source</li> </ul> <p>User Input Required:</p> <p>Yes: User input is required to manually connect the display to the specified port, with the prompt question <code>Connect Device: {display} to Port: {port} and Press Enter:</code> (This will be automated in future versions.)</p> <p>Acceptance Criteria:</p> <p>Connect each display to the supported video ports, retrieve the <code>EDID</code> bytes, and verify them against the expected <code>EDID</code> data.</p> <p>Expected Results:</p> <p>The test will retrieve and parse <code>EDID</code> bytes for each connected display. It will verify that the <code>EDID</code> information, including fields like manufacturerId and monitorName, matches the expected values for each display. The test will pass if all expected <code>EDID</code> details are retrieved and verified correctly for each display and port.</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsDisplay_test04_TestVerifyDisplayEdidBytes</code> with the appropriate configuration:</li> </ul> <pre><code>dsDisplay_test04_TestVerifyDisplayEdidBytes --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li> <p>The test will download the required artifacts, then copy them to the target directory.</p> </li> <li> <p>EDID Bytes Verification:</p> </li> <li>For each display, the test will prompt the user to connect the display to the specified port.</li> <li>The test will retrieve the <code>EDID</code> bytes from the connected display device.</li> <li> <p>The test will verify the retrieved <code>EDID</code> bytes against the expected details, such as manufacturer ID and monitor name, for each connected display.</p> </li> <li> <p>Completion and Results:</p> </li> </ul> <p>If all expected <code>EDID</code> bytes are verified, the test will conclude and display the final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#dsdisplay_l3_runall_sourcepy","title":"dsDisplay_L3_Runall_Source.py","text":"<p>This python file runs all the tests supported by <code>source</code> devices</p> <pre><code>python dsDisplay_L3_Runall_Source.py  --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsDisplay/ds-display_L3_TestProcedure/#dsdisplay_l3_runall_sinkpy","title":"dsDisplay_L3_Runall_Sink.py","text":"<p>This python file runs all the tests supported by <code>sink</code> devices</p> <pre><code>python dsDisplay_L3_Runall_Sink.py  --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/","title":"Device Settings Front Panel Display High Level Test Specification Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>     - Hardware Abstraction layer</li> <li><code>SOC</code>     - System On a Chip</li> <li><code>FP</code>      - Front Panel</li> <li><code>FPD</code>     - Front Panel Display</li> <li><code>ds</code>      - Device Settings.</li> <li><code>LED</code>     - Light Emitting Devices</li> <li><code>dsFPD</code>   - Device Settings Front Panel Display</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the High Level Test Specification requirements for the <code>dsFPD</code> module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, emulator requirements, control plane requirements, and expected deliverables.</p> <p>The interface of the test is available here: ds-fdp HAl Header</p> <p><code>Note: There will be no test case implemented to verify the 7-segment front panel display LEDs.</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#module-description","title":"Module Description","text":"<p>High-level overview:</p> <ul> <li><code>dsFPD</code> provides a set of APIs to control the <code>FP</code>discrete <code>LED</code>s and 7-segment <code>LED</code>s existing on a platform.</li> <li>It facilitates the communication to <code>FP</code> <code>LED</code>s, aiding in their configuration and utilization within the system. The <code>LED</code>s is controlled by the caller based on the platform requirements. Interface specification is available here: ds-fdp HAl Spec</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Test Description 1 Discrete <code>LED</code> Brightness Control The test aims to set and verify the Brightness of the discrete <code>LED</code>s supported on the platform. 2 Discrete <code>LED</code> Blink Control The test aims to set and verify the blink activity of the discrete <code>LED</code>s supported on the platform 3 Discrete <code>LED</code> Color Control The test aims to set and verify the color control activities of the discrete <code>LED</code>s supported on the platform 4 Discrete Power <code>LED</code> Control The test aims to set and verify the discrete Power <code>LED</code> supported on the platform"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#discrete-led-brightness-control","title":"Discrete <code>LED</code> Brightness Control","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's OFF, set it to ON. 3. Set the brightness of the discrete <code>LED</code> within the specified range (min-max) and verify using the get function. Note: 1. For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) 2. for Brightness range check  Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/MAX_BRIGHTNESS and dsFPD/SupportedFPDIndicators/[Indicator number]/MIN_BRIGHTNESS</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/MAX_BRIGHTNESS and dsFPD/SupportedFPDIndicators/[Indicator number]/MIN_BRIGHTNESS</code>) dsGetFPState(), dsSetFPState(), dsSetFPBrightness(), dsGetFPBrightness() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's ON, set it to OFF. 3. Set the brightness of the discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>.Note: For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsGetFPState(), dsSetFPState(), dsSetFPBrightness() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1.Check the current state of the <code>FP</code>.2. If it's OFF, set it to ON. 3. Set the brightness of the discrete <code>LED</code> and verify brightness intensity with help of control plane.Note: 1. For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) 2. for Brightness range check  Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/MAX_BRIGHTNESS and dsFPD/SupportedFPDIndicators/[Indicator number]/MIN_BRIGHTNESS</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/MAX_BRIGHTNESS and dsFPD/SupportedFPDIndicators/[Indicator number]/MIN_BRIGHTNESS</code>) dsGetFPState(), dsSetFPState(), dsSetFPBrightness() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#test-startup-requirement-discrete-led-brightness-control","title":"Test Startup Requirement-Discrete <code>LED</code> Brightness Control","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#emulator-requirement-discrete-led-brightness-control","title":"Emulator Requirement-Discrete <code>LED</code> Brightness Control","text":"<p>The emulator will boot with the <code>LED</code> configurations that should include</p> <ol> <li>Number of discrete <code>LED</code>s, available</li> <li>Max and Min value of Brightness.</li> <li>Default brightness of each discrete <code>LED</code></li> </ol>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#control-plane-requirement-discrete-led-brightness-control","title":"Control Plane Requirement-Discrete <code>LED</code> Brightness Control","text":"<p>Read the brightness intensity of the <code>LED</code> when set to a different level and compare it with the previous intensity value using a <code>LED</code> detector device.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#discrete-led-blink-control","title":"Discrete <code>LED</code> blink control","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's OFF, set it to ON. 3. set the blink functionality of discrete <code>LED</code> and verify Blink interval with help of control plane.Note: For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsGetFPState(), dsSetFPState(), dsSetFPBlink() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's ON, set it to OFF. 3. set the blink functionality of discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>.Note: For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsGetFPState(), dsSetFPState(), dsSetFPBlink() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#test-startup-requirement-discrete-led-blink-control","title":"Test Startup Requirement-Discrete <code>LED</code> blink control","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#emulator-requirement-discrete-led-blink-control","title":"Emulator Requirement-Discrete <code>LED</code> blink control","text":"<p>The emulator will boot with the <code>LED</code> configurations that should include</p> <ol> <li>Number of discrete <code>LED</code>s, available</li> </ol>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#control-plane-requirement-discrete-led-blink-control","title":"Control Plane Requirement-Discrete <code>LED</code> blink control","text":"<p>Read the Blink interval from the <code>LED</code> detector device.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#discrete-led-color-control","title":"Discrete <code>LED</code> color control","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's OFF, set it to ON. 3. Check the indicator supports multi-colored 4. set the color functionality of discrete <code>LED</code> available by setting and getting different colors supported by the discrete <code>LED</code> Note: 1. For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) 2. for indicator color support check  Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/DEFAULT_COLOR_MODE</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/DEFAULT_COLOR_MODE</code>) dsGetFPState(), dsSetFPState(), dsSetFPColor(), dsGetFPColor() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's ON, set it to OFF. 3. set the color functionality of discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>.Note: For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsGetFPState(), dsSetFPState(), dsSetFPColor() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's ON, set it to OFF. 3. Check the indicator supports <code>single-colored</code> 4. set the color functionality of discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>.Note: For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsGetFPState(), dsSetFPState(), dsSetFPColor() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's OFF, set it to ON. 3. Check the indicator supports multi-colored 4. set the color functionality of discrete <code>LED</code> available by setting and verify Blink interval with help of control plane. Note: 1. For supported <code>FPD</code> indicators check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) 2. for indicator color support check  Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/DEFAULT_COLOR_MODE</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/DEFAULT_COLOR_MODE</code>) dsGetFPState(), dsSetFPState(), dsSetFPColor() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#test-startup-requirement-discrete-led-color-control","title":"Test Startup Requirement-Discrete <code>LED</code> color control","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#emulator-requirement-discrete-led-color-control","title":"Emulator Requirement-Discrete <code>LED</code> color control","text":"<p>The emulator will boot with the <code>LED</code> configurations that should include</p> <ol> <li>Number of discrete <code>LED</code>s, available</li> <li>Supported colors for each <code>LED</code></li> </ol>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#control-plane-requirement-discrete-led-color-control","title":"Control Plane Requirement-Discrete <code>LED</code> color control","text":"<p>The control panel should be able to read the color of the <code>LED</code> through the specialized devices that shall identify the <code>LED</code> color and provide the same information to the control panel.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#discrete-power-led-control","title":"Discrete Power <code>LED</code> control","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Verify the <code>LED</code> state transitions 1.Loop through all supported <code>LED</code> states. 2. For each state, set the <code>LED</code> to that state using dsFPSetLEDState(). 3. Verify the state using dsFPGetLEDState(). 4. Ensure each state transition is valid.Note: 1.For supported <code>LED</code> states check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsFPGetSupportedLEDStates(), dsFPSetLEDState(), dsFPGetLEDState() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Verify the <code>LED</code> state transitions 1.Loop through all supported <code>LED</code> states. 2. For each state, set the <code>LED</code> to that state using dsFPSetLEDState(). 3. Verify the state with control plane. 4. Ensure each state transition is valid.Note: For supported <code>LED</code> states check profile file for Sink <code>Sink_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) and for Source <code>Source_FPD.yaml</code>(path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code>) dsFPGetSupportedLEDStates(), dsFPSetLEDState() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#test-startup-requirement-discrete-power-led-control","title":"Test Startup Requirement-Discrete Power <code>LED</code> control","text":"<p>NA</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#emulator-requirement-discrete-power-led-control","title":"Emulator Requirement-Discrete Power <code>LED</code> control","text":"<p>The emulator will boot with the <code>LED</code> configurations that should include</p> <ol> <li>Provide the configuration of Power <code>LED</code> states supported.</li> </ol>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_High-Level_TestSpec/#control-plane-requirement-discrete-power-led-control","title":"Control Plane Requirement-Discrete Power <code>LED</code> control","text":"<p>Due to platform-specific requirements, it may not be possible to capture the <code>LED</code> behavior in each state.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/","title":"Device Setting FPD L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Table of Contents</li> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the Low level l2 Specification and Procedure Documentation for the DSFPD module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> <li><code>FPD</code> - Front Panel Display</li> <li><code>LED</code> - Light Emitting Diode</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - ds-front-panel-display_High-Level_TestSpec.md</li> <li><code>HAL Interface file</code> - dsFPD Header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsFPD_SetFPstateON_SetBrightness</code> Description Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FPD</code>. 2. If it's OFF, set it to ON. 3. Set the brightness of the discrete <code>LED</code> within the specified range (min-max) and verify using the get function. Note: 1. For supported <code>FPD</code> indicators check configuration file using path <code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code> 2. for Brightness range checking by configuration file using path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/MIN_BRIGHTNESS</code> and <code>dsFPD/SupportedFPDIndicators/[Indicator number]/MAX_BRIGHTNESS</code> Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Front Panel Display (<code>FPD</code>) sub-module using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Iterate over the supported <code>FPD</code> indicators from configuration file and get the current state of the <code>FPD</code> using <code>dsGetFPState</code> eIndicator = list of supported FPD indicators <code>dsERR_NONE</code>, state = current state Should be successful 03 If the current state of the FP is OFF, set it to ON using <code>dsSetFPState</code> eIndicator = current indicator,  state = <code>dsFPD_STATE_ON</code> <code>dsERR_NONE</code> Should be successful 04 Set the brightness of the <code>LED</code> using <code>dsSetFPBrightness</code> eIndicator = current indicator, eBrightness = random value within minimum and maximum brightness from profile <code>dsERR_NONE</code> Should be successful 05 Verify the brightness of the <code>LED</code> using <code>dsGetFPBrightness</code> eIndicator = current indicator <code>dsERR_NONE</code>, brightness = eBrightness Should be successful 06 Terminate the Front Panel Display (<code>FPD</code>) sub-module using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsFPInit API] --&gt;|Success|B{Iterate over supported &lt;br&gt;FPD indicators from profile}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt; C[Call dsGetFPState API for each indicator]\n    C --&gt;|FP OFF|E[Call dsSetFPState API to set FP ON]\n    C --&gt;|FP ON|G[Call dsSetFPBrightness API &lt;br&gt; within min and max from profile]\n    E --&gt;|Success|G\n    G --&gt;|Success|H[Call dsGetFPBrightness API]\n    H --&gt;|Success|I[Check if brightness matches value set]\n    I --&gt;|Yes|B\n    B --&gt;|End of loop|K[Call dsFPTerm API]\n    K --&gt;|Success|L[Test case success]\n    K --&gt;|Failure|K1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsFPD_SetFPstateOFF_SetBrightness</code> Description Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FPD</code>. 2. If it's ON, set it to OFF. 3. Set the brightness of the discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>. Note: For supported <code>FPD</code> indicators check configuration file using the path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code> Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Front Panel Display (FPD) sub-module using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Iterate over the supported <code>FPD</code> indicators from configuration file and check the current state of the <code>FPD</code> using <code>dsGetFPState</code> eIndicator = eIndicator = list of supported <code>FPD</code> indicators <code>dsERR_NONE</code>, state = current state Should be successful 03 If the state is ON, set it to OFF using <code>dsSetFPState</code> eIndicator = current indicator, state = <code>dsFPD_STATE_OFF</code> <code>dsERR_NONE</code> Should be successful 04 Set the brightness of the discrete <code>LED</code> using <code>dsSetFPBrightness</code> eIndicator = current indicator, eBrightness = random value 0-100 <code>dsERR_OPERATION_NOT_SUPPORTED</code> Should be successful 05 Terminate the Front Panel Display sub-module using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsFPInit] --&gt;|Success|B{Iterate over &lt;br&gt; supported FPD &lt;br&gt; indicators}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt; C[Call dsGetFPState]\n    C --&gt;|state is &lt;br&gt; dsFPD_STATE_ON|E[Call dsSetFPState with &lt;br&gt; dsFPD_STATE_OFF]\n    C --&gt;|state is &lt;br&gt;dsFPD_STATE_OFF|G\n    E --&gt;|Success|G[Call dsSetFPBrightness]\n    G --&gt;|dsERR_OPERATION_NOT_SUPPORTED|B\n    B --&gt;|End of loop|L[Call dsFPTerm]\n    L --&gt;|Success|M[Test case success]\n    L --&gt;|Failure|L1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsFPD_SetFPstateOFF_SetBlink</code> Description Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FP</code>. 2. If it's ON, set it to OFF. 3. Set the blink functionality of discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>. Note: For supported <code>FPD</code> indicators check configuration file using the path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code> Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Front Panel Display (<code>FPD</code>) using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Iterate over all <code>FPD</code> indicators from profile and get the current state using <code>dsGetFPState</code> eIndicator =  list of supported <code>FPD</code> indicators <code>dsERR_NONE</code> , state = current state Should be successful 03 If the state is ON, set it to OFF using <code>dsSetFPState</code> eIndicator = current indicator, state = <code>dsFPD_STATE_OFF</code> <code>dsERR_NONE</code> Should be successful 04 Set the blink functionality of discrete <code>LED</code> using <code>dsSetFPBlink</code> eIndicator = current indicator, uBlinkDuration = 500, uBlinkIterations = 10 <code>dsERR_OPERATION_NOT_SUPPORTED</code> Should be successful 05 Terminate the <code>FPD</code> using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsFPInit API] --&gt;|Success|B{Iterate over &lt;br&gt; supported FPD &lt;br&gt;indicators}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt; C[Call dsGetFPState API]\n    C --&gt;|Success|D[Check if FP state is ON]\n    D --&gt;|State is ON|E[Call dsSetFPState API &lt;br&gt; to set it OFF]\n    D --&gt;|State is OFF|F[Call dsSetFPBlink API]\n    E --&gt;|Success|F\n    F --&gt;|Return is &lt;br&gt; dsERR_OPERATION_NOT_SUPPORTED|B\n    B --&gt;|End of loop|I[Call dsFPTerm API]\n    I --&gt;|Success|J[Test case success]\n    I --&gt;|Failure|I1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-4","title":"Test 4","text":"Title Details Function Name <code>test_l2_dsFPD_SetFPstateON_Multi_SetColor</code> Description Iterate over supported <code>FPD</code> indicators. For each SupportedFPDIndicators: 1. Check the current state of the <code>FP</code>. 2. If it's OFF, set it to ON. 3. Check the indicator supports multi-colored 4. set the color functionality of discrete <code>LED</code> available by setting and getting different colors supported by the discrete <code>LED</code> Note: 1. For supported <code>FPD</code> indicators check configuration file using path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code> 2. for indicator color support check configuration file using the path <code>dsFPD/SupportedFPDIndicators/[Indicator number]/DEFAULT_COLOR_MODE</code>) Test Group 02 Test Case ID 004 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-4","title":"Test Procedure - Test 4","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Front Panel Display (<code>FPD</code>) using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Iterate over all supported <code>FPD</code> indicators from profile eIndicator = list of supported <code>FPD</code> indicators <code>dsERR_NONE</code> Should be successful 03 Get the current state of the <code>FPD</code> indicator using <code>dsGetFPState</code> eIndicator = current indicator, state = valid buffer <code>dsERR_NONE</code>, state = current state Should be successful 04 If the state is OFF, set it to ON using <code>dsSetFPState</code> eIndicator = current indicator, state = <code>dsFPD_STATE_ON</code> <code>dsERR_NONE</code> Should be successful 05 Set the color of the <code>FPD</code> indicator that supports multi-color using <code>dsSetFPColor</code> eIndicator = current indicator, color = supported color from configuration file <code>dsERR_NONE</code> Should be successful 06 Get the color of the <code>FPD</code> indicator using <code>dsGetFPColor</code> eIndicator = current indicator, getcolor = valid buffer <code>dsERR_NONE</code>, getcolor = color Should be successful 07 Terminate the FPD using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsFPInit] --&gt;|Success|B{Iterate over &lt;br&gt; the supported &lt;br&gt; FPD indicators}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt; C[Call dsGetFPState]\n    C --&gt;|Success|D[Check if the state is OFF]\n    D --&gt;|State is OFF|E[Call dsSetFPState to set it to ON]\n    D --&gt;|State is ON|I\n    E --&gt;|Success|I[Check if the indicator &lt;br&gt; supports multi-colored]\n    I --&gt;|Multi-colored &lt;br&gt; is supported|G[Call dsSetFPColor &lt;br&gt; with supported colors]\n    I --&gt;|Multi-colored &lt;br&gt; is not supported|B\n    G --&gt;|Success|H[Call dsGetFPColor ]\n    H --&gt;|get and set matches|B\n    B --&gt;|No more indicators &lt;br&gt; to check|K[Call dsFPTerm]\n    K --&gt;|Success|L[Test case success]\n    K --&gt;|Failure|K1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-5","title":"Test 5","text":"Title Details Function Name <code>test_l2_dsFPD_SetFPstateOFF_SetColor</code> Description Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FPD</code>. 2. If it's ON, set it to OFF. 3. Set the color functionality of discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>. Note: For supported <code>FPD</code> indicators check configuration file using the path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code> Test Group 02 Test Case ID 005 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-5","title":"Test Procedure  - Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Front Panel Display (<code>FPD</code>) using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Iterate over all supported <code>FPD</code> indicators eIndicator = list of supported <code>FPD</code> indicators <code>dsERR_NONE</code> Should be successful 03 Get the current state of the <code>FPD</code> indicator using <code>dsGetFPState</code> eIndicator = current indicator, state = address of state variable <code>dsERR_NONE</code> , state = current state Should be successful 04 If the state is ON, set it to OFF using <code>dsSetFPState</code> eIndicator = current indicator, state = <code>dsFPD_STATE_OFF</code> <code>dsERR_NONE</code> Should be successful 05 Set the color functionality of the discrete <code>LED</code> using <code>dsSetFPColor</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code> eIndicator = current indicator, eColor = supported colors from configuration file <code>dsERR_OPERATION_NOT_SUPPORTED</code> Should be successful 06 Terminate the <code>FPD</code> using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsFPInit API] --&gt;|Success|B{Iterate over supported &lt;br&gt; FPD indicators}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt; C[Call dsGetFPState API]\n    C --&gt;|State is ON|E[Call dsSetFPState API &lt;br&gt; to set it OFF]\n    C --&gt;|State is OFF|F[Call dsSetFPColor API &lt;br&gt; with supported colors]\n    E --&gt;|Success|F\n    F --&gt;|Return is &lt;br&gt;dsERR_OPERATION_NOT_SUPPORTED|B\n    B --&gt; I[Call dsFPTerm API]\n    I --&gt;|Success|J[Test case success]\n    I --&gt;|Failure|I1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-6","title":"Test 6","text":"Title Details Function Name <code>test_l2_dsFPD_SetFPstateON_Single_SetColor</code> Description Iterate over supported <code>FPD</code> indicators. For each supported indicator: 1. Check the current state of the <code>FPD</code>. 2. If it's ON, set it to OFF. 3. Check the indicator supports <code>single-colored</code> 4. set the color functionality of discrete <code>LED</code> and check it returns <code>dsERR_OPERATION_NOT_SUPPORTED</code>. Note: For supported <code>FPD</code> indicators check configuration file using the path:<code>dsFPD/SupportedFPDIndicators/[Indicator number]/Indicator_type</code> Test Group 02 Test Case ID 006 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-6","title":"Test Procedure  - Test 6","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the Front Panel Display (<code>FPD</code>) using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Iterate over all <code>FPD</code> indicators and check if they are supported eIndicator = list of supported <code>FPD</code> indicators <code>dsERR_NONE</code> Should be successful 03 Get the current state of the <code>FPD</code> indicator using <code>dsGetFPState</code> eIndicator = current indicator, state = valid buffer <code>dsERR_NONE</code>, state = current state Should be successful 04 If the state is OFF, set it to ON using <code>dsSetFPState</code> eIndicator = current indicator, state = <code>dsFPD_STATE_ON</code> <code>dsERR_NONE</code> Should be successful 05 Set the color of the <code>FPD</code> indicator that supports single-color using <code>dsSetFPColor</code> eIndicator = current indicator, eColor = valid color <code>dsERR_OPERATION_NOT_SUPPORTED</code> Should be successful 06 Terminate the FPD using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsFPInit API] --&gt;|Success|B{Iterate over supported &lt;br&gt; FPD indicators}\n    A --&gt;|Failure|A1[Test case fail]\n    B --&gt; C[Call dsGetFPState API]\n    C --&gt;|State is OFF|E[Call dsSetFPState API &lt;br&gt; to set it ON]\n    C --&gt;|State is ON|F\n    E --&gt;|Success|F[Check if indicator &lt;br&gt; supports single-color]\n    F --&gt;|Supports single-colored|G[Call dsSetFPColor API &lt;br&gt; with supported color]\n    F --&gt;|Doesn't support &lt;br&gt; single-color|B\n    G --&gt;|Returns &lt;br&gt; dsERR_OPERATION_NOT_SUPPORTED|B\n    B --&gt;|End of loop|I[Call dsFPTerm API]\n    I --&gt;|Success|J[Test case success]\n    I --&gt;|Failure|I1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-7","title":"Test 7","text":"Title Details Function Name <code>test_l2_dsFPD_VerifyLEDStateTransitions</code> Description Verify the <code>LED</code> state transitions 1.Loop through all supported <code>LED</code> states. 2. For each state, set the <code>LED</code> to that state using <code>dsFPSetLEDState</code>. 3. Verify the state using <code>dsFPGetLEDState</code>. 4. Ensure each state transition is valid. Test Group 02 Test Case ID 007 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L2_Low-Level_TestSpecification/#test-procedure-test-7","title":"Test Procedure - Test 7","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the device using <code>dsFPInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through all supported <code>LED</code> states and get the supported <code>LED</code> states using <code>dsFPGetSupportedLEDStates</code> supportedLEDStates = valid buffer <code>dsERR_NONE</code>, supportedLEDStates = value from configuration file Should be successful 03 For each state, set the <code>LED</code> to that state using <code>dsFPSetLEDState</code> setState = current LedState <code>dsERR_NONE</code> Should be successful 04 Verify the state using <code>dsFPGetLEDState</code> currentState = valid buffer <code>dsERR_NONE</code>, currentState = setState Should be successful 05 After looping through all states, terminate the device using <code>dsFPTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsFPInit] --&gt;|Success|C[Call dsFPGetSupportedLEDStates]\nA --&gt;|Failure|A1[Test case fail]\nC --&gt;|Success|D{Loop through all &lt;br&gt; supported LED states}\nC --&gt;|Failure|C1[Test case fail]\nD --&gt; E[Call dsFPSetLEDState &lt;br&gt; with current ledstate]\nE --&gt;|Success|G[Call dsFPGetLEDState]\nG --&gt;|Success|D\nD -- End of loop--&gt; I[Call dsFPTerm]\nI --&gt;|Success|J[Test case success]\nI --&gt;|Failure|I1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/","title":"Device Settings Front Panel Display L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test Cases High Level Overview</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Device Settings Front Panel Display module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>LED</code> - Light Emitting Diode</li> <li><code>FPD</code> - Front Panel Display</li> <li><code>Y</code>   - yes supported</li> <li><code>NA</code>  - Not Supported</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsFrontPanelDevice High Level TestSpec</li> <li><code>Interface header [4.0.0]</code> - dsFPD HAL header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"# Test-case Description HAL APIs Source Sink 1 Verify LED can be set On and OFF Verify all the supported LED on the DUT can be powered on or off. The User to vaidate the same reflected in DUT. <code>dsSetFPState()</code> <code>Y</code> <code>Y</code> 2 Check Brightness Control Verify the brightness control for all the supported LED on the DUT by changing the brightness Settings. The User to vaidate the same reflected in DUT. <code>dsSetFPBrightness()</code> <code>Y</code> <code>Y</code> 3 Check LED Blink funciton Verify all the supported LED on the DUT can be set with supported Blink rates. The User to vaidate the same reflected in DUT. <code>dsSetFPBlink()</code> <code>Y</code> <code>Y</code> 4 Verify LED Color support Verify all the supported LED on the DUT can be set to supported colors. The User to vaidate the same reflected in DUT. <code>dsSetFPColor()</code> <code>Y</code> <code>Y</code> 5 Verify All the Supported State pattern of LED Verify the Front Panel LED can all the supported states on the DUT. The User to vaidate the same reflected in DUT. <code>dsFPSetLEDState()</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsAudio L3 Python test cases:</p> <pre><code>---\ntitle: dsFPD - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsFPD : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsFPD \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsFPD</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsFPD_Settings</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file dsFPD_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsFPD_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/","title":"dsFPD HAL L3 Python Test Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Test Cases</li> <li>dsFPD_test01_EnableDisableAndVerifyLEDIndicators.py</li> <li>dsFPD_test02_SetVerifyLEDIndicatorsBrightness.py</li> <li>dsFPD_test03_SetVerifyLEDIndicatorsBlink.py</li> <li>dsFPD_test04_SetVerifyLEDIndicatorsColor.py</li> <li>dsFPD_test05_SetVerifyFPPattern.py</li> <li>dsFPD_L3_Runall.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>FPD</code>    - Front Panel Display</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the artifacts required for test cases ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update the target directory where <code>HAL</code> binaries will be copied into the device. Also, map the profile to the source/sink settings <code>YAML</code> file path.</p> <p>Ensure the platform should match with the <code>DUT</code> platform in Rack Configuration</p> <pre><code>deviceConfig:\n  cpe1:\n    platform: \"stb\"    # Must match the platform in example_rack_config.yml\n    model: \"uk\"\n    target_directory: \"/tmp\"  # Path where HAL binaries are copied in device\n    test:\n      profile: \"../../../../profiles/sink/Sink_FPD.yaml\"\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: dsFPD_L3_testSetup.yml</p> <p>Update the artifact paths from which the binaries should be copied to the device.</p> <p>Set the execution paths for each test case.</p> <pre><code>dsFPD:\n  description: \"dsFPD Device Settings test setup\"\n  assets:\n    device:\n      defaults: &amp;defaults\n        execute:\n      test01_EnableDisableAndVerifyLEDIndicators:\n        &lt;&lt;: *defaults\n      test02_SetVerifyLEDIndicatorsBrightness:\n        &lt;&lt;: *defaults\n      test03_SetVerifyLEDIndicatorsBlink:\n        &lt;&lt;: *defaults\n      test04_SetVerifyLEDIndicatorsColor:\n        &lt;&lt;: *defaults\n      test05_SetVerifyFPPattern:\n        &lt;&lt;: *defaults\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-suite-configuration","title":"Test Suite Configuration","text":"<p>Example Test Setup configuration File: dsFPD_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#dsfpd_test01_enabledisableandverifyledindicatorspy","title":"dsFPD_test01_EnableDisableAndVerifyLEDIndicators.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#overview","title":"Overview","text":"<p>This test helps to verify if the Led indicators can be switched ON and OFF using the HAL API's</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>Yes: User interaction is necessary to confirm front panel LED status (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Set supported Front panel LED State to ON and OFF and verify.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test enables the supported front panel LED, and subsequently disabled the LED</p> <p>Success Criteria</p> <ul> <li>User should see the supported LED turned to ON State</li> <li>User should see the supported LED turned to OFF state.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsFPD_test01_EnableDisableAndVerifyLEDIndicators.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>LED state Verification:</p> <p>The test will enable LED and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator state dsFPD_STATE_ON ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator is ON  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is OFF (this will mark the step as FAIL).</p> </li> <li> <p>LED status confirmation (LED indicator Disabled):</p> </li> </ul> <p>After confirming LED state, the test will disable the LED indicator and prompt the user again:</p> <ul> <li>Question: \"Is Indicator state dsFPD_STATE_OFF ? (Y/N)\"</li> <li>Press Y if specified LED indicator is OFF (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is ON  (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All supported LED indicators:</p> </li> </ul> <p>The test will iterate through all supported Indicators, enabling/disabling each one and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all indicators, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#dsfpd_test02_setverifyledindicatorsbrightnesspy","title":"dsFPD_test02_SetVerifyLEDIndicatorsBrightness.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#overview_1","title":"Overview","text":"<p>This test helps to verify if the Led indicators can be set with specified brightness.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#platform-support-test02","title":"Platform Support - test02","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>Yes: User interaction is necessary to confirm front panel LED status and Brightness (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<p>Set supported Front panel LED can be set with different brightness, 0%, 50% and 100%</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test enables the supported front panel LED, sets brightness value to 0, 50 and 100, subsequently disables the LED indicator.</p> <p>Success Criteria</p> <ul> <li>User should see the supported LED turned to ON State</li> <li>User should see the supported LED glowing in 0% brightness</li> <li>User should see the supported LED glowing in 50% brightness</li> <li>User should see the supported LED glowing in 100% brightness</li> <li>User should see the supported LED turned to OFF state.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsFPD_test02_SetVerifyLEDIndicatorsBrightness.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>LED state Verification:</p> <p>The test will enable LED and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator state dsFPD_STATE_ON ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator is ON  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is OFF (this will mark the step as FAIL).</p> </li> <li> <p>LED 0% brightness Verification:</p> <p>The test will set LED brightness to 0% and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator brightness 0% ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator brightness is 0%  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator brightness is not 0% (this will mark the step as FAIL).</p> </li> <li> <p>LED 50% brightness Verification:</p> <p>The test will set LED brightness to 50% and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator brightness 50% ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator brightness is 50%  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator brightness is not 50% (this will mark the step as FAIL).</p> </li> <li> <p>LED 100% brightness Verification:</p> <p>The test will set LED brightness to 100% and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator brightness 100% ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator brightness is 100%  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator brightness is not 100% (this will mark the step as FAIL).</p> </li> <li> <p>LED status confirmation (LED indicator Disabled):</p> </li> </ul> <p>After confirming LED state, the test will disable the LED indicator and prompt the user again:</p> <ul> <li>Question: \"Is Indicator state dsFPD_STATE_OFF ? (Y/N)\"</li> <li>Press Y if specified LED indicator is OFF (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is ON  (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All supported LED indicators:</p> </li> </ul> <p>The test will iterate through all supported Indicators, enabling/disabling and setting brightness to each one and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all indicators, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#dsfpd_test03_setverifyledindicatorsblinkpy","title":"dsFPD_test03_SetVerifyLEDIndicatorsBlink.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#overview_2","title":"Overview","text":"<p>This test helps to verify if the Led indicators can blink with specified parameter.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#platform-support-test03","title":"Platform Support - test03","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>Yes: User interaction is necessary to confirm front panel LED status and blinking (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Set supported Front panel LED with blink duration of 1000 ms and 5 iterations.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#expected-results-test02_1","title":"Expected Results - test02","text":"<p>The test enables the supported front panel LED, sets LED to blink with 1000ms duration and 5 iterations , subsequently disables the LED indicator.</p> <p>Success Criteria</p> <ul> <li>User should see the supported LED turned to ON State</li> <li>User should see the supported LED blinking with 1000ms duration and 5 iterations.</li> <li>User should see the supported LED turned to OFF state.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsFPD_test03_SetVerifyLEDIndicatorsBlink.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>LED state Verification:</p> <p>The test will enable LED and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator state dsFPD_STATE_ON ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator is ON  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is OFF (this will mark the step as FAIL).</p> </li> <li> <p>LED blink Verification:</p> <p>The test will set LED to blink with duration of 1000ms for 5 times and prompt the user with the following:</p> </li> <li> <p>Question: \"Is indicator blinking 5 times with 1 sec ? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator blink with the duration specified. (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator did not blink with duration specified. (this will mark the step as FAIL).</p> </li> <li> <p>LED status confirmation (LED indicator Disabled):</p> </li> </ul> <p>After confirming LED state, the test will disable the LED indicator and prompt the user again:</p> <ul> <li>Question: \"Is Indicator state dsFPD_STATE_OFF ? (Y/N)\"</li> <li>Press Y if specified LED indicator is OFF (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is ON  (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All supported LED indicators:</p> </li> </ul> <p>The test will iterate through all supported Indicators, enabling/disabling and setting blink parameter to each one and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all indicators, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#dsfpd_test04_setverifyledindicatorscolorpy","title":"dsFPD_test04_SetVerifyLEDIndicatorsColor.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#overview_3","title":"Overview","text":"<p>This test helps to verify if the Led indicators can set with supported colors.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#platform-support-test04","title":"Platform Support - test04","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>Yes: User interaction is necessary to confirm front panel LED status and blinking (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>Set supported Front panel LED set with supported colors.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>The test enables the supported front panel LED, sets LED to its supported colors , subsequently disables the LED indicator.</p> <p>Success Criteria</p> <ul> <li>User should see the supported LED turned to ON State</li> <li>User should see the supported LED set with supported color</li> <li>User should see the supported LED turned to OFF state.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsFPD_test04_SetVerifyLEDIndicatorsColor.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>LED state Verification:</p> <p>The test will enable LED and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Indicator state dsFPD_STATE_ON ? (Y/N):? (Y/N)\"</p> </li> <li>Press Y if specified LED indicator is ON  (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is OFF (this will mark the step as FAIL).</p> </li> <li> <p>LED color Verification:</p> <p>The test will set LED to supported color and prompt the user with the following:</p> </li> <li> <p>Question: \"Is indicator color ? (Y/N)\" <li>Press Y if specified LED indicator set with specified color. (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is not set with specified color. (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All supported color for the LED indicators:</p> </li> <p>The test will iterate through all supported colors of the indicator and collecting user feedback accordingly.</p> <ul> <li>LED status confirmation (LED indicator Disabled):</li> </ul> <p>After confirming LED state, the test will disable the LED indicator and prompt the user again:</p> <ul> <li>Question: \"Is Indicator state dsFPD_STATE_OFF ? (Y/N)\"</li> <li>Press Y if specified LED indicator is OFF (this will mark the step as PASS).</li> <li> <p>Press N if specified LED indicator is ON  (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All supported LED indicators:</p> </li> </ul> <p>The test will iterate through all supported Indicators and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all indicators, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#dsfpd_test05_setverifyfppatternpy","title":"dsFPD_test05_SetVerifyFPPattern.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#overview_4","title":"Overview","text":"<p>This test helps to verify if the front panel can set with different patterns.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#platform-support-test05","title":"Platform Support - test05","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#user-input-required-test05","title":"User Input Required - test05","text":"<p>Yes: User interaction is necessary to confirm front panel Patterns is set (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<p>Set supported Front panel pattern</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#expected-results-test05","title":"Expected Results - test05","text":"<p>The test sets all the supported Front panel patterns and verifies.</p> <p>Success Criteria</p> <ul> <li>User should see all the supported front panel patterns one buy one.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsFPD_test05_SetVerifyFPPattern.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Front panel pattern verification:</p> <p>The test will set the pattern and prompt the user with the following:</p> </li> <li> <p>Question: \"Is Front panel shows  ? (Y/N):? (Y/N)\" <li>Press Y if specified pattern is shown  (this will mark the step as PASS).</li> <li> <p>Press N if specified pattern is not shown (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All supported patterns:</p> </li> <p>The test will iterate through all supported patterns of the device collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all indicators, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsFPD/ds-front-panel-display_L3_TestProcedure/#dsfpd_l3_runallpy","title":"dsFPD_L3_Runall.py","text":"<p>This python file runs all the tests supported</p> <pre><code>python dsFPD_L3_Runall.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/","title":"Device Settings HdmiIn L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test Cases High Level Overview</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Device Settings HdmiIn module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HDMI</code>- High-Definition Multimedia Interface</li> <li><code>HDR</code> - High Dynamic Range</li> <li><code>HLG</code> - Hybrid Log-Gamma</li> <li><code>SDR</code> - Standard Dynamic Range</li> <li><code>EDID</code>- Extended Display Identification Data</li> <li><code>ALLM</code>- Auto Low Latency Mode</li> <li><code>AVI</code> - Audio Video Interleave</li> <li><code>SPD</code> - Source Product Descriptor</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsHdmiIn High Level TestSpec</li> <li><code>Interface header</code> - dsHdmiIn HAL header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"# Streams Name Streams description 1 vts_HDR10_stream Format: HDR10,Resolution: 3840 x 2160 (4K UHD),Color Depth: 10-bit,Color Space: Rec. 2020 2 vts_SDR_stream Format: SDR,Resolution: 1920 x 1080 3 vts_HLG_stream Format: HLG,Resolution: 3840 x 2160 or It can also be used with 1080p and 720p resolutions. 4 vts_DolbyVision_stream Format: Dolby Vision,Resolution: 3840 x 2160 (4K UHD),Color Depth: 10/12-bit,Color Space: Rec. 2020format and dynamic metadata. 5 vts_HDR10plus_stream Format: HDR10,Resolution: 3840 x 2160 (4K UHD),Color Depth: 10-bit,Color Space: Rec. 2020 and dynamic metadata capabilities. <p>Each test case need to verify with the each HdmiIn port. Below are top test use-case for the HdmiIn port.</p> # Test-case Description Focus APIs Source Sink 1 Verify the HdmiIn Connect status with callback Connect or Disconnect HdmiInput device on each of the HdmiInput ports and check the hdmiInConnectCB callback is triggered <code>dsHdmiInRegisterConnectCB()</code> <code>Y</code> <code>Y</code> 2 Verify the HdmiIn Signal change with callback Select the HdmiInput port and check the callback is triggered when the change in signal status occurs(i.e like no signal , unstable signal, stable signal <code>dsHdmiInRegisterSignalChangeCB()</code> <code>NA</code> <code>Y</code> 3 Verify the HdmiIn Status change with callback Select the HdmiInput port and check the callback is triggered when the status change occurs(i.e like isPresented, activeport) and  check the callbacks is triggered <code>dsHdmiInRegisterStatusChangeCB()</code> <code>NA</code> <code>Y</code> 4 Verify the HdmiIn Video Mode update  with callback Select the Hdminput device with different resolutions , aspect ratio  and check the callbacks is triggered and outputs the same resolution , aspect ratio <code>dsHdmiInRegisterVideoModeUpdateCB()</code> <code>NA</code> <code>Y</code> 5 Verify the HdmiIn <code>ALLM</code> change  with callback Change the <code>ALLM</code> option to TRUE/FALSE after connecting game controller on 4k supported panel and check the callbacks is triggered when the <code>ALLM</code> status change occurs <code>dsHdmiInRegisterAllmChangeCB()</code> <code>NA</code> <code>Y</code> 6 Verify the  HdmiIn Audio Video lateny with callback Select the Hdminput device with available resolutions (like <code>HDR</code>,<code>HLG</code>,<code>DolbyVision</code>,<code>SDR</code>,...) and check the callbacks is triggered when there is latency change <code>dsHdmiInRegisterAVLatencyChangeCB()</code> <code>NA</code> <code>Y</code> 7 Verify the HdmiIn <code>AVI</code> content change with callbacks Play the streams from Hdminput device with differenct formats(like <code>GRAPHICS</code>,<code>PHOTO</code>,<code>CINEMA</code>,<code>GAME</code>,...) and check the callbacks is triggered when there is <code>AVI</code> content change <code>dsHdmiInRegisterAviContentTypeChangeCB()</code> <code>NA</code> <code>Y</code> 8 Get HdmiIn status of the selected port Select the HdmiInput and verify the status whether selected port active or not <code>dsHdmiInSelectPort()</code>,<code>dsHdmiInGetStatus()</code> <code>Y</code> <code>Y</code> 9 Scale HdmiIn video of the selected port Select the HdmiInput and scale the video on the selcted port verify video scaled or not <code>dsHdmiInScaleVideo()</code> <code>Y</code> <code>Y</code> 10 Check and verify Zoom mode selected Select the Zoom mode from the available inputs and verify its set or not <code>dsHdmiInSelectZoomMode()</code> <code>Y</code> <code>NA</code> 11 Get and verify the <code>EDID</code> of selected port Select the HdmiInput and get the <code>EDID</code> for that particular Input port <code>dsGetEDIDBytesInfo()</code> <code>NA</code> <code>Y</code> 12 Get and verify the <code>SPD</code> info of selected port Select the HdmiInput and get the <code>SPD</code> info for that particular Input port <code>dsGetHDMISPDInfo()</code> <code>NA</code> <code>Y</code> 13 Set and verify the <code>EDID</code> version on selected port Set the <code>EDID</code> version and verify by retrieving the <code>EDID</code> version <code>dsSetEdidVersion()</code>,<code>dsGetEdidVersion()</code> <code>NA</code> <code>Y</code> 14 Set and verify <code>EDID</code> to <code>ALLM</code> support on selected port Set and retrieve <code>ALLM</code> on selected port connected with game controller on 4k supported panel <code>dsSetEdid2AllmSupport()</code>,<code>dsGetEdid2AllmSupport()</code> <code>NA</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsHdmiIn L3 Python test cases:</p> <pre><code>---\ntitle: dsHdmiIn - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- dsHdmiInHelperClass : inherits\n    dsHdmiInHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsHdmiIn : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsHdmiIn \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testConfig.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsHdmiIn</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-Hdmi-In_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsHdmiIn_Settings</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams etc.</li> <li> <p>Example configuration file dsHdmiIn_L3_testSetup.yml</p> </li> <li> <p>testSuite.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsHdmiIn_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/","title":"HdmiIn High Level Test Specification Document","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>EDID</code>     - Extended Display Identification Data</li> <li><code>API</code>      - Application programming interface</li> <li><code>HDMI</code>     - High-Definition Multimedia Interface</li> <li><code>dsHdmiIn</code> - Device Settings High-Definition Multimedia Interface Input</li> <li><code>SPD</code>      - Source Product Descriptor</li> <li><code>ALLM</code>     - Auto Low Latency Mode</li> <li><code>AVI</code>      - Audio Video Interleave</li> <li><code>Y</code>        - Yes</li> <li><code>N</code>        - No</li> <li><code>NA</code>       - Not Applicable</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the high level testing requirements for the <code>dsHdmiIn</code> module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, emulator requirements, control plane requirements and expected deliverables.</p> <ul> <li>Interface of the test is available in this link -  Interface header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#module-description","title":"Module Description","text":"<p>High level overview:</p> <ul> <li><code>dsHdmiIn</code> provides a variety of <code>API</code>s for accessing information regarding the <code>HDMI</code> Inputs on sink devices and source devices that has an input port.</li> <li>It facilitates interaction with <code>HDMI</code> Input ports, aiding in their configuration and utilization within the system. This information is then passed to the caller.</li> <li> <p>For the sink and source devices, to retrieve the available <code>HDMI</code> Input information, an external device must be connected.</p> </li> <li> <p><code>HAL</code> specification : ds-hdmiIn HAL Spec</p> </li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Test Description 1 Get Number of Inputs The test aims to verify and validate the number of HDMI Input ports available on the platform. 2 Set and Get the <code>HDMI</code> Input port Status The test is to verify by selecting the HDMI input and getting the status of HDMI Input ports available on the platform. 3 Scale the <code>HDMI</code> Input Video The test aims to verify and validate the video size and coordinates of the HMDI Input Video. 4 Select Zoom Mode The test aims to verify the zoom mode functionality of the module. 5 Get Current Video Mode The test is to get current HDMI input video mode from active port. 6 Callback for connection Status The test aims to verify whether it notifies applications when the HDMI input port connection status changes 7 Callback for Signal Change The test aims to verify the callback function used to inform applications about changes in the signal status of the <code>HDMI</code> In.(NoSignal/UnstableSignal/NotSupportedSignal/StableSignal) 8 Callback for Status Change The test validates the functionality of the callback function designed to notify applications of <code>HDMI</code> Input status change events.(Port,IsPresented flag status) 9 Callback for Video Mode Change The test validates the functionality of the callback function designed to notify when there is a change in the video resolution 10 Callback for <code>ALLM</code> Mode Change The test validates the functionality of the callback function designed to notify when <code>HDMI</code> input <code>ALLM</code> mode changes 11 Callback for AV Latency Change The test validates the functionality of the callback function designed to notify when <code>HDMI</code> input AV latency changes 12 Callback for <code>AVI</code> Content Type Change The test validates the functionality of the callback function designed to notify when <code>HDMI</code> input AVI content type changes 13 Check <code>HDMI</code> ARC Port The test verifies whether the given port is an <code>HDMI</code> ARC port or not 14 Set and Get <code>EDID</code> Information The test is to validate by setting and getting the <code>EDID</code> bytes information and <code>EDID</code> version 15 Get <code>HDMI</code> <code>SPD</code> Info The test is to get and verify the <code>SPD</code> information. 16 Get Supported Game Feature List The test verifies by getting the all supported game features in the list. 17 Get AV latency The test validates by getting the current av latency. 18 Get <code>ALLM</code> status The test aims to verify that <code>ALLM</code> status is enabled or disabled for the specific <code>HDMI</code> input port. 19 Get and Set <code>EDID</code> to all <code>ALLM</code> Support The test aims to verfiy by setting and getting the <code>EDID</code> <code>ALLM</code> support. 20 Get <code>HDMI</code> version The test is to validate getting the <code>HDMI</code> compatibility version -----------"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-number-of-inputs","title":"Get Number of Inputs","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get Number of Inputs Verify that the function returns the expected <code>HDMI</code> Input ports. Compare the input port values by parsing the configuration YAML file for sink is <code>Sink_HDMIIN.yaml (HDMIIN/HdmiInputPort/numberOfPorts)</code> and source is <code>Source_HDMIIN.yaml(HDMIIN/HdmiInputPort/numberOfPorts)</code> dsHdmiInGetNumberOfInputs() <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-number-of-inputs","title":"Test Startup Requirement - Get Number of Inputs","text":"<p>The test begins with the configured <code>HDMI</code> input port details.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-number-of-inputs","title":"Emulator Requirement - Get Number of Inputs","text":"<p>Emulator will boot with the port information's coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-number-of-inputs","title":"Control Plane Requirement - Get Number of Inputs","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#set-and-get-the-hdmi-input-port-status","title":"Set and Get the <code>HDMI</code> Input port Status","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Set and Get the <code>HDMI</code> Input port Status Loop through supported <code>HDMI</code> Input port, verify that the function successfully sets the specified <code>HDMI</code> Input port without any external device connection and \"Get status\" to check the active port is false, port connected is false and presentation is false. Note:supported <code>HDMI</code> Input port, Check profile file for sink is <code>Sink_HDMIIN.yaml (HDMIIN/HdmiInputPort/numberOfPorts)</code> and source is <code>Source_HDMIIN.yaml(HDMIIN/HdmiInputPort/numberOfPorts)</code> dsHdmiInGetNumberOfInputs(), dsHdmiInSelectPort(), dsHdmiInGetStatus() <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through all <code>HDMI</code> Input port, verify that the function successfully sets the specified <code>HDMI</code> Input port as active for presentation and check the port information is valid using \"Get status\".Note:supported <code>HDMI</code> Input port, Check profile file for sink is <code>Sink_HDMIIN.yaml (HDMIIN/HdmiInputPort/numberOfPorts)</code> and source is <code>Source_HDMIIN.yaml(HDMIIN/HdmiInputPort/numberOfPorts)</code> dsHdmiInGetNumberOfInput(), dsHdmiInSelectPort(), dsHdmiInGetStatus() <code>N</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> On the active HDMI port, set the Audio Mix to be enable and disable dsHdmiInSelectPort() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code> On the active HDMI port, verify the <code>HDMI</code> input with the video plane in both primary and secondary. Additionally, validate the topmost flag. dsHdmiInSelectPort() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-set-and-get-the-hdmi-input-port-status","title":"Test Startup Requirement - Set and Get the <code>HDMI</code> Input port Status","text":"<ul> <li>The test begins with the configured <code>HDMI</code> input port numbers.</li> <li>Connection of the source device with the <code>HDMI</code> Input.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-set-and-get-the-hdmi-input-port-status","title":"Emulator Requirement - Set and Get the <code>HDMI</code> Input port Status","text":"<p>Emulator will boot with the port information's coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-set-and-get-the-hdmi-input-port-status","title":"Control Plane Requirement - Set and Get the <code>HDMI</code> Input port Status","text":"<ul> <li>Connecting and disconnecting source devices in the <code>HDMI</code> Input will be handled by the Control Plane. </li> <li>Validate the Audio mix and Video plane by the analyzers.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#scale-the-hdmi-input-video","title":"Scale the <code>HDMI</code> Input Video","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Scale the <code>HDMI</code> Input Video Verify that the function successfully scales the <code>HDMI</code> input video when valid coordinates and dimensions are provided within the resolution limits. Based on video resolution need to check whether the coordinates are in range dsHdmiInScaleVideo() <code>N</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-scale-the-hdmi-input-video","title":"Test Startup Requirement - Scale the <code>HDMI</code> Input Video","text":"<p>The test begins by setting up the video analyzer, and the video should be played.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-scale-the-hdmi-input-video","title":"Emulator Requirement - Scale the <code>HDMI</code> Input Video","text":"<p>Emulator will boot with the port information's coming from the configuration file. Predefined coordinates and dimesions to compare.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-scale-the-hdmi-input-video","title":"Control Plane Requirement - Scale the <code>HDMI</code> Input Video","text":"<p>Control plane to validate the coordinates and dimensions by the video analyzers.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#select-zoom-mode","title":"Select Zoom Mode","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Select Zoom Mode Verify that the function successfully updates the video zoom on the active <code>HDMI</code> input using the provided zoom mode dsHdmiInSelectZoomMode() <code>N</code> <code>Y</code> <code>Y</code> <code>N</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-select-zoom-mode","title":"Test Startup Requirement - Select Zoom Mode","text":"<p>The test begins by setting up the video analyzer, and the video should be played.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-select-zoom-mode","title":"Emulator Requirement - Select Zoom Mode","text":"<p>Emulator will boot with the zoom modes in the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-select-zoom-mode","title":"Control Plane Requirement - Select Zoom Mode","text":"<p>Changing the zoom modes by the Control Plane. Validates the zoom mode by analyzers.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-current-video-mode","title":"Get Current Video Mode","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get Current Video Mode Verify that the function successfully updates the current <code>HDMI</code> input video modes like Pixel resolution, frame rate and interlaced information of the active port dsHdmiInGetCurrentVideoMode() <code>N</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-current-video-mode","title":"Test Startup Requirement - Get Current Video Mode","text":"<p>The test begins by setting up the video analyzer, and the video should be played.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-current-video-mode","title":"Emulator Requirement - Get Current Video Mode","text":"<p>Emulator will boot with the all video mode related information in the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-current-video-mode","title":"Control Plane Requirement - Get Current Video Mode","text":"<p>Control plane validates the current mode by the analyzers.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-connection-status","title":"Callback for connection Status","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for connection Status Verify that the callback function properly updates the connection/disconnection status flag and notifies the application when a <code>HDMI</code> Input port is connected or disconnected. dsHdmiInRegisterConnectCB() <code>N</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Callback for connection Status Verify that the callback function properly updates the isPresented status, if the connected port is active and presents video after being connected. dsHdmiInRegisterConnectCB() <code>N</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-connection-status","title":"Test Startup Requirement - Callback for connection Status","text":"<p>Connection of the source device with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-connection-status","title":"Emulator Requirement - Callback for connection Status","text":"<p>Emulator will boot with the port information coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-connection-status","title":"Control Plane Requirement - Callback for connection Status","text":"<p>Connecting and disconnecting source devices in the <code>HDMI</code> Input will be handled by the Control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-signal-change","title":"Callback for Signal Change","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for Signal Change Verify that the callback function properly notifies the application whenever there is a change in the signal statuses (e.g., NoSignal, UnstableSignal, NotSupportedSignal, StableSignal) for the <code>HDMI</code> Input port. dsHdmiInRegisterSignalChangeCB() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-signal-change","title":"Test Startup Requirement - Callback for Signal Change","text":"<p>Connection of the source device with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-signal-change","title":"Emulator Requirement - Callback for Signal Change","text":"<p>Emulator will boot with the port information's coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-signal-change","title":"Control Plane Requirement - Callback for Signal Change","text":"<ul> <li>Connecting and disconnecting source devices in the <code>HDMI</code> Input will be handled by the Control Plane.</li> <li>Provide resolution changes or configurations changes on the connected device that affects the output signal.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-status-change","title":"Callback for Status Change","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for Status Change Verify that the callback function properly triggers whenever the dsHdmiInStatus_t is updated and notifies the application of the <code>HDMI</code> Input status change event. dsHdmiInRegisterStatusChangeCB() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-status-change","title":"Test Startup Requirement - Callback for Status Change","text":"<p>Connection of the source device with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-status-change","title":"Emulator Requirement - Callback for Status Change","text":"<p>Emulator will boot with the port information's coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-status-change","title":"Control Plane Requirement - Callback for Status Change","text":"<p>Connecting and disconnecting source devices in the <code>HDMI</code> Input will be handled by the Control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-video-mode-change","title":"Callback for Video Mode Change","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for Video Mode Change Verify that the callback function properly notifies the application whenever there is resolution and other video mode changes. dsHdmiInRegisterVideoModeUpdateCB() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-video-mode-change","title":"Test Startup Requirement - Callback for Video Mode Change","text":"<p>Connection of the source device with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-video-mode-change","title":"Emulator Requirement - Callback for Video Mode Change","text":"<p>Emulator will boot with the video resolutions and other video modes from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-video-mode-change","title":"Control Plane Requirement - Callback for Video Mode Change","text":"<p>Changing of the video resolution by control Plane. </p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-allm-mode-change","title":"Callback for <code>ALLM</code> mode change","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for <code>ALLM</code> mode change Verify that the callback function properly notifies the application whenever there is <code>ALLM</code> mode change. dsHdmiInRegisterAllmChangeCB() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-allm-mode-change","title":"Test Startup Requirement - Callback for <code>ALLM</code> mode change","text":"<p>Connection of the source device/compatible gaming console devices with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-allm-mode-change","title":"Emulator Requirement - Callback for <code>ALLM</code> mode change","text":"<p>Emulator will boot with the <code>HDMI</code> input port numbers and <code>ALLM</code> mode information.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-allm-mode-change","title":"Control Plane Requirement - Callback for <code>ALLM</code> mode change","text":"<p>Changing of the <code>ALLM</code> mode by control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-av-latency-change","title":"Callback for AV Latency Change","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for AV Latency Change Verify that the callback function notifies the application whenever there is a change in the <code>HDMI</code> input Audio and Video latency within its Max(500ms) and Min(0) ranges. dsHdmiInRegisterAVLatencyChangeCB() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-av-latency-change","title":"Test Startup Requirement - Callback for AV Latency Change","text":"<ul> <li>Connection of the source device with the <code>HDMI</code> Input. </li> <li>Test starts with the video playback with different modes ( Film Maker, Cinema mode )</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-av-latency-change","title":"Emulator Requirement - Callback for AV Latency Change","text":"<p>Emulator will boot with the AV latency information.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-av-latency-change","title":"Control Plane Requirement - Callback for AV Latency Change","text":"<p>Control plane signals the source device to play the content ( Cinema mode to Film Maker mode ).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#callback-for-avi-content-type-change","title":"Callback for <code>AVI</code> Content Type Change","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Callback for <code>AVI</code> Content Type Change Verify that the callback function properly notifies the application whenever there is a change in the <code>AVI</code> content type. dsHdmiInRegisterAviContentTypeChangeCB() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-callback-for-avi-content-type-change","title":"Test Startup Requirement - Callback for <code>AVI</code> Content Type Change","text":"<ul> <li>Connection of the source device with the <code>HDMI</code> Input.</li> <li>Test starts with the video playback.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-callback-for-avi-content-type-change","title":"Emulator Requirement - Callback for <code>AVI</code> Content Type Change","text":"<p>Emulator will boot with the <code>AVI</code> content type information.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-callback-for-avi-content-type-change","title":"Control Plane Requirement - Callback for <code>AVI</code> Content Type Change","text":"<p>Changing <code>AVI</code> content type by control Plane..</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#check-hdmi-arc-port","title":"Check <code>HDMI</code> ARC Port","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Check <code>HDMI</code> ARC Port Loop through supported <code>HDMI</code> Input port and verify whether the given port is an HDMI ARC port by comparing it with the <code>Sink_HDMIIN.yaml (HDMIIN/HdmiArcPort/portNumber)</code> configuration file.Note:supported <code>HDMI</code> Input port, Check profile file for sink is <code>Sink_HDMIIN.yaml (HDMIIN/HdmiInputPort/numberOfPorts)</code> dsIsHdmiARCPort() <code>Y</code> <code>N</code> <code>N</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-check-hdmi-arc-port","title":"Test Startup Requirement - Check <code>HDMI</code> ARC Port","text":"<p>Test starts with the number of ports and ARC port from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-check-hdmi-arc-port","title":"Emulator Requirement - Check <code>HDMI</code> ARC Port","text":"<p>Emulator will boot with the <code>HDMI</code> ARC port information.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-check-hdmi-arc-port","title":"Control Plane Requirement - Check <code>HDMI</code> ARC Port","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#set-and-get-edid-information","title":"Set and Get <code>EDID</code> Information","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Set and Get <code>EDID</code> Information Setting the <code>EDID</code> version for a given port and getting back the <code>EDID</code> version and compare with the Set value. Also, validate the EDID length for a given port. Compare the EDID length values by parsing the configuration YAML file <code>Sink_EDID_Info.yaml (HDMIIN/EDID_Data/edidBytesLength)</code> dsSetEdidVersion(), dsGetEdidVersion(), dsGetEDIDBytesInfo() <code>Y</code> <code>N</code> <code>N</code> <code>Y</code> <code>NA</code> This test ensures that the module can accurately retrieve and interpret <code>EDID</code> information, providing essential data about the display's capabilities and characteristics. dsGetEdidVersion(), dsGetEDIDBytesInfo() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-set-and-get-edid-information","title":"Test Startup Requirement - Set and Get <code>EDID</code> Information","text":"<ul> <li>Connection of the source device with the <code>HDMI</code> Input and video analyzer to check the display capabilities.</li> <li>Test starts with the predefined EDID length information coming from the configuration file.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-set-and-get-edid-information","title":"Emulator Requirement - Set and Get <code>EDID</code> Information","text":"<p>Emulator will boot with the <code>EDID</code> coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-set-and-get-edid-information","title":"Control Plane Requirement - Set and Get <code>EDID</code> Information","text":"<p>Connecting and disconnecting source devices in the <code>HDMI</code> Input will be handled by the Control Plane.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-hdmi-spd-info","title":"Get <code>HDMI</code> <code>SPD</code> Info","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get <code>HDMI</code> <code>SPD</code> Info Test to get the <code>HDMI</code> <code>SPD</code> Info. Check whether it gets the spd info frame information properly. dsGetHDMISPDInfo() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-hdmi-spd-info","title":"Test Startup Requirement - Get <code>HDMI</code> <code>SPD</code> Info","text":"<p>Connection of the source device with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-hdmi-spd-info","title":"Emulator Requirement - Get <code>HDMI</code> <code>SPD</code> Info","text":"<p>Emulator will boot with the <code>HDMI</code> SPD information from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-hdmi-spd-info","title":"Control Plane Requirement - Get <code>HDMI</code> <code>SPD</code> Info","text":"<p>Connecting and disconnecting source devices in the <code>HDMI</code> Input will be handled by the Control Plane. Check the SPD info frame - Vendor name by the Analyzers.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-supported-game-feature-list","title":"Get Supported Game Feature List","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get Supported Game Feature List Make sure that the functionality can list and get the count of all the game features that are supported. Compare the result by parsing the configuration YAML file <code>Sink_HDMIIN.yaml(HDMIIN/gameFeatures/count)</code> dsGetSupportedGameFeaturesList() <code>Y</code> <code>N</code> <code>N</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-supported-game-feature-list","title":"Test Startup Requirement - Get Supported Game Feature List","text":"<p>Connection of the source device/game supported device with the <code>HDMI</code> Input. Test boots with the game feature list and count in the configuration file to compare the results.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-supported-game-feature-list","title":"Emulator Requirement - Get Supported Game Feature List","text":"<p>Emulator will boot with the game supported features in the configuration.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-supported-game-feature-list","title":"Control Plane Requirement - Get Supported Game Feature List","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-av-latency","title":"Get AV latency","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get AV latency The test gets the current AV latency connected to the source device. Also, It checks the AV latency after changing the AV content, such as switching from FilmMaker mode to any other mode. dsGetAVLatency <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-av-latency","title":"Test Startup Requirement - Get AV latency","text":"<ul> <li>Connection of the source device with the <code>HDMI</code> Input.</li> <li>Test starts up with the video playback content of different modes ( Film Maker mode, Cinema mode )</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-av-latency","title":"Emulator Requirement - Get AV latency","text":"<p>Emulator will boot with the av latency information in configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-av-latency","title":"Control Plane Requirement - Get AV latency","text":"<ul> <li>Control plane handles the switch between the modes ( Film Maker modes and Cinema modes ). </li> <li>Control Plane to test the content with post processing and without post processing.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-allm-status","title":"Get <code>ALLM</code> Status","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get <code>ALLM</code> Status Gets the <code>ALLM</code> status of the designated <code>HDMI</code> input port. The status information indicates whether <code>ALLM</code> is enabled or disabled dsGetAllmStatus() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-allm-status","title":"Test Startup Requirement - Get <code>ALLM</code> status","text":"<p>Connection of the Game console source devce with the <code>HDMI</code> Input with game playback. </p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-allm-status","title":"Emulator Requirement - Get <code>ALLM</code> status","text":"<p>Emulator will boot with the <code>ALLM</code> configuration details.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-allm-status","title":"Control Plane Requirement - Get <code>ALLM</code> status","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-and-set-edid-to-all-allm-support","title":"Get and Set <code>EDID</code> to all <code>ALLM</code> Support","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get and Set <code>EDID</code> to all <code>ALLM</code> Support Set and Get the <code>ALLM</code> support to <code>EDID</code> version 2.0 without connecting any source devices. dsSetEdid2AllmSupport(), dsGetEdid2AllmSupport() <code>Y</code> <code>N</code> <code>N</code> <code>Y</code> <code>NA</code> Set and Get <code>ALLM</code> support to <code>EDID</code> Version 2.0 with the connected external source device dsSetEdid2AllmSupport(), dsGetEdid2AllmSupport() <code>N</code> <code>Y</code> <code>N</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-and-set-edid-to-all-allm-support","title":"Test Startup Requirement - Get and Set <code>EDID</code> to all <code>ALLM</code> Support","text":"<p>Connection of the Game console source device with the <code>HDMI</code> Input.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-and-set-edid-to-all-allm-support","title":"Emulator Requirement - Get and Set <code>EDID</code> to all <code>ALLM</code> Support","text":"<p>Emulator will boot with the <code>ALLM</code> support information.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-and-set-edid-to-all-allm-support","title":"Control Plane Requirement - Get and Set <code>EDID</code> to all <code>ALLM</code> Support","text":"<p>Control plane connects/ disconnects the external devices. Validates the ALLM by analyzers.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#get-hdmi-version","title":"Get <code>HDMI</code> Version","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Get <code>HDMI</code> Version Get <code>HDMI</code> Version and Validate with the version from profile file dsGetHdmiVersion() <code>Y</code> <code>N</code> <code>N</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#test-startup-requirement-get-hdmi-version","title":"Test Startup Requirement - Get <code>HDMI</code> Version","text":"<ul> <li>The test begins with the configured <code>HDMI</code> input port numbers.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#emulator-requirement-get-hdmi-version","title":"Emulator Requirement - Get <code>HDMI</code> Version","text":"<p>Emulator will boot with the <code>EDID</code> coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-High-Level_TestSpec/#control-plane-requirement-get-hdmi-version","title":"Control Plane Requirement - Get <code>HDMI</code> Version","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/","title":"Device Settings HDMI Input L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the Low Level L2 Test Specification and Procedure Documentation for the Device Settings HDMI Input module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - ds-hdmi-in-High-Level_TestSpec.md</li> <li><code>HAL Interface file</code> - dsHdmiIn.h</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsHdmiIn_GetNumberOfInputs</code> Description Verify that the function returns the expected <code>HDMI</code> Input ports. Compare the input port values by parsing the configuration YAML file <code>dsHdmiIn/numberOfPorts</code> Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize <code>HDMI</code> input using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the number of <code>HDMI</code> input ports using <code>dsHdmiInGetNumberOfInputs</code> pNumberOfinputs = valid buffer <code>dsERR_NONE</code> Should be successful 03 Compare the number of <code>HDMI</code> input ports with the value in the configuration file pNumberOfinputs = <code>dsHdmiIn/numberOfPorts</code> <code>dsERR_NONE</code> Should be successful 04 Terminate <code>HDMI</code> input using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHdmiInInit API] --&gt;|dsERR_NONE| B[Parse Configuration file]\nA --&gt;|Failure| A1[Test case fail]\nB --&gt;|Success| C[Call dsHdmiInGetNumberOfInputs API]\nB --&gt;|Failure| B1[Test case fail]\nC --&gt;|Success| D[Compare pNumberOfinputs with YAML value]\nC --&gt;|Failure| C1[Test case fail]\nD --&gt;|Match| E[Call dsHdmiInTerm API]\nD --&gt;|Mismatch| D1[Test case fail]\nE --&gt;|Failure| E1[Test case fail]\nE --&gt;|dsERR_NONE| F[Test case success]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsHdmiIn_GetStatus</code> Description Verify the HDMI port with the 'Get status' function when it is disabled, without selecting any port, and without any external devices. Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize <code>HDMI</code> input using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the status of <code>HDMI</code> input using <code>dsHdmiInGetStatus</code> status = valid buffer <code>dsERR_NONE</code> Should be successful 03 Check if <code>HDMI</code> input is presented isPresented = false false Should be successful 04 Check if any <code>HDMI</code> input port is active activePort = <code>dsHDMI_IN_PORT_NONE</code> <code>dsHDMI_IN_PORT_NONE</code> Should be successful 05 Check if any <code>HDMI</code> input port is connected isPortConnected[i] = false for all i in range 0 to <code>dsHDMI_IN_PORT_MAX</code> false Should be successful 06 Terminate <code>HDMI</code> input using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHdmiInInit] --&gt;|dsERR_NONE| B[Call dsHdmiInGetStatus]\nA --&gt;|Failure| A1[Test case fail]\nB --&gt;|dsERR_NONE| C[Check pStatus]\nB --&gt;|Failure| B1[Test case fail]\nC --&gt;|isPresented=false, isPortConnected=false, &lt;br&gt; activePort=dsHDMI_IN_PORT_NONE| D[Call dsHdmiInTerm]\nC --&gt;|Failure| C1[Test case fail]\nD --&gt;|dsERR_NONE| E[Test case success]\nD --&gt;|Failure| D1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsHdmiIn_VerifyHdmiInputPortStatus</code> Description Loop through all <code>HDMI</code> Input port, verify that the function successfully sets the specified <code>HDMI</code> Input port without any external device connection and 'Get status' to check the active port is false, port connected is false and presentation is false. Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize HDMI input using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the number of <code>HDMI</code> inputs using <code>dsHdmiInGetNumberOfInputs</code> numInputs = valid buffer <code>dsERR_NONE</code>, numInputs &gt; 0 Should be successful 03 Loop through supported <code>HDMI</code> input ports and select each port using <code>dsHdmiInSelectPort</code> port = <code>dsHDMI_IN_PORT_0</code> to numInputs-1, audioMix = false, evideoPlaneType = dsVideoPlane_PRIMARY, topMost = false <code>dsERR_NONE</code> Should be successful 04 Get the status of the selected HDMI input port using <code>dsHdmiInGetStatus</code> status = valid buffer <code>dsERR_NONE</code>, activePort = port, isPresented = false, isPortConnected[port] = false Should be successful 05 Terminate HDMI input using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHdmiInInit API] --&gt;|dsERR_NONE| B[Call dsHdmiInGetNumberOfInputs API]\nA --&gt;|Not dsERR_NONE| A1[Test case fail]\nB --&gt;|dsERR_NONE and&lt;br&gt; non-zero inputs| C{Loop through supported &lt;br&gt; HDMI input ports}\nB --&gt;|Not dsERR_NONE or &lt;br&gt;zero inputs| B1[Test case fail]\nC --&gt; D[Call dsHdmiInSelectPort API with current port]\nD --&gt;|dsERR_NONE| E[Call dsHdmiInGetStatus API]\nE --&gt;|!dsERR_NONE| E1[Test case fail]\nE1 --&gt; F\nE --&gt;|dsERR_NONE, activePort is current port, &lt;br&gt; isPresented is false, isPortConnected is false| F[Next port in loop]\nF --&gt; C\nC --&gt;|End of loop| G[Call dsHdmiInTerm API]\nG --&gt;|dsERR_NONE| H[Test case pass]\nG --&gt;|Not dsERR_NONE| G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-4","title":"Test 4","text":"Title Details Function Name <code>test_l2_dsHdmiIn_VerifyHdmiArcPort_sink</code> Description Loop through supported ports and verify whether the given port is an HDMI ARC port by comparing it with the <code>dsHdmiIn/HdmiArcPort/numberOfPorts</code> configuration file. Test Group 02 Test Case ID 004 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-4","title":"Test Procedure - Test 4","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize HDMI input using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through supported HDMI input ports iPort = <code>dsHDMI_IN_PORT_0</code> to number of Hdmi Input ports supported <code>dsERR_NONE</code> Should be successful 03 For each port, check if it is an <code>HDMI</code> ARC port using <code>dsIsHdmiARCPort</code> iPort = current port in loop, &amp;isArcPort = valid buffer <code>dsERR_NONE</code> Should be successful 04 If the port is an <code>HDMI</code> ARC port, verify it with the configuration file iPort = current port, isArcPort = <code>dsHdmiIn/HdmiArcPortID</code> from configuration file returned by <code>dsIsHdmiARCPort</code> <code>dsERR_NONE</code> Should be successful 05 Terminate <code>HDMI</code> input using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsHdmiInInit API] --&gt;|Success| B{Loop through &lt;br&gt; HDMI ports}\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt; C[Call dsIsHdmiARCPort API]\n    C --&gt;|Success| D[Check isArcPort flag]\n    D --&gt;|isArcPort is true| E[Compare with configuration file]\n    E --&gt; F[Is it the last HDMI port?]\n    F --&gt;|No| B\n    F --&gt;|Yes| G[Call dsHdmiInTerm API]\n    G --&gt;|Success| H[Test case pass]\n    G --&gt;|Failure| G1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-5","title":"Test 5","text":"Title Details Function Name <code>test_l2_dsHdmiIn_SetAndGetEdidVersionAndValidateEdidLength_sink</code> Description Setting the <code>EDID</code> version for a given port and getting back the <code>EDID</code> version and compare with the Set value. Test Group 02 Test Case ID 005 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-5","title":"Test Procedure - Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize HDMI input module using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Set <code>EDID</code> version for each HDMI port using <code>dsSetEdidVersion</code> hdmiPort = <code>dsHDMI_IN_PORT_0</code> to <code>dsHDMI_IN_PORT_2</code>, edidVersion = Supported <code>EDID</code> version from configuration file  <code>dsHdmiIn/EdidVersion/</code> <code>dsERR_NONE</code> Should be successful 03 Get  and compare the <code>EDID</code> version for each <code>HDMI</code> port using <code>dsGetEdidVersion</code> hdmiPort <code>dsERR_NONE</code> Should be successful 04 Repeat steps 2 to 4 for all <code>HDMI</code> ports and <code>EDID</code> versions <code>dsERR_NONE</code> Should be successful 05 Terminate <code>HDMI</code> input module using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsHdmiInInit] --&gt; |Success| B[dsSetEdidVersion for various ports and edid version]\n    A --&gt; |Failure| A1[Test Case Fail: dsHdmiInInit]\n    B --&gt; |Success| C[dsGetEdidVersion]\n    B --&gt; |Failure| B1[Test Case Fail: dsSetEdidVersion]\n    C --&gt; |Success &amp; get and set matches | G[dsHdmiInTerm]\n    C --&gt; |Failure| C1[Test Case Fail: dsGetEdidVersion]\n    G --&gt; |Success| H[Test Case Success]\n    G --&gt; |Failure| G1[Test Case Fail: dsHdmiInTerm]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-6","title":"Test 6","text":"Title Details Function Name <code>test_l2_dsHdmiIn_GetSupportedGameFeaturesList_sink</code> Description Make sure that the functionality can list and get the count of all the game features that are supported. Compare the result by parsing the configuration YAML file <code>dsHdmiIn/gameFeatures/count</code> Test Group 02 Test Case ID 006 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-6","title":"Test Procedure - Test 6","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize HDMI input using dsHdmiInInit None dsERR_NONE Should be successful 02 Get the list of supported game features using dsGetSupportedGameFeaturesList features = <code>dsHdmiIn/gameFeatures/feature</code> dsERR_NONE Should be successful 03 Compare the count of game features with the count in the configuration file features.gameFeatureCount = value from <code>dsHdmiIn/gameFeatures/count</code> dsERR_NONE Should be successful 04 Terminate HDMI input using dsHdmiInTerm None dsERR_NONE Should be successful <pre><code>graph TB\n    A[Call dsHdmiInInit API] --&gt;|dsERR_NONE| B[Call dsGetSupportedGameFeaturesList API]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt; C[Verify gameFeatureCount field]\n    B --&gt;|Failure| B1[Test case fail]\n    C --&gt;|dsERR_NONE| D[Verify gameFeatureList field]\n    C --&gt;|Failure| C1[Test case fail]\n    D --&gt; E[Call dsHdmiInTerm API]\n    D --&gt;|Failure| D1[Test case fail]\n    E --&gt; F[Test case success]\n    E --&gt;|Failure| E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-7","title":"Test 7","text":"Title Details Function Name <code>test_l2_dsHdmiIn_SetAndGetAllmSupport_sink</code> Description Set and Get the <code>ALLM</code> support to <code>EDID</code> version 2.0 without connecting any source devices. Test Group 02 Test Case ID 007 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-7","title":"Test Procedure - Test 7","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize <code>HDMI</code> input using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Set <code>EDID</code> 2.0 ALLM support to true using <code>dsSetEdid2AllmSupport</code> iHdmiPort = <code>dsHDMI_IN_PORT_0</code>, allmSupport = true <code>dsERR_NONE</code> Should be successful 03 Get <code>EDID</code> 2.0 ALLM support using <code>dsGetEdid2AllmSupport</code> iHdmiPort = <code>dsHDMI_IN_PORT_0</code>,  number of Hdmi Input ports <code>dsERR_NONE</code>, allmSupport = true Should be successful 04 Set EDID 2.0 ALLM support to false using <code>dsSetEdid2AllmSupport</code> iHdmiPort = dsHDMI_IN_PORT_0, allmSupport = false <code>dsERR_NONE</code> Should be successful 05 Get EDID 2.0 ALLM support using <code>dsGetEdid2AllmSupport</code> iHdmiPort = <code>dsHDMI_IN_PORT_0</code>, to number of Hdmi Input ports supported <code>dsERR_NONE</code>, allmSupport = false Should be successful 06 Terminate HDMI input using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHdmiInInit] --&gt;|Success| B[Call dsSetEdid2AllmSupport with true]\nA --&gt;|Failure| A1[Test case fail]\nB --&gt;|Success| C[Call dsGetEdid2AllmSupport]\nB --&gt;|Failure| B1[Test case fail]\nC --&gt;|Success| D[Call dsSetEdid2AllmSupport with false]\nC --&gt;|Failure| C1[Test case fail]\nD --&gt;|Success| E[Call dsGetEdid2AllmSupport]\nD --&gt;|Failure| D1[Test case fail]\nE --&gt;|Success| F[Call dsHdmiInTerm]\nE --&gt;|Failure| E1[Test case fail]\nF --&gt;|Success| G[Test case success]\nF --&gt;|Failure| F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-8","title":"Test 8","text":"Title Details Function Name <code>test_l2_dsHdmiIn_GetHdmiVersionAndValidate_sink</code> Description Getting the <code>HDMI</code> compatibility version for a given port version and validate it. Test Group 02 Test Case ID 008 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in-L2-Low-Level_TestSpec/#test-procedure-test-8","title":"Test Procedure - Test 8","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize HDMI input module using <code>dsHdmiInInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get  and validate the <code>HDMI</code> compatibility version by comparing with the YAML file for each <code>HDMI</code> port using <code>dsGetHdmiVersion</code> hdmiPort = <code>dsHDMI_IN_PORT_0</code> to number of supported ports <code>dsERR_NONE</code> Should be successful 03 Terminate <code>HDMI</code> input module using <code>dsHdmiInTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[dsHdmiInInit] --&gt; |Success| B[dsGetHdmiVersion]\n    A --&gt; |Failure| A1[Test Case Fail: dsHdmiInInit]\n    B --&gt; |Success| C[Validate with value from profile file]\n    B --&gt; |Failure| B1[Test Case Fail : dsGetHdmiVersion]\n    C --&gt; |Success| D[dsHdmiInTerm]\n    C --&gt; |Failure| C1[Test Case Fail]\n    D --&gt; |Success| E[Test Case Success]\n    D --&gt; |Failure| D1[Test Case Fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/","title":"dsHdmiIn HAL L3 Python Test Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Test Cases</li> <li>dsHdmiIn_test1_ConnectionCallback_Verify.py</li> <li>dsHdmiIn_test2_SignalChangeCallback_Verify.py</li> <li>dsHdmiIn_test3_PortStatusCallback_Verify.py</li> <li>dsHdmiIn_test4_VideoModeChangeCallback_Verify.py</li> <li>dsHdmiIn_test5_AllmChangeCallback_Verify.py</li> <li>dsHdmiIn_test6_AVlatencyCallback_Verify.py</li> <li>dsHdmiIn_test7_AVIChangeCallback_Verify.py</li> <li>dsHdmiIn_test8_SelectPortAndVerifyPortStatus.py</li> <li>dsHdmiIn_test9_ScaleVideoAndVerify.py</li> <li>dsHdmiIn_test10_ZoomModeAndVerify.py</li> <li>dsHdmiIn_test11_GetEDIDInfo_Verify.py</li> <li>dsHdmiIn_test12_GetSpdInfo_Verify.py</li> <li>dsHdmiIn_test13_SetAndGetEDIDVersion.py</li> <li>dsHdmiIn_test14_SetAndGetEDID2ALLMSupport.py</li> <li>dsHdmiIn_L3_Runall_Sink.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>OEM</code>    - Original Equipment Manufacture</li> <li><code>SoC</code>    - System on a Chip</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>SDR</code>    - Standard Dynamic Range</li> <li><code>EDID</code>   - Extended Display Identification Data</li> <li><code>ALLM</code>   - Auto Low Latency Mode</li> <li><code>AVI</code>    - Audio Video Interleave</li> <li><code>SPD</code>    - Source Product Descriptor</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: <code>ut/host/tests/configs/example_rack_config.yml</code></p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"tv device under test\"\n      platform: \"tv\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: <code>ut/host/tests/configs/deviceConfig.yml</code></p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file: - Set the folder path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n  cpe1:\n    platform: \"linux\"    # Must match the platform in example_rack_config.yml\n    model: \"uk\"\n    soc_vendor: \"intel\"\n    target_directory: \"/tmp\"  # Path where HAL binaries are copied in device\n    prompt: \"\" # Prompt string on console\n    test:\n      profile: \"../../../../profiles/sink/Sink_HDMIIN.yaml\"\n      player:\n        tool: \"gstreamer\"\n        prerequisites:\n          - export xxxx    # Pre-commands required to play the stream\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: <code>ut/host/tests/L3_TestCases/dsHdmiIn/dsHdmiIn_L3_testSetup.yml</code></p> <p>If need to enable any commands post test case execution update postcmd.</p> <pre><code>dsHdmiIn:\n  description: \"dsHdmiIn Device Settings test setup\"\n  assets:\n    device:\n      test1_ConnectionCallback_Verify:\n        streams:[]\n      test2_SignalChangeCallback_Verify:\n        streams:[]\n      test14_SetAndGetEDID2ALLMSupport:\n        streams:[]\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: <code>ut/host/tests/dsClasses/dsHdmiIn_testConfig.yml</code></p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p> <pre><code>dsHdmiIn:\n  description: \"dsHdmiIn Device Settings testing profile\"\n  test:\n    artifacts:\n            - \"../../../bin/\"\n    execute: \"run.sh\"\n    type: UT-C  # Cunit tests (UT-C)\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test1_connectioncallback_verifypy","title":"dsHdmiIn_test1_ConnectionCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>Yes: User interaction is necessary to connect and Disconnect the Hdmi In device.(This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Connect the external device and check if dut recognize the event. Disconnect the external device and check if dut recognize the event.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test registers the event and check for  the event callback.</p> <p>Success Criteria</p> <ul> <li>Device should recognize the connect/Disconnect event.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsHdmiIn_test1_ConnectionCallback_Verify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will Request User to connect Source device to Hdmi In port:</p> </li> <li> <p>Question: \"Plug the HDMI cable {port} and Press Enter: (Y/N)\"</p> </li> <li>Press Y if Device is connected/disconnect (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect/disconnect the device (this will mark the step as FAIL).</p> </li> <li> <p>Device Status Confirmation:</p> </li> <li> <p>Test will check if the device status event has reached the device. </p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, connecting/disconnecting device on each one and collecting user feedback accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test2_signalchangecallback_verifypy","title":"dsHdmiIn_test2_SignalChangeCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test02","title":"Platform Supported - test02","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test02","title":"User Input Required - test02","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device.(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<ul> <li>Verify the Signal status.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test02","title":"Expected Results - test02","text":"<ul> <li>The test registers the event and check for signal status event callback.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsHdmiIn_test2_SignalChangeCallback_Verify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Signal Status Confirmation:</p> </li> <li> <p>Test will check if the signal status event has reached the device.</p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, collects signal status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test3_portstatuscallback_verifypy","title":"dsHdmiIn_test3_PortStatusCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test03","title":"Platform Supported - test03","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test03","title":"User Input Required - test03","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device.(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<ul> <li>Verify the Port status.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test03","title":"Expected Results - test03","text":"<ul> <li>The test registers the event and check for port status event callback.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsHdmiIn_test3_PortStatusCallback_Verify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Port Status Confirmation:</p> </li> <li> <p>Test will check if the port status event has reached the device.</p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, collects port status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test4_videomodechangecallback_verifypy","title":"dsHdmiIn_test4_VideoModeChangeCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test04","title":"Platform Supported - test04","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test04","title":"User Input Required - test04","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device and to change the resolution on connected device(like Fire Tv Stick, Xbox, Hdmi Analyzer).(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<ul> <li>Verify the video mode status.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test04","title":"Expected Results - test04","text":"<ul> <li>The test registers the event and check for Video mode status event callback.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Select the test file:  </p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test4_VideoModeChangeCallback_Verify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Device resolution change prompt:</p> <p>The test will prompt the user to change the resolution on the source device connected to the HDMI In port:</p> </li> <li> <p>Question: \"Change the Resolution on device connected to port_type and then press Enter: (Y/N)\"</p> </li> <li>Press Y if user able to change resolution (this will mark the step as PASS).</li> <li> <p>Press N if user unable to change the resolution  (this will mark the step as FAIL).</p> </li> <li> <p>Video mode Status Confirmation:</p> </li> <li> <p>Test will check if the video mode status event has reached the device.</p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, collects video mode status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test5_allmchangecallback_verifypy","title":"dsHdmiIn_test5_AllmChangeCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test05","title":"Platform Supported - test05","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test05","title":"User Input Required - test05","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device and to enable/disable ALLM on connected device (like Fire Tv Stick, Xbox, Hdmi Analyzer).(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<ul> <li>Verify the ALLM status.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test05","title":"Expected Results - test05","text":"<ul> <li>The test registers the event and check for ALLM change event callback</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test5_AllmChangeCallback_Verify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Device ALLM change prompt:</p> <p>The test will prompt the user to enable or disable ALLM:</p> </li> <li> <p>Question: \"Change ALLM mode on Hdmi In device connected to port to enable ALLM if its in OFF and press Enter: (Y/N)\"</p> </li> <li>Press Y if user able to enable the ALLM feature (this will mark the step as PASS).</li> <li> <p>Press N if user unable to enable ALLM feature  (this will mark the step as FAIL).</p> </li> <li> <p>Question: \"Change ALLM mode on Hdmi In device connected to port to disable ALLM and press Enter: (Y/N)\"</p> </li> <li>Press Y if user able to disable the ALLM feature (this will mark the step as PASS).</li> <li> <p>Press N if user unable to disable ALLM feature  (this will mark the step as FAIL).</p> </li> <li> <p>ALLM enable/disable Status Confirmation:</p> </li> <li> <p>Test will check if the ALLM change event has reached the device.</p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, collects ALLM status status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test6_avlatencycallback_verifypy","title":"dsHdmiIn_test6_AVlatencyCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test06","title":"Platform Supported - test06","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test06","title":"User Input Required - test06","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device on ports (like Xbox) and play the games.(This will be    automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test06","title":"Acceptance Criteria - test06","text":"<ul> <li>Verify the audio video latency.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test06","title":"Expected Results - test06","text":"<ul> <li>The test registers the event and check for audio video latency event callback.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test06","title":"Test Steps - test06","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test6_AVlatencyCallback_Verify.py</code></p> </li> <li>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Audio Video latency Confirmation:</p> </li> <li> <p>Test will check if the audio video latency event has reached the device.</p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, collects audio video latency status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test7_avichangecallback_verifypy","title":"dsHdmiIn_test7_AVIChangeCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test07","title":"Platform Supported - test07","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test07","title":"User Input Required - test07","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device and to change the AVI content on connected device (lik   e Hdmi Analyzer) and change the content type like Cinema , Game , Sport.(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test07","title":"Acceptance Criteria - test07","text":"<ul> <li>Verify the AVI content type being played on device.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test07","title":"Expected Results - test07","text":"<ul> <li>The test registers the event and check for AVI content change event callback</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test07","title":"Test Steps - test07","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test7_AVIChangeCallback_Verify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Device AVI content change prompt:</p> <p>The test will prompt the user to change AVI content on the source device:</p> </li> <li> <p>Question: \"Change the AVI Content on device connected to port and press Enter: (Y/N)\"</p> </li> <li>Press Y if user able to change AVI content (this will mark the step as PASS).</li> <li> <p>Press N if user unable to change the AVI content (this will mark the step as FAIL).</p> </li> <li> <p>AVI content Change Confirmation:</p> </li> <li> <p>Test will check if the AVI content change event has reached the device.</p> </li> <li>If event is detected, the step will marked as PASS</li> <li> <p>If event not detected, the step will marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, collects AVI content change status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test8_selectportandverifyportstatuspy","title":"dsHdmiIn_test8_SelectPortAndVerifyPortStatus.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test08","title":"Platform Supported - test08","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test08","title":"User Input Required - test08","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device to port.(This will be automated later)</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test08","title":"Acceptance Criteria - test08","text":"<ul> <li>Verify the respective port is selected.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test08","title":"Expected Results - test08","text":"<ul> <li>The test selects the respective port and verify the same.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test08","title":"Test Steps - test08","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test8_SelectPortAndVerifyPortStatus.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Port select Confirmation:</p> </li> <li> <p>Test will check the status of the port selected.</p> </li> <li>If port selected and supplied port argument are same then mark the step as PASS</li> <li> <p>If  port selected and supplied port argument are not same then  mark the step as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, verify port status accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test9_scalevideoandverifypy","title":"dsHdmiIn_test9_ScaleVideoAndVerify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test09","title":"Platform Supported - test09","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test09","title":"User Input Required - test09","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device and to verify the video scaling on connected device.(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test09","title":"Acceptance Criteria - test09","text":"<ul> <li>Verify the video scaled on selected port.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test09","title":"Expected Results - test09","text":"<ul> <li>The test selects the respective port and scales video.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test09","title":"Test Steps - test09","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test9_ScaleVideoAndVerify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Video scaling Confirmation:     The test will Request User to check video scaled on particular port or not:</p> </li> <li> <p>Question: \"Check if video is scaled  on port port_type. Press Y/N:\"</p> </li> <li>Press Y if video scaling on the specified port is successful (this will mark the step as PASS).</li> <li> <p>Press N if video scaled on the sepcified port not successful (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, verify video scaling accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test10_zoommodeandverifypy","title":"dsHdmiIn_test10_ZoomModeAndVerify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test10","title":"Platform Supported - test10","text":"<ul> <li>Source </li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test10","title":"User Input Required - test10","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device and to verify the video scaling on connected device.(This will be automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test10","title":"Acceptance Criteria - test10","text":"<ul> <li>Verify the zoom mode on selected port.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test10","title":"Expected Results - test10","text":"<ul> <li>The test selects the respective port and sets zoom mode.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test10","title":"Test Steps - test10","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsHdmiIn_test10_ZoomModeAndVerify.py</code></p> </li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>Zoom Mode set Confirmation:     The test will Request User to check particular zoom mode is set on particular port or not:</p> </li> <li> <p>Question: \"Verify Zoom Mode selected on port {port_type} and press Enter: Y/N\"</p> </li> <li>Press Y if zoom mode ablet to set on particular port happen (this will mark the step as PASS).</li> <li> <p>Press N if unable to set zoom mode on particular port not happen (this will mark the step as FAIL).</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, verify zoom mode set accordingly.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test11_getedidinfo_verifypy","title":"dsHdmiIn_test11_GetEDIDInfo_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test11","title":"Platform Supported - test11","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test11","title":"User Input Required - test11","text":"<ul> <li>NO</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test11","title":"Acceptance Criteria - test11","text":"<ul> <li>Get and verify EDID info.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test11","title":"Expected Results - test11","text":"<ul> <li>The test get EDID info and verifies the info.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test11","title":"Test Steps - test11","text":"<ul> <li>Run the Python script <code>dsHdmiIn_test11_GetEDIDInfo_Verify.py</code></li> <li>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</li> <li> <p>Edid Info Confirmation:</p> </li> <li> <p>Test will get the EDID info and verifies the same.</p> </li> <li>If EDID info is received, it will be compared with the YAML EDID info bytes. If they match, the step will be marked as PASS</li> <li> <p>If EDID info is received, it will be compared with the YAML EDID info bytes. If they does not match, the step will be marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, gets EDID and verifies.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test12_getspdinfo_verifypy","title":"dsHdmiIn_test12_GetSpdInfo_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test12","title":"Platform Supported - test12","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test12","title":"User Input Required - test12","text":"<ul> <li>Yes: User interaction is necessary to connect the Hdmi In device to port like Hdmi Quantum Data Analyzer.(This will be    automated later).</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test12","title":"Acceptance Criteria - test12","text":"<ul> <li>Gets SPD Info and verifies the same.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test12","title":"Expected Results - test12","text":"<p>This test evaluates the SPD Info received from connected device.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test12","title":"Test Steps - test12","text":"<ul> <li>Run the Python script <code>dsHdmiIn_test12_GetSpdInfo_Verify.py</code></li> <li> <p>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Device Connect prompt:</p> <p>The test will prompt the User to connect a Source device:</p> </li> <li> <p>Question: \"connect device to porttype and press Enter (Y/N)\"</p> </li> <li>Press Y if Device is connected (this will mark the step as PASS).</li> <li> <p>Press N if user could not connect the device (this will mark the step as FAIL).</p> </li> <li> <p>SPD Info Confirmation:</p> </li> <li> <p>Test will get the SPD info and verifies the same.</p> </li> <li>If SPD info is received, it will be compared with the YAML SPD info bytes. If they match, the step will be marked as PASS</li> <li> <p>If SPD info is received, it will be compared with the YAML SPD info bytes. If they does not match, the step will be marked as FAIL</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, gets spdinfo and verifies the same.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test13_setandgetedidversionpy","title":"dsHdmiIn_test13_SetAndGetEDIDVersion.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test13","title":"Platform Supported - test13","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test13","title":"User Input Required - test13","text":"<ul> <li>NO</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test13","title":"Acceptance Criteria - test13","text":"<ul> <li>Verify EDID version by retrieving.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test13","title":"Expected Results - test13","text":"<p>This test set EDID version and verifies the same by retrieving the EDID version.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test13","title":"Test Steps - test13","text":"<ul> <li>Run the Python script <code>dsHdmiIn_test13_SetAndGetEDIDVersion.py</code></li> <li>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</li> <li> <p>EDID version Verification:</p> </li> <li> <p>Test will sets and get the EDID version.</p> </li> <li>If the set and retrieved EDID versions are the same, the test will mark the step as PASS.</li> <li> <p>If the set and retrieved EDID versions do not match, the test will mark the step as FAIL.</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, sets EDID version and verifies by retrieving EDID version.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p> <ul> <li>Completion and Result:</li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_test14_setandgetedid2allmsupportpy","title":"dsHdmiIn_test14_SetAndGetEDID2ALLMSupport.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#platform-supported-test14","title":"Platform Supported - test14","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#user-input-required-test14","title":"User Input Required - test14","text":"<ul> <li>NO</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#acceptance-criteria-test14","title":"Acceptance Criteria - test14","text":"<ul> <li>Verify ALLM by retrieving.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#expected-results-test14","title":"Expected Results - test14","text":"<p>This test set ALLM and verifies the same by retrieving the ALLM.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#test-steps-test14","title":"Test Steps - test14","text":"<ul> <li>Run the Python script <code>dsHdmiIn_test14_SetAndGetEDID2ALLMSupport.py</code></li> <li>The test will automatically download all required artifacts and streams, copying them to the designated target directory before commencing execution.</li> <li> <p>ALLM version Verification:</p> </li> <li> <p>Test will sets and get the ALLM.</p> </li> <li>If the set and retrieved ALLM support statuses match, the test will mark the step as PASS.</li> <li> <p>If the set and retrieved ALLM support statuses do not match, the test will mark the step as FAIL.</p> </li> <li> <p>Repeat for All Ports:</p> </li> </ul> <p>The test will iterate through all available Hdmi IN ports, sets ALLM and verifies by retrieving ALLM.</p> <ul> <li>Test Conclusion:</li> </ul> <p>Upon receiving user responses for all ports, the test will conclude and present a final result: PASS or FAIL based on the user inputs throughout the test execution.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHDMIIn/ds-hdmi-in_L3_Test-Procedure/#dshdmiin_l3_runall_sinkpy","title":"dsHdmiIn_L3_Runall_Sink.py","text":"<p>This python file runs all the tests supported by <code>sink</code> devices</p> <p>```bash python dsHdmiIn_L3_Runall_Sink.py --config /PATH/ut/host/tests/configs/example_rack_config.yml --deviceConfig /PATH/ut/host/tests/configs/deviceConfig.yml</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/","title":"Device Settings Host High Level Test Specification Document","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>SoC</code>    - System On a Chip</li> <li><code>EDID</code>   - Extended Display Identification</li> <li><code>API</code>    - Application programming interface</li> <li><code>CPU</code>    - Central processing unit</li> <li><code>dsHost</code> - Device Settings Host</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>EDID</code> specifications - https://en.wikipedia.org/wiki/Extended_Display_Identification_Data</li> <li>Python <code>EDID</code> decoder library is available here - https://pypi.org/project/pyedid/</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#introduction","title":"Introduction","text":"<p>This document provides an overview of the testing requirements for the <code>dsHost</code> module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <p>Interface of the test is available in this link - https://github.com/rdkcentral/rdk-halif-device_settings/blob/main/include/dsHost.h</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#module-description","title":"Module Description","text":"<p>High level overview:</p> <ul> <li><code>dsHost</code> offers a range of <code>API</code>s for retrieving information about the platform.</li> <li>Data is retrieved from the <code>SoC</code> and <code>HDMI</code>. This data is passed to the caller.</li> <li>In order to retrieve <code>HDMI</code> information, an external device must be connected.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#testing-scope","title":"Testing Scope","text":"# Testing Scope Description 1 Retrieve CPU Temperature Test if the module correctly retrieves the <code>CPU</code> temperature. 2 Obtain SOC ID Test if the module successfully obtains the 8-byte <code>SoC</code> ID programmed to the CHIP One Time Programmable area. 3 Fetch Host EDID Test if the module fetches the host <code>EDID</code> along with its length -----------"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#retrieve-cpu-temperature","title":"Retrieve CPU Temperature","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Get the CPU temperature and check weather the temperature falls within valid operating range and ensure the <code>CPU</code> is in a normal operating state based on maximum and minimum values of <code>dsHost/cpuTemperature</code> in the configuration yaml <code>dsGetCPUTemperature</code> Y N Y Y N Invoke the module to retrieve <code>CPU</code> temperature while the device is within a heat/cold chambers to verify that the device will properly retrieve the information <code>dsGetCPUTemperature</code> N Y Y Y Y"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#test-startup-requirement-retrieve-cpu-temperature","title":"Test Startup Requirement - Retrieve CPU Temperature","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#emulator-requirement-retrieve-cpu-temperature","title":"Emulator Requirement - Retrieve CPU Temperature","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#control-plane-requirement-retrieve-cpu-temperature","title":"Control Plane Requirement - Retrieve CPU Temperature","text":"<p>Control external heat/cold chambers</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#obtain-soc-id","title":"Obtain SoC ID","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Get the <code>SoC</code> ID and verify with <code>dsHost/socID</code> value in configuration yaml file. <code>dsGetSocIDFromSDK</code> Y N Y Y N"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#test-startup-requirement-obtain-soc-id","title":"Test Startup Requirement-Obtain SoC ID","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#emulator-requirement-obtain-soc-id","title":"Emulator Requirement-Obtain SoC ID","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#control-plane-requirement-obtain-soc-id","title":"Control Plane Requirement-Obtain SoC ID","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#fetch-host-edid","title":"Fetch Host EDID","text":"Description HAL APIs L2 L3 Source Sink Control plane requirements Get the host <code>EDID</code> bytes and validate the <code>EDID</code> bytes and length with the <code>dsHost/edidBytes</code> and <code>dsHost/edidbytesLength</code> values from the configuration yaml file <code>dsGetHostEDID</code> Y N N Y N"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#test-startup-requirement-fetch-host-edid","title":"Test Startup Requirement - Fetch Host EDID","text":"<p>Launch the test with the predefined configuration set of results.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#emulator-requirement-fetch-host-edid","title":"Emulator Requirement - Fetch Host EDID","text":"<p>Emulator will boot with the <code>EDID</code> coming from the configuration file.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_High-Level_TestSpecification/#control-plane-requirement-fetch-host-edid","title":"Control Plane Requirement - Fetch Host EDID","text":"<p>None</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/","title":"Device Settings Host L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the Low Level L2 Test Specification and Procedure for the Device Settings Host module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>SoC</code>  - System on a Chip</li> <li><code>EDID</code> - Extended Display Identification</li> <li><code>CPU</code> - Central processing unit</li> <li><code>dsHost</code> - Device Settings Host</li> <li><code>API</code> - Application programming interface</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsHost_TestSpecification.md</li> <li><code>HAL Interface Header File</code> - dsHost.h</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsHost_GetCPUTemperature</code> Description Get the <code>CPU</code> temperature and check whether the temperature falls within valid operating range and ensure the <code>CPU</code> is in a normal operating state based on maximum and minimum values of <code>dsHost/cpuTemperature</code> in the configuration file Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the host using <code>dsHostInit</code> No input parameters <code>dsERR_NONE</code> Should be successful 02 Get the <code>CPU</code> temperature using <code>dsGetCPUTemperature</code> cpuTemperature = valid buffer <code>dsERR_NONE</code> Should be successful 03 Check the <code>CPU</code> temperature against the profile cpuTemperature = obtained value, profile temperature range = <code>dsHost/cpuTemperature</code> of configuration file Value should fall in the expected range Should be successful 04 Terminate the host using <code>dsHostTerm</code> No input parameters <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHostInit API] --&gt;|return status is dsERR_NONE|B[Call dsGetCPUTemperature API]\nA --&gt;|return status is not dsERR_NONE|A1[Test case fail]\nB --&gt;|return status is dsERR_NONE|C[Check cpuTemperature value &lt;br&gt; with profile value]\nB --&gt;|return status is not dsERR_NONE|B1[Test case fail]\nC --&gt;|cpuTemperature is within valid range|D[Call dsHostTerm API]\nC --&gt;|cpuTemperature is out of valid range|C1[Test case fail]\nD --&gt;|return status is dsERR_NONE|E[Test case success]\nD --&gt;|return status is not dsERR_NONE|D1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsHost_GetAndVerifySocID</code> Description Get the <code>SoC</code> ID and verify with <code>dsHost/socID</code> value in configuration file Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the host using <code>dsHostInit</code> <code>API</code> No input parameters <code>dsERR_NONE</code> Should be successful 02 Get the <code>SoC</code> ID using <code>dsGetSocIDFromSDK</code> <code>API</code> socID = valid buffer <code>dsERR_NONE</code> Should be successful 03 Verify the <code>SoC</code> ID with the value in the configuration file socID = value from <code>dsHost/socID</code> of configuration file <code>dsERR_NONE</code> Should be successful 04 Terminate the host using <code>dsHostTerm</code> <code>API</code> No input parameters <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHostInit API] --&gt;|dsERR_NONE|B[Call dsGetSocIDFromSDK API]\nA --&gt;|Failure|A1[Test case fail]\nB --&gt;|dsERR_NONE|D[Compare SoC ID with socID &lt;br&gt; from sink configuration file]\nB --&gt;|Failure|B1[Test case fail]\nD --&gt;|Match|E[Call dsHostTerm API]\nD --&gt;|No Match|D1[Test case fail]\nE --&gt;|dsERR_NONE|F[Test case success]\nE --&gt;|Failure|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsHost_ValidateHostEDID_sink</code> Description Get the host <code>EDID</code> bytes and validate the <code>EDID</code> bytes and length with the <code>dsHost/edidBytes</code> and <code>dsHost/edidbytesLength</code> values from the configuration file Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L2_Low-Level_TestSpecification/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the host using <code>dsHostInit</code> No input parameters <code>dsERR_NONE</code> Should be successful 02 Get the host <code>EDID</code> using <code>dsGetHostEDID</code> edid = valid buffer, length = valid pointer <code>dsERR_NONE</code> Should be successful 03 Validate the <code>EDID</code> bytes and length edid = retrieved <code>EDID</code> from <code>dsHost/edidBytes</code> of configuration file, length = retrieved length from <code>dsHost/edidbytesLength</code> of configuration file edidBytes and edidbytesLength from configuration file matches Should be successful 04 Terminate the host using <code>dsHostTerm</code> No input parameters <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsHostInit API] --&gt;|Success: dsERR_NONE|B[Call dsGetHostEDID API]\nA --&gt;|Failure: Not dsERR_NONE|A1[Test case fail]\nB --&gt;|Success: dsERR_NONE and &lt;br&gt; valid edid, length|C[Validate EDID bytes and length with &lt;br&gt; values from configuration file]\nB --&gt;|Failure: Not dsERR_NONE or &lt;br&gt; invalid edid, length|B1[Test case fail]\nC --&gt;|Success: Values match|D[Call dsHostTerm API]\nC --&gt;|Failure: Values don't match|C1[Test case fail]\nD --&gt;|Success: dsERR_NONE|E[Test case success]\nD --&gt;|Failure: Not dsERR_NONE|D1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/","title":"Device Settings Host L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Device Settings Host module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>Y</code>   - yes supported</li> <li><code>NA</code>  - Not Supported</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsHost_TestSpecification.md</li> <li><code>HAL Interface Header File</code> - dsHost.h</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Each test case need to verify with the each supported video port. Below are top test use-case for the video port.</p> # Test-case Description HAL APIs Source Sink 1 Verify that the get temperature function After the device is running for sometime, call getTemperature, and call it after a five minute wait. The two temperatures should not see any noticable changes in temperature <code>dsGetCPUTemperature()</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsHost L3 Python test cases:</p> <pre><code>---\ntitle: dsHost - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsHost : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsHost \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsHost</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_Low-Level_TestSpec/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li>For more details refer RAFT and example_device_config.yml</li> </ul> <p>componentProfile.yaml/platformProfile.yaml   - Contains component-specific configurations   - Contains platform wide configuration broken down into separate components   - Example configuration file dsHost_Settings</p> <ul> <li>testSetupConfig.yaml</li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file dsHost_L3_testSetup.yml</p> </li> <li> <p>testSuite.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsHost_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/","title":"dsHost HAL L3 Python Test Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Run Test Cases</li> <li>Test Setup Connections</li> <li>Test Cases</li> <li>dsHost_test1_VerifyTemperature.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_player Plays the stream required for test case ssh_player_secondary Plays a secondary stream, if required for test case ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player_secondary:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update the target directory where <code>HAL</code> binaries will be copied into the device. Also, map the profile to the source/sink settings <code>YAML</code> file path.</p> <p>Ensure the platform should match with the <code>DUT</code> platform in Rack Configuration</p> <pre><code>deviceConfig:\n  cpe1:\n    platform: \"stb\"    # Must match the platform in example_rack_config.yml\n    model: \"uk\"\n    target_directory: \"/tmp\"  # Path where HAL binaries are copied in device\n    test:\n      profile: \"../../../../profiles/sink/Sink_HostSettings.yaml\"\n      player:\n        tool: \"gstreamer\"\n        prerequisites:\n          - export xxxx    # Pre-commands required to play the stream\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: dsHost_L3_testSetup.yml</p> <p>Update the artifact paths from which the binaries should be copied to the device.</p> <p>Set the execution paths for each test case.</p> <pre><code>dsHost:\n  description: \"dsHost Device Settings test setup\"\n  assets:\n    device:\n      defaults: &amp;defaults\n        artifacts:\n          - \"&lt;path&gt;/bin/hal_test\"\n          - \"&lt;path&gt;/bin/libut_control.so\"\n          - \"&lt;path&gt;/bin/Sink_HostSettings.yaml\"\n          - \"&lt;path&gt;/bin/run.sh\"\n        execute:\n          - \"chmod +x /opt/HAL/dshost_L3/hal_test\"\n          - \"chmod +x /opt/HAL/dshost_L3/run.sh\"\n          - cp -rf /usr/lib/libdshal.so /opt/HAL/dshost_L3/\n          - \"ln -s /usr/lib/libds-hal.so /opt/HAL/dshost_L3/libdshal.so\"\n        streams:\n        test1_VerifyConnect_Callback:\n          &lt;&lt;: *defaults\n          streams:\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#test-suite-configuration","title":"Test Suite Configuration","text":"<p>Example Test Setup configuration File: dsHost_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p> <pre><code>dsHost:\n  description: \"dsHost Device Settings testing profile\"\n  test:\n    execute: \"/tmp/run.sh -p /tmp/Sink_HostSettings.yaml\"\n    type: UT-C  # Cunit tests (UT-C)\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#test-setup-connections","title":"Test Setup Connections","text":"<p>To verify the get temperature works as expected. For Example:</p> <ul> <li>Get the temperature, and then place the device in a heat chamber and verify the temperature increases.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#dshost_test1_verifytemperaturepy","title":"dsHost_test1_VerifyTemperature.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Sink/Source</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>Yes: User interaction is necessary increase the temperature (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>The temperature is noted to be increasing once placed in the heat chamber or location to increase the temperature.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The temperature should increase.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsHost/ds-host_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Initiate the Test:</p> </li> <li> <p>Select and execute the Python file: <code>dsHost_test1_VerifyTemperature.py</code></p> </li> <li> <p>The test will automatically download all required artifacts, copying them to the designated target directory before commencing execution.</p> </li> <li> <p>Increase Temperature prompt:</p> <p>The test will request the User to place the device in a heat chamber and press enter to take the first reading, then increase the temperature and press enter to get the next reading:</p> </li> <li> <p>Question: \"Please begin to increase the temperature, and wait around one to two minutes before pressing enter to continue:\"</p> </li> <li> <p>Press Enter once the device is in a location to increase the temperature and suitable time has passed the change in temperature can be recorded.</p> </li> <li> <p>Test Conclusion:</p> </li> </ul> <p>The temperature should increase as expected.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/","title":"Device Settings Video Device High Level Test Specification Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> <li>Emulator Requirements</li> <li>Check the Zoom Control</li> <li>Check the HDR Capability</li> <li>Check Video codec and Formats</li> <li>Check the Display frame rate Capability</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>  - Hardware Abstraction Layer</li> <li><code>API</code>  - Caller Programming Interface</li> <li><code>DS</code>   - Device Settings</li> <li><code>HDR</code>  - High Dynamic Range</li> <li><code>FPS</code>  - Frames Per Second.</li> <li><code>FRF</code>  - Frame Rate Frequency</li> <li><code>HEVC</code> - High Efficiency Video Coding</li> <li><code>NA</code>   - Not Applicable</li> <li><code>Y</code>    - Yes</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the High Level testing requirements for the Device Settings Video Device module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <p>Interface of the test is available here: dsVideoDevice HAL header</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#module-description","title":"Module Description","text":"<p><code>DS</code> Video device <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set information about about the zoom mode, <code>HDR</code> capabilities, Video encoding formats and frame rate.</p> <p>Interface specification is available here: dsVideoPort HAL Spec</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Description 1 Check the Zoom Control Verify setting and getting the zoom modes 2 Check the HDR Capability Check the <code>HDR</code> Capability 3 Check Video codec and Formats Check supported video codec formats 4 Check the Display frame rate Capability Check supported Display frame rates"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#emulator-requirements","title":"Emulator Requirements","text":"<p>Boot configuration: Check video ports, encoding formats, profiles, frame rates, and device-supported zoom modes, along with the number of ports supported by each device.</p> <p>Supported Video encoding formats dsVideoCodingFormat_t link</p> <p>Supported Video <code>HEVC</code> profiles dsVideoCodecHevcProfiles_t link</p> <p>Supported Frame rates dsVideoFrameRate_t link</p> <p>Supported Video formats dsHDRStandard_t link</p> <p>Supported zoom modes dsVideoZoom_t link</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#check-the-zoom-control","title":"Check the Zoom Control","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Check the zoom mode status Loop through each supported video device and the zoom mode can be set using <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/SupportedDFCs)</code> profile file and verify using get function.Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> dsGetVideoDevice(), dsSetDFC(), dsGetDFC() <code>Y</code> <code>N</code> <code>Y</code> <code>NA</code> <code>NA</code> Loop through each supported video device and the zoom mode can be set using <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/SupportedDFCs)</code> profile file and verify using get with Video playback &amp; connected device. Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> dsGetVideoDevice(), dsSetDFC(), dsGetDFC() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#test-startup-requirement-check-the-zoom-control","title":"Test Startup Requirement-Check the Zoom Control","text":"<p>Playback the pre-define streams</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#emulator-requirements-check-the-zoom-control","title":"Emulator Requirements-Check the Zoom Control","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#control-plane-requirements-check-the-zoom-control","title":"Control Plane Requirements-Check the Zoom Control","text":"<p>Verify the applied zoom mode during playback with analyzer.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#check-the-hdr-capability","title":"Check the HDR Capability","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Check <code>HDR</code> Capability Loop through each supported video device and Get the <code>HDR</code> capabilities for each video device and verify with the profile file for source use this <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/HDRCapabilities)</code> and for the sink use this <code>Sink_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/HDRCapabilities)</code> Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> and for the sink use this <code>Sink_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> dsGetHDRCapabilities() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#test-startup-requirement-check-the-hdr-capability","title":"Test Startup Requirement-Check the HDR Capability","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#emulator-requirements-check-the-hdr-capability","title":"Emulator Requirements-Check the HDR Capability","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#control-plane-requirements-check-the-hdr-capability","title":"Control Plane Requirements-Check the HDR Capability","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#check-video-codec-and-formats","title":"Check Video codec and Formats","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Check Video coding Formats and information Loop through each supported video device and the get Video coding format for each video device and verify the with profile file for source use this file <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/SupportedVideoCodingFormats)</code> and for the sink use this <code>Sink_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/SupportedVideoCodingFormats)</code> Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> and for the sink use this <code>Sink_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> dsGetSupportedVideoCodingFormats() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Loop through each supported video device and get Video codec information for each video device and verify the with <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/VideoCodecInfo)</code> profile file.Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code>. dsGetVideoCodecInfo() <code>Y</code> <code>NA</code> <code>Y</code> <code>NA</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#test-startup-requirement-check-video-codec-and-formats","title":"Test Startup Requirement-Check Video codec and Formats","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#emulator-requirements-check-video-codec-and-formats","title":"Emulator Requirements-Check Video codec and Formats","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#control-plane-requirements-check-video-codec-and-formats","title":"Control Plane Requirements-Check Video codec and Formats","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#check-the-display-frame-rate-capability","title":"Check the Display frame rate Capability","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Check the Display frame rate Capability Loop through each supported video device and Set the supported display frame rate for each video device using profile file <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/SupportedDisplayFramerate)</code> and verify using get function. Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code>. dsSetDisplayframerate(), dsGetCurrentDisplayframerate() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Loop through each supported video device and Set the supported display frame rate for each video device using profile file <code>Source_VideoDevice.yaml(dsVideoDevice/Device/[Device Number]/SupportedDisplayFramerate)</code> and check if callbacks are triggered Note:Supported Number of VideoDevices check this profile file for source <code>Source_VideoDevice.yaml(dsVideoDevice/NumVideoDevices)</code> dsSetDisplayframerate(), dsRegisterFrameratePreChangeCB(), dsRegisterFrameratePostChangeCB() <code>NA</code> <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#test-startup-requirement-check-the-display-frame-rate-capability","title":"Test Startup Requirement-Check the Display frame rate Capability","text":"<p>Playback the pre-define streams</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#emulator-requirements-check-the-display-frame-rate-capability","title":"Emulator Requirements-Check the Display frame rate Capability","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_High-Level_TestSpec/#control-plane-requirements-check-the-display-frame-rate-capability","title":"Control Plane Requirements-Check the Display frame rate Capability","text":"<p>Verify the frame rate with analyzer</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/","title":"Device Settings Video Device L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the Low Level L2 Test Specification and Procedure for the Device Settings Video Device module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> <li><code>HDR</code> - High Dynamic Range</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li>High Level Test Specification ds-video-device_High-Level_TestSpec.md</li> <li>dsVideoDevice <code>HAL</code> Interface - dsVideoDevice.h</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsVideoDevice_SetAndGetDFC_source</code> Description Loop through each supported video device and the zoom mode can be set using <code>dsVideoDevice/Device/[Device Number]/SupportedDFCs</code> field of configuration file and verify using get Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize video device using <code>dsVideoDeviceInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get video device handle using <code>dsGetVideoDevice</code> index = 0 to <code>dsVideoDevice/NumVideoDevices</code> from profile file <code>dsERR_NONE</code> Should be successful 03 Loop through each supported video device and set the zoom mode using <code>dsSetDFC</code> handle = obtained handle, dfc = <code>dsVideoDevice/Device/[Device Number]/SupportedDFCs</code> of configuration file <code>dsERR_NONE</code> Should be successful 04 Verify the set zoom mode using <code>dsGetDFC</code> handle = obtained handle, dfc_get = buffer to get dfc <code>dsERR_NONE</code>, dfc_get = dfc Should be successful 05 Terminate video device using <code>dsVideoDeviceTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[dsVideoDeviceInit] --&gt;|dsERR_NONE|B{Loop through &lt;br&gt; each video device}\nA --&gt;|Failure|A1[Test case fail]\nB --&gt;|dsERR_NONE|C[ dsGetVideoDevice]\nC --&gt; D[Set various zoom mode from &lt;br&gt; configuration file - dsSetDFC]\nD --&gt;|dsERR_NONE|E[Verify zoom mode -&lt;br&gt; dsGetDFC]\nE --&gt;|dsERR_NONE, &lt;br&gt; Zoom mode matches|B\nE --&gt;|!dsERR_NONE, &lt;br&gt; Zoom mode doesn't match|E1[Test case fail]\nE1 --&gt; B\nB --&gt;|End of loop|F[ dsVideoDeviceTerm]\nF --&gt;|dsERR_NONE|G[Test case success]\nF --&gt;|Failure|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsVideoDevice_GetHDRCapabilities</code> Description Loop through each supported video device and Get the <code>HDR</code> capabilities for each video device and verify with the configuration file Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video device using <code>dsVideoDeviceInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through each video device using <code>dsGetVideoDevice</code> index = 0 to <code>dsVideoDevice/NumVideoDevices</code> from configuration file, handle = valid pointer <code>dsERR_NONE</code> Should be successful 03 Get the <code>HDR</code> capabilities for each video device using <code>dsGetHDRCapabilities</code> handle = obtained from previous step, capabilities = valid pointer <code>dsERR_NONE</code> Should be successful 04 Verify the obtained <code>HDR</code> capabilities with the configuration file capabilities = obtained from previous step, configuration field = <code>dsVideoDevice/Device/[Device Number]/HDRCapabilities</code> Value should match with the configuration file Should be successful 05 Terminate the video device using <code>dsVideoDeviceTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[dsVideoDeviceInit] --&gt;|dsERR_NONE|B{Loop through each &lt;br&gt; supported video device}\nB --&gt;|dsERR_NONE and valid handle|C[dsGetVideoDevice]\nC --&gt;|dsERR_NONE and valid capabilities|D[dsGetHDRCapabilities]\nD --&gt;|Verify HDR capabilities|E{End of loop}\nD --&gt;|Verify HDR capabilities Fail|D1[Test case fail]\nD1 --&gt; E\nE --&gt; B\nE --&gt;|dsERR_NONE|F[dsVideoDeviceTerm]\nF --&gt; G[Test case success]\nA --&gt;|Failure|H[Test case fail]\nF --&gt;|Failure|J[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsVideoDevice_GetSupportedVideoCodingFormats</code> Description Loop through each supported video device and get the Video coding format for each video device and verify it with the Configuration file Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video device using <code>dsVideoDeviceInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through each video device using <code>dsGetVideoDevice</code> index = 0 to <code>dsVideoDevice/NumVideoDevices</code> from the configuration file <code>dsERR_NONE</code> Should be successful 03 Get the supported video coding formats for each device using <code>dsGetSupportedVideoCodingFormats</code> handle = obtained from <code>dsGetVideoDevice</code> <code>dsERR_NONE</code> Should be successful 04 Verify the obtained supported formats with the configuration file supported_formats = from previous step, configuration field = <code>dsVideoDevice/Device/[Device Number]/SupportedVideoCodingFormats</code> <code>dsERR_NONE</code> Should be successful 05 Terminate the video device using <code>dsVideoDeviceTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsVideoDeviceInit] --&gt;|dsERR_NONE|B{Loop through each &lt;br&gt; supported video device}\nA --&gt;|Failure|A1[Test case fail]\nB --&gt; C[Call dsGetVideoDevice for each device]\nC --&gt;|dsERR_NONE and &lt;br&gt; handle is valid|D[Call dsGetSupportedVideoCodingFormats &lt;br&gt;for each device]\nD --&gt;|dsERR_NONE and &lt;br&gt; supported_formats is valid|E[Verify supported_formats &lt;br&gt; with configuration file]\nE --&gt;|Match|B\nE --&gt;|No Match|E1[Test case fail]\nE1 --&gt; B\nB --&gt;|End of loop|F[Call dsVideoDeviceTerm]\nF --&gt;|dsERR_NONE|G[Test case success]\nF --&gt;|Failure|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-4","title":"Test 4","text":"Title Details Function Name <code>test_l2_dsVideoDevice_GetVideoCodecInfo_source</code> Description Loop through each supported video device and get Video codec information for each video device and verify the with configuration file Test Group 02 Test Case ID 004 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-procedure-test-4","title":"Test Procedure - Test 4","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video device using <code>dsVideoDeviceInit</code> None <code>dsERR_NONE</code> Should be successful 02 Loop through each supported video device using <code>dsGetVideoDevice</code> index = 0 to <code>dsVideoDevice/NumVideoDevices</code> from the configuration file <code>dsERR_NONE</code> Should be successful 03 Get Video codec information for each video device using <code>dsGetVideoCodecInfo</code> handle = handle from <code>dsGetVideoDevice</code>, codec = codec <code>dsERR_NONE</code> Should be successful 04 Verify the obtained Video codec information with configuration file num_entries = <code>dsVideoDevice/Device/[Device Number]/VideoCodecInfo/num_entries</code>, level = <code>dsVideoDevice/Device/[Device Number]/VideoCodecInfo/VideoCodec[number]/level</code>, profile =  <code>dsVideoDevice/Device/[Device Number]/VideoCodecInfo/VideoCodec[number]/profile</code> <code>dsERR_NONE</code> Should be successful 05 Terminate the video device using <code>dsVideoDeviceTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsVideoDeviceInit] --&gt;|dsERR_NONE|B{Loop through each &lt;br&gt;supported video device}\nA --&gt;|Failure|A1[Test case fail]\nB --&gt;|dsERR_NONE and valid handle|C[Call dsGetVideoCodecInfo with handle]\nC --&gt;|dsERR_NONE and info structure populated|D[Verify video codec info &lt;br&gt; with profile file]\nD --&gt;|Success|B\nD --&gt;|Fail|D1[Test case fail]\nD1 --&gt; B\nB --&gt;|End of loop|F[Call dsVideoDeviceTerm]\nF --&gt;|dsERR_NONE|G[Test case success]\nF --&gt;|Failure|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-5","title":"Test 5","text":"Title Details Function Name <code>test_l2_dsVideoDevice_SetAndVerifyDisplayframerate_sink</code> Description Loop through each supported video device and Set the supported display frame rate for each video device using configuration file and verify using get Test Group 02 Test Case ID 005 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-procedure-test-5","title":"Test Procedure - Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize video device using <code>dsVideoDeviceInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get video device handle using <code>dsGetVideoDevice</code> with index 0 , Loop through each supported video device index = 0 to <code>dsVideoDevice/NumVideoDevices</code> from the configuration file, handle = valid pointer <code>dsERR_NONE</code> Should be successful 03 Set the supported display frame rate for each video device using <code>dsSetDisplayframerate</code> handle = obtained handle, framerate = <code>dsVideoDevice/Device/[Device Number]/SupportedDisplayframerate</code> dsERR_NONE Should be successful 04 Verify the set frame rate using <code>dsGetCurrentDisplayframerate</code> handle = obtained handle, framerate = valid pointer <code>dsERR_NONE</code> Should be successful 05 Terminate video device using <code>dsVideoDeviceTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsVideoDeviceInit] --&gt;|dsERR_NONE|B{Loop through each &lt;br&gt; supported video device}\nA --&gt;|Failure|A1[Test case fail]\nB --&gt; D[Read supported display frame &lt;br&gt; rate from profile file]\nD --&gt; E[Call dsSetDisplayframerate &lt;br&gt; with handle and frame rate]\nE --&gt;|dsERR_NONE|F[Call dsGetCurrentDisplayframerate ]\nF --&gt;|dsERR_NONE and frame rate matches|B\nF --&gt; |!dsERR_NONE and frame rate doesn't match|F1[Test case fail]\nF1 --&gt; B\nB --&gt;|End of loop|H[Call dsVideoDeviceTerm]\nH --&gt;|dsERR_NONE|I[Test case pass]\nH --&gt;|Failure|H1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-6","title":"Test 6","text":"Title Details Function Name <code>test_l2_dsVideoDevice_SetAndVerifyFRFMode_sink</code> Description Loop through each supported video device and Set the display frame rate mode for each video device and verify using get Test Group 02 Test Case ID 006 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L2-Low-Level_TestSpec/#test-procedure-test-5_1","title":"Test Procedure - Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize video device using <code>dsVideoDeviceInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get video device handle using <code>dsGetVideoDevice</code> with index 0 , Loop through each supported video device index = 0 to <code>dsVideoDevice/NumVideoDevices</code> from the configuration file, handle = valid pointer <code>dsERR_NONE</code> Should be successful 03 Set the frame rate mode for each video device using <code>dsSetFRFMode</code> handle = obtained handle, frfMode = 0 and 1 dsERR_NONE Should be successful 04 Verify the set frame rate mode using <code>dsGetFRFMode</code> handle = obtained handle, frfMode = valid intiger pointer <code>dsERR_NONE</code> Should be successful 05 Terminate video device using <code>dsVideoDeviceTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsVideoDeviceInit] --&gt;|dsERR_NONE|B{Loop through each &lt;br&gt; supported video device}\nA --&gt;|Failure|A1[Test case fail]\nB --&gt; E[Call dsSetFRFMode with handle and frfMode 0 and 1]\nE --&gt;|dsERR_NONE|F[Call dsGetFRFMode ]\nF --&gt;|dsERR_NONE and frfMode matches|B\nF --&gt; |!dsERR_NONE and frfMode doesn't match|F1[Test case fail]\nF1 --&gt; B\nB --&gt;|End of loop|H[Call dsVideoDeviceTerm]\nH --&gt;|dsERR_NONE|I[Test case pass]\nH --&gt;|Failure|H1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/","title":"Device Settings Video Device L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Device Settings Video Device module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>DFC</code>  - Decoder Format Conversion</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>L3</code>   - Level 3 Testing</li> <li><code>DS</code>   - Device Settings</li> <li><code>HDR</code>  - High Dynamic Range</li> <li><code>FPS</code>  - Frames Per Second.</li> <li><code>FRF</code>  - Frame Rate Frequency</li> <li><code>HEVC</code> - High Efficiency Video Coding</li> <li><code>RAFT</code>  - Rapid Automation Framework for Testing</li> <li><code>DUT</code>   - Device Under Test</li> <li><code>NA</code>   - Not Applicable</li> <li><code>Y</code>    - Yes</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsVideoDevice High Level TestSpec</li> <li><code>Interface header</code> - dsVideoDevice HAL header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#video-streams-requirement","title":"Video Streams Requirement","text":"# Streams Name Streams description 1 scrolling_text_fast_3840x2160_23.98fps.mp4 Resolution: 3840x2160, Framerate Per Second: 23.98 2 scrolling_text_fast_3840x2160_24fps.mp4 Resolution: 3840x2160, Framerate Per Second: 24 3 scrolling_text_fast_3840x2160_25fps.mp4 Resolution: 3840x2160, Framerate Per Second: 25 4 scrolling_text_fast_3840x2160_29.97fps.mp4 Resolution: 3840x2160, Framerate Per Second: 29.97 5 scrolling_text_fast_3840x2160_30fps.mp4 Resolution: 3840x2160, Framerate Per Second: 30 6 scrolling_text_fast_3840x2160_50fps.mp4 Resolution: 3840x2160, Framerate Per Second: 50 7 scrolling_text_fast_3840x2160_59.94fps.mp4 Resolution: 3840x2160, Framerate Per Second: 59.94 8 scrolling_text_fast_3840x2160_60fps.mp4 Resolution: 3840x2160, Framerate Per Second: 60 9 scrolling_text_fast_1920x1080_60fps.mp4 Resolution: 1920x1080, Framerate Per Second: 60"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Below are top test use-case for the Video Display.</p> # Test-case Description HAL APIs Source Sink Streams Number 1 Verify the Video Display framerate change with pre and post change callback. Set the auto framerate mode and check the callback is triggered before and after when the framerate of a display changes <code>dsRegisterFrameratePreChangeCB()</code>, <code>dsRegisterFrameratePostChangeCB()</code> <code>NA</code> <code>Y</code> 1,2,3,4,5,6,7,8 2 Set and verify the Zoom mode of the source device Play any video content and Set the supported Zoom mode and verify the selected Zoom mode <code>dsSetDFC()</code>, <code>dsGetDFC()</code> <code>Y</code> <code>NA</code> 9 3 Select the Device Frame Rate of Sink device Select the Device Frame Rate of Sink device and on playing video playback verify <code>dsSetDisplayframerate()</code> <code>dsSetDisplayframerate()</code> <code>NA</code> <code>Y</code> 1,2,3,4,5,6,7,8 4 Set and verify the <code>FRF</code> mode Select the<code>FRF</code>mode and verify the selected <code>FRF</code> mode with video playback <code>dsSetFRFMode()</code> <code>NA</code> <code>Y</code> 1,2,3,4,5,6,7,8"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsVideoDevice L3 Python test cases:</p> <pre><code>---\ntitle: dsVideoDevice - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- dsVideoDeviceHelperClass : inherits\n    dsVideoDeviceHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; dsVideoDevice : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsVideoDevice \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testConfig.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsVideoDevice</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsVideoDevice_Settings</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file dsVideoDevice_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsVideoDevice_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/","title":"dsVideoDevice HAL L3 Python Test Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Streams Required</li> <li>Test Cases</li> <li>dsVideoDevice_test1_FrameratePreChangePostChangeCallback_Verify.py</li> <li>dsVideoDevice_test2_SetAndGetZoomMode.py</li> <li>dsVideoDevice_test3_SetDisplayFramerate.py</li> <li>dsVideoDevice_test4_SetAndGetFRFMode.py</li> <li>dsVideoDevice_L3_Runall_Sink.py</li> <li>dsVideoDevice_L3_Runall_Source.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>  - Hardware Abstraction Layer</li> <li><code>L3</code>   - Level 3 Testing</li> <li><code>DUT</code>  - Device Under Test</li> <li><code>RAFT</code> - Rapid Automation Framework for Testing</li> <li><code>YAML</code> - YAML Ain't Markup Language</li> <li><code>DS</code>   - Device Settings</li> <li><code>FPS</code>  - Frames Per Second.</li> <li><code>FRF</code>  - Frame Rate Frequency</li> <li><code>HEVC</code> - High Efficiency Video Coding</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_player Plays the stream required for test case ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file: - Set the folder path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../../profiles/sink/Source_VideoDevice.yaml\"\n            streams_download_url: \"&lt;URL_Path&gt;\" #URL path from which the streams are downloaded to the device\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: dsVideoDevice_L3_testSetup.yml</p> <p>Provide the streams for each test case. This path is appended with <code>streams_download_url</code> entry from Device Configuration File</p> <p>If a test case requires multiple streams or needs to be validated using several streams, ensure that all necessary streams are added sequentially for that specific test case.</p> <pre><code>dsVideoDevice:  \n  description: \"dsVideoDevice Device Settings test setup\"\n  assets:\n    device:\n      test1_FrameratePrePostChangeCallBack_Verify:\n        streams:\n      test2_ZoomMode:\n        streams:\n      test3_SetDisplayFramerate:\n        streams:\n      test4_FRFMode:\n        streams:\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: dsVideoDevice_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#streams-required","title":"Streams Required","text":"<p>Refer ds-video-device_L3_Low-Level_TestSpecification.md for the stream details</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#dsvideodevice_test1_framerateprechangepostchangecallback_verifypy","title":"dsVideoDevice_test1_FrameratePreChangePostChangeCallback_Verify.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#platform-supported-test01","title":"Platform Supported - test01","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<ul> <li>No</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<ul> <li>Play Streams <code>#1</code> <code>#2</code> <code>#3</code> <code>#4</code> <code>#5</code> <code>#6</code> <code>#7</code> <code>#8</code> of different fps sequentially and verify whether pre and post display framerate change callbacks triggered or not.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<ul> <li>This test should verify the triggered pre and post callbacks whenever there is a framerate change.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li>Run the test file: <code>dsVideoDevice_test1_FrameratePreChangePostChangeCallback_Verify.py</code></li> <li>Execution process:</li> </ul> <p>Upon execution, the test will:</p> <ul> <li>Download all the required artifacts and streams.</li> <li>Copy them to the target directory.</li> <li> <p>Automatically start the test execution.</p> </li> <li> <p>Iterating through supported display framerates and respective stream:</p> <p>The test sets the auto frame mode and verifies the pre- and post-frame rate change callbacks for different streams with varying frame rates.</p> </li> <li> <p>Completion and results:</p> </li> </ul> <p>Upon verifying the supported framerates and based on the callback responses, the test will conclude and display the final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#dsvideodevice_test2_setandgetzoommodepy","title":"dsVideoDevice_test2_SetAndGetZoomMode.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#platform-supported-test02","title":"Platform Supported - test02","text":"<ul> <li>Source</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<p>Play Stream <code>#9</code> and verify the supported zoom modes on device.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test will set the various zoom modes. The user should able to notice a change in device's output while different zoom modes are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Select the test file:</p> </li> <li> <p>Run the Python script <code>dsVideoDevice_test2_SetAndGetZoomMode.py</code></p> </li> <li> <p>Execution process:</p> </li> </ul> <p>The test will:</p> <ul> <li>Download all the required artifacts and video streams.</li> <li>Copy them to the target directory.</li> <li> <p>Automatically start the test execution.</p> </li> <li> <p>Play the video stream:</p> </li> </ul> <p>Test starts the video stream playback specified in the test setup configuration file.</p> <ul> <li>Iterating through supported zoom modes:</li> </ul> <p>The test will repeat for different supported zoom modes. On setting each zoom mode user need to verify whether it is applied to playback stream.</p> <ul> <li>User interaction for verification:</li> </ul> <p>For each iteration:</p> <ul> <li>The test will ask: <code>Is the Zoom mode {zoomMode} applied in the device: {device}? (Y/N):</code></li> <li> <p>The user should press Y if the zoom mode is applied correctly (this passes the step), or N if the zoom is not observed (this fails the step).</p> </li> <li> <p>Completion and results:</p> </li> </ul> <p>Once all necessary user actions are completed, the test will evaluate the results and display whether the test Passed or Failed.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#dsvideodevice_test3_setdisplayframeratepy","title":"dsVideoDevice_test3_SetDisplayFramerate.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#platform-supported-test03","title":"Platform Supported - test03","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Play Streams <code>#1</code> <code>#2</code> <code>#3</code> <code>#4</code> <code>#5</code> <code>#6</code> <code>#7</code> <code>#8</code> of different fps sequentially an verify the impact of the supported display framerates.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#expected-results-test03","title":"Expected Results - test03","text":"<p>This test will evaluate the supported display framerates. The user should notice a difference in video playback when different streamrates are applied.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Select the test file:  </p> </li> <li> <p>Run the Python script <code>dsVideoDevice_test3_SetDisplayFramerate.py</code></p> </li> <li> <p>Execution process:</p> </li> </ul> <p>The test will:</p> <ul> <li>Download all required artifacts and video streams.</li> <li>Copy them to the target directory.</li> <li> <p>Automatically begin the test execution.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the designated video stream.</p> </li> <li>During playback, the test will prompt the user to verify whether displayRate with a streamRate acceptable.</li> </ul> <pre><code>  For example, to verify the display frame rate for weston-gl, run the following commands to check the refresh rate set on the display:\n\n  export XDG_RUNTIME_DIR=/tmp\n  westeros-gl-console get auto-frm-mode   //auto-frm-mode 0 - Disable, auto-frm-mode 1 - Enable\n  westeros-gl-console get mode            //mode 3840x2160px60 - 60FPS\n</code></pre> <ul> <li>Iterating through supported display framerates:</li> </ul> <p>The test will repeat for different supported display framerates.</p> <ul> <li>User Interaction:</li> </ul> <p>For each prompt, the user should assess the video playback output and respond:</p> <ul> <li><code>Is a displayRate {displayFramerate} with a streamRate {StreamFrameRate} acceptable? (Y/N):</code>, the user should press Y to confirm (this will pass the step).</li> <li> <p>If not, press N (this will fail the step).</p> </li> <li> <p>Completion and results:</p> </li> </ul> <p>After receiving all user inputs, the test will conclude and provide a final result (PASS/FAIL).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#dsvideodevice_test4_setandgetfrfmodepy","title":"dsVideoDevice_test4_SetAndGetFRFMode.py","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#platform-supported-test04","title":"Platform Supported - test04","text":"<ul> <li>Sink</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>Yes (This will be automated later).</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>Play Streams <code>#1</code> <code>#2</code> <code>#3</code> <code>#4</code> <code>#5</code> <code>#6</code> <code>#7</code> <code>#8</code> sequentially and verify the video playback and Framerate with <code>FRF</code> mode enabled.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>The test evaluates the effect of <code>FRF</code> mode on video playback. The user should notice a difference in video output for different frame rate streams when Auto <code>FRF</code> mode is enabled.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>dsVideoDevice_test4_SetAndGetFRFMode.py</code></p> </li> <li> <p>Download and Setup:</p> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> </li> <li> <p>Stream Playback:</p> </li> <li> <p>The test will play the designated video stream.</p> </li> <li> <p>During playback, the test will prompt the user to verify whether <code>FRF</code> mode is applied based on video playback.</p> </li> <li> <p>User Interaction:</p> </li> </ul> <p>For each prompt, the user should assess the video playback output and respond:</p> <ul> <li>The test will ask: <code>Has the display refresh rate been changed to match Stream Framerate:{streamFramerate} (Suggested mode is {expectedMode})? (Y/N):</code>, the user should press Y to confirm the experience (this will pass the step).</li> <li>If not, press N (this will fail the step).</li> </ul> <pre><code>  For example, to verify the display frame rate for weston-gl, run the following commands to check the refresh rate set on the display:\n\n  export XDG_RUNTIME_DIR=/tmp\n  westeros-gl-console get auto-frm-mode   //auto-frm-mode 0 - Disable, auto-frm-mode 1 - Enable\n  westeros-gl-console get mode            //mode 3840x2160px60 - 60FPS\n</code></pre> <ul> <li>Completion:</li> </ul> <p>After receiving all necessary user inputs, the test case will conclude and display the final result: PASS or FAIL.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#dsvideodevice_l3_runall_sinkpy","title":"dsVideoDevice_L3_Runall_Sink.py","text":"<p>This python file runs all the tests supported by <code>sink</code> devices</p> <pre><code>python dsVideoDevice_L3_Runall_Sink.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoDevice/ds-video-device_L3_TestProcedure/#dsvideodevice_l3_runall_sourcepy","title":"dsVideoDevice_L3_Runall_Source.py","text":"<p>This python file runs all the tests supported by <code>source</code> devices</p> <pre><code>python dsVideoDevice_L3_Runall_Source.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/","title":"Device Settings Video Port High Level Test Specification Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Module Description</li> <li>Testing Scope</li> <li>Emulator Requirements</li> <li>Check the Video port status</li> <li>Check Video Content Format and Resolution</li> <li>Check HDR Capability</li> <li>HDCP Management</li> <li>Color Capabilities</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Caller Programming Interface</li> <li><code>DS</code>     - Device Settings</li> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>HDCP</code>   - High-bandwidth Digital Content Protection</li> <li><code>HDR</code>    - High Dynamic Range</li> <li><code>SDR</code>    - Standard Dynamic Range</li> <li><code>EDID</code>   - Extended Display Identification Data</li> <li><code>EOTF</code>   - Electro-Optical Transfer Function</li> <li><code>NA</code>     - Not Applicable</li> <li><code>Y</code>      - Yes</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the High Level testing requirements for the Device Settings Video Port module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <p>Interface header is available here: dsVideoPort HAL header</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#module-description","title":"Module Description","text":"<p><code>DS</code> Video Port <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set information about the Video ports like getting  video port handle, fetching connected display information such as color depth, color space, matrix coefficients, quantization range, supported video resolutions using the video port handle. It also provides <code>APIs</code> to enable or disable content protection like <code>HDCP</code>, to set the background color and preferred color depth of the video port.</p> <p>Interface specification is available here: dsVideoPort HAL Spec</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Description 1 Check the Video port status Check the Video Port Access and Status 2 Check Video Content Format and Resolution Check Video content Format and Resolution 3 Check HDR Capability Check <code>HDR</code> Capability 4 HDCP Management Check <code>HDCP</code> Status 5 Color Capabilities Check the color capabilities"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#emulator-requirements","title":"Emulator Requirements","text":"<p>Boot configuration: Check video ports, formats, frame rates, and device-supported resolutions, along with the number of ports supported by each device.</p> <p>Supported Video Port dsVideoPortType_t link</p> <p>Supported Video resolutions dsTVResolution_t link</p> <p>Supported Frame rates dsVideoFrameRate_t link</p> <p>Supported Video formats dsHDRStandard_t link</p> <p>Supported Video background Color dsVideoBackgroundColor_t link</p> <p>Supported Display Color Depth dsDisplayColorDepth_t link</p> <p>Supported Display Color Space dsDisplayColorSpace_t link</p> <p>Supported Display MatrixCoefficient dsDisplayMatrixCoefficients_t link</p> <p>Supported Display QuantizationRange dsDisplayQuantizationRange_t link</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#check-the-video-port-status","title":"Check the video port status","text":"Test Functionality Description HAL APIs L2 L3 Source Sink Control plane requirements Check the each video port status Get the handle for each video port, check the status of each video port to see if it's enabled or disabled. If a port is disabled, enable it, and then verify the status of each port. dsGetVideoPort(), dsIsVideoPortEnabled(), dsEnableVideoPort() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Verify the connected/disconnected status of each port's display when no video port is connected. dsIsDisplayConnected(), dsIsVideoPortActive() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Verify the connected/disconnected status of each port's display by connecting/disconnecting the video port dsIsDisplayConnected(), dsIsVideoPortActive() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Retrieve the surround mode capabilities of each port and verify them with the configuration YAML file. If it is a sink device, retrieve the value from 'Sink_4K_VideoPort.yaml' using the path \"dsVideoPort/Ports/[port no]/Display_surround\" since the sink device has only an INTERNAL port. It is not supported for the source devices dsIsDisplaySurround() <code>Y</code> <code>NA</code> <code>NA</code> <code>Y</code> <code>NA</code> Verify the each port surround mode capabilities of connected display and verify with configuration file. It is not supported of Sink devices. If it is a source devices, the value has to be retrieved from the \"Source_4K_VideoPort.yaml\" using the path \"dsVideoPort/Ports/[port no]/Display_surround\" supported by the <code>HDMI</code> device. dsIsDisplaySurround(), dsGetSurroundMode() <code>Y</code> <code>NA</code> <code>Y</code> <code>NA</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#test-startup-requirement-check-the-video-port-status","title":"Test Startup Requirement-Check the video port status","text":"<p><code>NA</code></p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#emulator-requirements-check-the-video-port-status","title":"Emulator Requirements-Check the video port status","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#control-plane-requirements-check-the-video-port-status","title":"Control Plane Requirements-Check the video port status","text":"<p>plug/Unplug the Video port,Verify with edid info, is surround mode supported</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#check-video-content-format-and-resolution","title":"Check Video Content Format and Resolution","text":"Test Functionality Description HAL API's L2 L3 Source Sink Control plane requirements Check Video Format Content and Resolution Register callback for the Video Format update event,change the video formate and check whether callback is Triggered or not dsVideoFormatUpdateRegisterCB() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Set properties for each video port, including pixel resolution, aspect ratio, stereoscopic modes, frame rates, and scan modes, looping through supported values. Verify the settings using the get function dsSetResolution(), dsGetResolution() <code>Y</code> <code>NA</code> <code>Y</code> <code>NA</code> <code>NA</code> Set current active Video port properties like pixel resolution, Aspect ratio, Stereo Scopic modes, frame rates &amp; scan modes and looping through with supported values and verify external Analyzer with video playback dsIsVideoPortActive(), dsSetResolution(), dsGetResolution() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Gets the each port supported resolutions of TV and verify with the configuration YAML file. If it is a sink device, the value to be retrieved from the 'Sink_4K_VideoPort.yaml' by using the path \"dsVideoPort/Ports/[port no]/Supported_tv_resolutions_capabilities\", supported by INTERNAL port. For source devices, the value to be retrieved from the 'Source_4K_VideoPort.yaml' by using the path \"dsVideoPort/Ports/[port no]/Supported_tv_resolutions_capabilities\", supported by <code>HDMI</code> port. dsSupportedTvResolutions() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> Get the current active Video port resolution and verify with the external device dsIsVideoPortActive(), dsGetResolution() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#test-startup-requirement-check-video-content-format-and-resolution","title":"Test Startup Requirement-Check Video Content Format and Resolution","text":"<p>Playback the pre-define streams</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#emulator-requirements-check-video-content-format-and-resolution","title":"Emulator Requirements-Check Video Content Format and Resolution","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#control-plane-requirements-check-video-content-format-and-resolution","title":"Control Plane Requirements-Check Video Content Format and Resolution","text":"<p>Check the each  port output resolutions and Verify the AspectRatio,video Stereo Scopic modes,video Frame rates,interlaced/progressive.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#check-hdr-capability","title":"Check HDR Capability","text":"Test Functionality Description HAL API's L2 L3 Source Sink Control plane requirements Check HDR Capability Get the each port HDR capabilities &amp; verify with the configuration YAML file YAML file. If it is a sink device, the value to be retrieved from the 'Sink_4K_VideoPort.yaml' by using the path \"dsVideoPort/Ports/[port no]/hdr_capabilities\", supported by INTERNAL port. For source devices, the value to be retrieved from the 'Source_4K_VideoPort.yaml' by using the path \"dsVideoPort/Ports/[port no]/hdr_capabilities\", supported only by <code>HDMI</code> port. dsGetTVHDRCapabilities() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> get the HDR format current active video port and verify with external analyzer dsIsVideoPortActive(), dsGetVideoEOTF() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Checks current active video port output is HDR with different HDR/SDR streams and verify with external analyzer dsIsVideoPortActive(), dsIsOutputHDR() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Set/Reset force HDR mode for the current active video port and verify with external analyzer is HDR mode is set/reset dsIsVideoPortActive(), dsSetForceHDRMode() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Reset the current active video port output to SDR and verify with external analyzer dsIsVideoPortActive(), dsResetOutputToSDR() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Set Force-disable 4K support for each port and verify it using the get function. dsSetForceDisable4KSupport(), dsGetForceDisable4KSupport() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Set Force Disable 4KSupport for active port on playback and verify with analyzer dsIsVideoPortActive(), dsSetForceDisable4KSupport() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#test-startup-requirement-check-hdr-capability","title":"Test Startup Requirement-Check HDR Capability","text":"<p>Playback the pre-define streams</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#emulator-requirements-check-hdr-capability","title":"Emulator Requirements-Check HDR Capability","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#control-plane-requirements-check-hdr-capability","title":"Control Plane Requirements-Check HDR Capability","text":"<p>Check video out is HDR or SDR and verify with analyzer</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#hdcp-management","title":"HDCP Management","text":"Test Functionality Description HAL API's L2 L3 Source Sink Control plane requirements Check HDCP status Check enable/disable the HDCP(1.x &amp; 2.x) for the current active video port with playback dsIsVideoPortActive(), dsEnableHDCP(), dsIsHDCPEnabled() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>NA</code> Check the HDCP status of each port and verify if dsHDCP_STATUS_AUTHENTICATED is returned for sinks, and dsHDCP_STATUS_UNPOWERED/dsHDCP_STATUS_PORTDISABLED is returned for sources. dsGetHDCPStatus() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Check current active port HDCP status and check with connected device dsIsVideoPortActive(), dsGetHDCPStatus() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>NA</code> Check the HDCP protocol status of each port and verify it with the configuration YAML file. If it is a sink device, retrieve the value from the 'Sink_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/hdcp_protocol_version\" supported by INTERNAL port. For a source device, retrieve the value from the 'Source_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/hdcp_protocol_version\" supported by <code>HDMI</code> port. dsGetHDCPProtocol() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Check current active port HDCP protocol Status with connected device dsIsVideoPortActive(), dsGetHDCPCurrentProtocol() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Check active port HDCP Receiver protocol version with connected device dsIsVideoPortActive(), dsGetHDCPReceiverProtocol(), <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Ignore EDID status for active port with connected device dsIsVideoPortActive(), dsGetIgnoreEDIDStatus() <code>N</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Set the preferred HDCP Protocol version for each valid port and verify it using the get function. dsSetHdmiPreference(), dsGetHdmiPreference() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> set/get preferred HDCP Protocol version for active port with connected device dsIsVideoPortActive(), dsSetHdmiPreference(), dsGetHdmiPreference() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>NA</code> Notify event if the HDCP status change and check the timing info for hdcp authentication dsRegisterHdcpStatusCallback() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Check HDCP status for active port and verify with external analyzer dsRegisterHdcpStatusCallback() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#test-startup-requirement-hdcp-management","title":"Test Startup Requirement-HDCP Management","text":"<p>Playback the pre-define streams</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#emulator-requirements-hdcp-management","title":"Emulator Requirements-HDCP Management","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#control-plane-requirements-hdcp-management","title":"Control Plane Requirements-HDCP Management","text":"<p>Check the HDCP status with external analyzer</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#color-capabilities","title":"Color Capabilities","text":"Test Functionality Description HAL API's L2 L3 Source Sink Control plane requirements Check Color information Get each port Color Space, compare with the configuration YAML file. If it is a sink device, retrieve the value from the 'Sink_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/colorspaces\" supported by INTERNAL port. For a source device, retrieve the value from the 'Source_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/colorspaces\" supported by <code>HDMI</code> port. dsGetColorSpace() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Get Color Space of active port with video playback dsIsVideoPortActive(), dsGetColorSpace() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>NA</code> Check each port Color Depth Capabilities and compare with the configuration YAML file . If it is a sink device, retrieve the value from the 'Sink_4K_VideoPort.yaml' file using the pat \"dsVideoPort/Ports/[port no]/Supported_color_depth_capabilities\" supported by INTERNAL port. For a source device, retrieve the value from the 'Source_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/Supported_color_depth_capabilities\" supported by <code>HDMI</code> port. dsColorDepthCapabilities() <code>Y</code> <code>NA</code> <code>Y</code> <code>NA</code> <code>NA</code> Get each port Color Depth and verify with the configuration YAML file . If it is a sink device, retrieve the value from the 'Sink_4K_VideoPort.yaml' file using the path \"color_depth\" supported by INTERNAL port. For a source device, retrieve the value from the 'Source_4K_VideoPort.yaml' file using the path \"color_depth\" supported by <code>HDMI</code> port. dsGetColorDepth() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Get active port Color Depth and verify with the analyzer dsIsVideoPortActive(), dsGetColorDepth() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code> Set preferred color depth for each port and compare get function dsSetPreferredColorDepth(), dsGetPreferredColorDepth() <code>Y</code> <code>NA</code> <code>Y</code> <code>NA</code> <code>NA</code> Set preferred color depth for current active port and verify with the analyzer dsIsVideoPortActive(), dsSetPreferredColorDepth() <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Get each port QuantizationRange status and verify with the configuration YAML file. If it is a sink device, retrieve the value from the 'Sink_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/quantization_ranges\" supported only by INTERNAL port. For a source device, retrieve the value from the 'Source_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/quantization_ranges\" supported by <code>HDMI</code> port. dsGetQuantizationRange() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Get each port MatrixCoefficients status and verify return dsDISPLAY_MATRIXCOEFFICIENT_UNKNOWN for source and with the configuration YAML file. If it is a sink device, retrieve the value from the 'Sink_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/matrix_coefficients\" supported only by INTERNAL port. For a source device, retrieve the value from the 'Source_4K_VideoPort.yaml' file using the path \"dsVideoPort/Ports/[port no]/matrix_coefficients\" supported by <code>HDMI</code> port. dsGetMatrixCoefficients() <code>Y</code> <code>NA</code> <code>Y</code> <code>Y</code> <code>NA</code> Check active port MatrixCoefficients status with video playback and verify with analyzer dsIsVideoPortActive(), dsGetMatrixCoefficients() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>NA</code> Set Background Color for active port with video playback and verify with analyzer/external device dsIsVideoPortActive(), dsSetBackgroundColor() <code>N</code> <code>Y</code> <code>Y</code> <code>NA</code> <code>Y</code> Gets current color space setting, color depth, matrix coefficients, HDR type,quantization range in one call of the active video port and verify with analyzer/external device dsIsVideoPortActive(), dsGetCurrentOutputSettings() <code>NA</code> <code>Y</code> <code>Y</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#test-startup-requirement-color-capabilities","title":"Test Startup Requirement-Color Capabilities","text":"<p>Playback the pre-define streams</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#emulator-requirements-color-capabilities","title":"Emulator Requirements-Color Capabilities","text":"<p>Emulator Requirements</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_High-Level_TestSpec/#control-plane-requirements-color-capabilities","title":"Control Plane Requirements-Color Capabilities","text":"<p>Verify the Color Space,Color Depth,QuantizationRange,MatrixCoefficients,Background Color with analyzer/external device</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/","title":"Device Settings Video Port L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L2 Low Level Test Specification and Procedure Documentation for the Device Settings Video Port module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> <li><code>HDMI</code>  - High-Definition Multimedia Interface</li> <li><code>HDCP</code>  - High-bandwidth Digital Content Protection</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsVideoPort High Level TestSpec</li> <li><code>Interface header</code> - dsVideoPort HAL header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_dsVideoPort_EnableDisabledVideoPorts</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code> to see if it's enabled or disabled. If a port is disabled, enable it, and then verify the status of each port. Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction :</p> <p>If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the handle for each supported video port using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code> <code>dsERR_NONE</code> Should be successful 03 enable the video port using <code>dsEnableVideoPort</code> handle = obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code> Should be successful 04 Verify the status of each port using <code>dsIsVideoPortEnabled</code> handle = obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code>, enabled = true Should be successful 05 disabled port using <code>dsEnableVideoPort</code> handle = obtained from <code>dsGetVideoPort</code>, enabled = false <code>dsERR_NONE</code> Should be successful 06 Verify the status of each port using <code>dsIsVideoPortEnabled</code> handle = obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code>, enabled = false Should be successful 07 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit API] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    A --&gt;|Not dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|D[Call dsEnableVideoPort API with true]\n    D --&gt;|dsERR_NONE|E[verify the port is true with dsIsVideoPortEnabled]\n    E --&gt;|check Enabled flag is true|F[Call dsEnableVideoPort API with false]\n    F --&gt;|dsERR_NONE|G[verify the port is false with dsIsVideoPortEnabled]\n    G --&gt;|Not dsERR_NONE|A4[Test case fail]\n    G --&gt; B\n    B --&gt;|End of loop|I[Call dsVideoPortTerm API]\n    I --&gt;|dsERR_NONE|J[Test case success]\n    I --&gt;|Not dsERR_NONE|I1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_dsVideoPort_VerifyDisplayAndPortStatus</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code> .Verify the connected/disconnected status of each supported port's display when no video port is connected. Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code> <code>dsERR_NONE</code> Should be successful 03 Check if the display is connected for the obtained video port handle using <code>dsIsDisplayConnected</code> handle = obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code>, connected = false Should be successful 04 Check if the video port is active for the obtained video port handle using <code>dsIsVideoPortActive</code> handle = obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code>, active = false Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    A --&gt;|Not dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsIsDisplayConnected for each handle]\n    C --&gt;|dsERR_NONE and connected is false|D[Call dsIsVideoPortActive for each handle]\n    D --&gt;|Not dsERR_NONE|A2[Test case fail]\n    D --&gt;|dsERR_NONE and enabled flag is true|B\n    B --&gt;|End of loop|I[Call dsVideoPortTerm API]\n    I --&gt;|dsERR_NONE|J[Test case success]\n    I --&gt;|Not dsERR_NONE|I1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_dsVideoPort_RetrieveAndVerifySurroundModeCapabilities</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Retrieve the surround mode capabilities of each supported port and verify them with the configuration file. If it is a sink device, retrieve the value from 'configuration file using the path <code>dsVideoPort/Ports/[port no]/Display_surround</code> since the sink device has only an INTERNAL port. It is not supported for the source devices. Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-3","title":"Test Procedure - Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code> <code>dsERR_NONE</code> Should be successful 03 Check if the display is in surround mode using <code>dsIsDisplaySurround</code> with the obtained handle handle = obtained from previous step <code>dsERR_NONE</code> Should be successful 04 Verify if the surround mode from previous step matches with the configuration file get_surround = <code>dsVideoPort/Ports/[port no]/Display_surround</code> None Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsVideoPortInit API]\n    Step1 --&gt;|dsERR_NONE|Step2{For each supported &lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 --&gt;|Not dsERR_NONE|Fail1[Test Case Failed]\n    Step2 --&gt;|dsERR_NONE and valid handle|Step3[Call dsIsDisplaySurround API]\n    Step3 --&gt;|dsERR_NONE and boolean value|Step4[Retrieve surround mode capabilities]\n    Step4 --&gt;|Not dsERR_NONE|Step5[Verify if dsIsDisplaySurround value matches with configuration file value]\n    Step5 --&gt;|loop through |Step2\n    Step2 --&gt;|End of loop|Step6[Call dsVideoPortTerm API]\n    Step5 --&gt;|Not match|Fail6[Test Case Failed]\n    Step6 --&gt;|dsERR_NONE|End[Test Case Passed]\n    Step6 --&gt;|Not dsERR_NONE|Fail5[Test Case Failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-4","title":"Test 4","text":"Title Details Function Name <code>test_l2_dsVideoPort_SetAndGetResolution_source</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Set properties for each supported video port, including pixel resolution, aspect ratio, stereoscopic modes, frame rates, and scan modes, looping through supported values. Verify the settings using the get function. Test Group 02 Test Case ID 004 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-4","title":"Test Procedure - Test 4","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> Loop through each video port and get the handle using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code>. <code>dsERR_NONE</code> Should be successful 03 Loop through all possible pixel resolutions, aspect ratios, stereoscopic modes, frame rates, and scan modes pixelResolution = <code>dsVIDEO_PIXELRES_720x480</code> to <code>dsVIDEO_PIXELRES_MAX</code>, aspectRatio = <code>dsVIDEO_ASPECT_RATIO_4x3</code> to <code>dsVIDEO_ASPECT_RATIO_MAX</code>, stereoScopicMode = <code>dsVIDEO_SSMODE_UNKNOWN</code> to <code>dsVIDEO_SSMODE_MAX</code>, frameRate = <code>dsVIDEO_FRAMERATE_UNKNOWN</code> to <code>dsVIDEO_FRAMERATE_MAX</code>, interlaced = false <code>dsERR_NONE</code> Should be successful 04 Set resolution using <code>dsSetResolution</code> with handle and setResolution handle, &amp;setResolution <code>dsERR_NONE</code> Should be successful 05 Get resolution using <code>dsGetResolution</code> with handle and getResolution handle, &amp;getResolution <code>dsERR_NONE</code> Should be successful 06 Compare setResolution and getResolution setResolution, getResolution Equal values for all properties Should be successful 07 Terminate video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    A --&gt;|Not dsERR_NONE|A1[Test case Fail]\n    B --&gt;|Not dsERR_NONE|E[Set supported values&lt;br&gt; using dsSetResolution API]\n    E --&gt;|Not dsERR_NONE| F[Get values using dsGetResolution API]\n    F --&gt;|Not dsERR_NONE|G[Compare returned and set resolution]\n    G --&gt;|loop through | B\n    G --&gt;|Not dsERR_NONE|I1[Test case Fail]\n    B --&gt;|End of Iteration| I[Call dsVideoPortTerm]\n    I --&gt;|dsERR_NONE|J[Test case Success]\n    I --&gt;|Not dsERR_NONE|I2[Test case Fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-5","title":"Test 5","text":"Title Details Function Name <code>test_l2_dsVideoPort_VerifySupportedTvResolutions</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Gets the supported port Resolutions of TV and verify with the configuration file <code>dsVideoPort/Ports/[port no]/Supported_tv_resolutions_capabilities</code> Test Group 02 Test Case ID 005 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-5","title":"Test Procedure - Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> Loop through each video port and get the handle using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code>. <code>dsERR_NONE</code> Should be successful 03 Get the supported TV resolutions using <code>dsSupportedTvResolutions</code> with the obtained handle handle = obtained from previous step <code>dsERR_NONE</code> Should be successful 04 Verify the obtained resolutions with the expected resolutions from the configuration file resolutions = value in <code>dsVideoPort/Ports/[port no]/Supported_tv_resolutions_capabilities</code> <code>dsERR_NONE</code> Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsVideoPortInit API]\n    Step1 -- dsERR_NONE --&gt; Step2{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 -- Not dsERR_NONE --&gt; Fail1[Test case fail]\n    Step2 -- dsERR_NONE and valid handle --&gt; Step3[Call dsSupportedTvResolutions API]\n    Step3 -- dsERR_NONE and valid resolutions --&gt; Step4[Verify if resolutions match with configuration file value]\n    Step4 --&gt;|loop through | Step2\n    Step4 -- Not Match --&gt; Fail2[Test case fail]\n    Step2 --&gt;|End of Iteration| Step5[Call dsVideoPortTerm API]\n    Step5 -- dsERR_NONE --&gt; End[Test Case Passed]\n    Step5 -- Not dsERR_NONE --&gt; Fail5[Test Case Failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-6","title":"Test 6","text":"Title Details Function Name <code>test_l2_dsVideoPort_GetHDRCapabilities</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Get the each supported port HDR capabilities &amp; verify with the configuration file <code>dsVideoPort/Ports/[port no]/hdr_capabilities</code> Test Group 02 Test Case ID 006 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-6","title":"Test Procedure - Test 6","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using dsGetVideoPort Loop through each video port and get the handle using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code>. <code>dsERR_NONE</code> Should be successful 03 Get the HDR capabilities of the TV using <code>dsGetTVHDRCapabilities</code> with the obtained handle handle = obtained from previous step <code>dsERR_NONE</code> Should be successful 04 Verify the obtained capabilities with the configuration file <code>dsVideoPort/Ports/[port no]/hdr_capabilities</code> Values should match capabilities = value in <code>dsVideoPort/Ports/[port no]/hdr_capabilities</code> Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit API] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    A --&gt;|Not dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsGetTVHDRCapabilities API with handle]\n    C --&gt;|dsERR_NONE|D[Verify if output matches with value from configuration file]\n    D --&gt;|Not dsERR_NONE|A2[Test case fail]\n    D --&gt;|loop through | B\n    B --&gt;|End of Iteration| E[Call dsVideoPortTerm API]\n    E --&gt;|dsERR_NONE|F[Test case success]\n    E --&gt;|Not dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-7","title":"Test 7","text":"Title Details Function Name <code>test_l2_dsVideoPort_GetHDCPStatus</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Check the <code>HDCP</code> status of each supported port and verify if <code>dsHDCP_STATUS_AUTHENTICATED</code> is returned for sinks and <code>dsHDCP_STATUS_UNPOWERED</code>/<code>dsHDCP_STATUS_PORTDISABLED</code> is returned for sources. Test Group 02 Test Case ID 007 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-7","title":"Test Procedure - Test 7","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> Loop through each video port and get the handle using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code>. <code>dsERR_NONE</code> Should be successful 03 Get the <code>HDCP</code> status for each handle using <code>dsGetHDCPStatus</code> handle = obtained from dsGetVideoPort() <code>dsERR_NONE</code> Should be successful 04 Check if the <code>HDCP</code> status is authenticated status = obtained from <code>dsGetHDCPStatus</code> <code>dsHDCP_STATUS_AUTHENTICATED</code> Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit API] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    A --&gt;|Not dsERR_NONE|A1[Test Case Fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsGetHDCPStatus API with handle]\n    C --&gt;|dsERR_NONE and HDCP status|D[Verify HDCP status is dsHDCP_STATUS_AUTHENTICATED]\n    D --&gt;|Not dsERR_NONE|E2[Test Case Fail]\n    D --&gt;|Iterate through all possible values|B\n    B --&gt;|End of loop|E[Call dsVideoPortTerm API]\n    E --&gt;|dsERR_NONE|F[Test Case Success]\n    E --&gt;|Not dsERR_NONE|E1[Test Case Fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-8","title":"Test 8","text":"Title Details Function Name <code>test_l2_dsVideoPort_VerifyHDCPProtocolStatus</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Check the <code>HDCP</code> protocol status of each supported port and verify it with the configuration file <code>dsVideoPort/Ports/[port no]/hdcp_protocol_version</code> supported by <code>HDMI</code> port. Test Group 02 Test Case ID 008 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-8","title":"Test Procedure - Test 8","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> Loop through each video port and get the handle using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code>. <code>dsERR_NONE</code> Should be successful 03 Get the HDCP protocol version using <code>dsGetHDCPProtocol</code> with the obtained handle handle = obtained from previous step <code>dsERR_NONE</code> Should be successful 04 Verify the obtained protocol version with the value from the configuration file protocolVersion = <code>dsVideoPort/Ports/[port no]/hdcp_protocol_version</code> <code>dsERR_NONE</code> Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsVideoPortInit API]\n    Step1 -- dsERR_NONE --&gt; Step2{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 -- Not dsERR_NONE --&gt; Fail1[Test Case Failed]\n    Step2 -- dsERR_NONE and valid handle --&gt; Step3[Call dsGetHDCPProtocol API and get HDCP protocol version]\n    Step3 -- dsERR_NONE --&gt; Step5[Compare the version with the value from configuration file ]\n    Step5 --&gt;|loop through | Step2\n    Step5 -- Not dsERR_NONE --&gt; Fail3[Test Case Failed]\n    Step2 --&gt;|End of Iteration| Step6[Call dsVideoPortTerm API]\n    Step6 -- dsERR_NONE --&gt; End[Test Case Passed]\n    Step6 -- Not dsERR_NONE --&gt; Fail6[Test Case Failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-9","title":"Test 9","text":"Title Details Function Name <code>test_l2_dsVideoPort_SetAndGetHdmiPreference</code> Description Get the handle for supported video port from configuration file(<code>dsVideoPort/Number_of_ports</code>), check the status of each supported video port type <code>dsVideoPort/Ports/[port no]/Typeid</code>.Set the HDMI preference    for each valid port and verify it using the get function. Test Group 02 Test Case ID 009 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-9","title":"Test Procedure - Test 9","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle for supported type of video port using <code>dsGetVideoPort</code> Loop through each video port and get the handle using <code>dsGetVideoPort</code> type = <code>dsVideoPort/Ports/[port no]/Typeid</code> index = <code>dsVideoPort/Ports/[port no]/Index</code>. <code>dsERR_NONE</code> Should be successful 03 Get the <code>HDCP</code> protocol version using <code>dsGetHDCPProtocol</code> with the obtained handle handle = obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code> Should be successful 04 Verify the <code>HDCP</code> protocol version with the value from the configuration file protocolVersion = value <code>dsVideoPort/Ports/[port no]/hdcp_protocol_version</code> <code>dsERR_NONE</code> Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit] --&gt;|return dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    B --&gt;|return dsERR_NONE and valid handle|D[Call dsSetHdmiPreference&lt;br&gt; to set supported protocol version]\n    A --&gt;|Not dsERR_NONE|C[Test case fail]\n    D --&gt;|dsERR_NONE|F[Call dsGetHdmiPreference API]\n    F --&gt;|Not dsERR_NONE|A2[Test case fail]\n    F --&gt;|loop through | B\n    B --&gt;|End of Iteration|J[Call dsVideoPortTerm API]\n    J --&gt;|dsERR_NONE|K[Test case success]\n    J --&gt;|Not dsERR_NONE|L[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-10","title":"Test 10","text":"Title Details Function Name <code>test_l2_dsVideoPort_GetColorSpace</code> Description Get each port Color Space, compare with the configuration file. Test Group 02 Test Case ID 010 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-10","title":"Test Procedure - Test 10","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get video port handle using <code>dsGetVideoPort</code> with type as <code>dsVIDEOPORT_TYPE_INTERNAL</code> and index as 0 type = <code>dsVIDEOPORT_TYPE_INTERNAL</code>, index = 0 <code>dsERR_NONE</code> Should be successful 03 Get color space using <code>dsGetColorSpace</code> with handle obtained from previous step handle = handle obtained from step 02 <code>dsERR_NONE</code> Should be successful 04 Compare the obtained color space with the value from the configuration file color_space = value in <code>dsVideoPort/Ports/[port no]/colorspaces</code> Value from the configuration file Should be successful 05 Terminate video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\nA[Call dsVideoPortInit] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\nA --&gt;|Not dsERR_NONE|A1[Test case fail]\nB --&gt;|dsERR_NONE and valid handle|C[Call dsGetColorSpace API]\nC --&gt;|dsERR_NONE|D[Compare color space &lt;br&gt;with value from profile file]\nD --&gt;|loop through | B\nD --&gt;|dsERR_NONE|E2[Test case fail]\nB --&gt;|End of Iteration| E[Call dsVideoPortTerm]\nE --&gt;|dsERR_NONE|F[Test case success]\nE --&gt;|dsERR_NONE|E1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-11","title":"Test 11","text":"Title Details Function Name <code>test_l2_dsVideoPort_CheckColorDepthCapabilities_source</code> Description Check each port Color Depth Capabilities and compare with the configuration file. Test Group 02 Test Case ID 011 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-11","title":"Test Procedure - Test 11","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle using <code>dsGetVideoPort</code> with <code>dsVIDEOPORT_TYPE_HDMI</code> and index 0 <code>dsVIDEOPORT_TYPE_HDMI</code>, 0 <code>dsERR_NONE</code> Should be successful 03 Check the color depth capabilities using <code>dsColorDepthCapabilities</code> with the obtained handle handle <code>dsERR_NONE</code> Should be successful 04 Compare the obtained color depth capability with the value from the configuration file colorDepthCapability = value in <code>dsVideoPort/Ports/[port no]/Supported_color_depth_capabilities</code> Check if equal Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsVideoPortInit] --&gt;|dsERR_NONE| Step2{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 -- \"Not dsERR_NONE\" --&gt; Fail1[Test Case Failed]\n    Step2 -- \"dsERR_NONE and valid handle\" --&gt; Step3[Call dsColorDepthCapabilities API with handle]\n    Step3 -- \"dsERR_NONE\" --&gt; Step4[Compare if value retrieved &lt;br&gt;from API and configuration file matches]\n    Step4 --&gt;|loop through | Step2\n    Step4 -- \"dsERR_NONE\" --&gt; Fail6[Test Case Failed]\n    Step2 --&gt;|End of Iteration| Step6[Call dsVideoPortTerm API]\n    Step6 -- \"dsERR_NONE\" --&gt; End[Test Case Passed]\n    Step6 -- \"Not dsERR_NONE\" --&gt; Fail4[Test Case Failed]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-12","title":"Test 12","text":"Title Details Function Name <code>test_l2_dsVideoPort_GetColorDepth</code> Description Get each port Color Depth and verify with the configuration file. Test Group 02 Test Case ID 012 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-12","title":"Test Procedure - Test 12","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle using <code>dsGetVideoPort</code> with type=<code>dsVIDEOPORT_TYPE_INTERNAL</code> and index=0 type=<code>dsVIDEOPORT_TYPE_INTERNAL</code>, index=0 <code>dsERR_NONE</code> Should be successful 03 Get the color depth using <code>dsGetColorDepth</code> with the obtained handle handle=obtained handle <code>dsERR_NONE</code> Should be successful 04 Verify the obtained color depth with the value from the configuration file color_depth=value in <code>dsVideoPort/Ports/[port no]/Supported_color_depth_capabilities</code> Should be equal Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    A[Call dsVideoPortInit] --&gt;|dsERR_NONE|B{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    A --&gt;|Not dsERR_NONE|A1[Test case fail]\n    B --&gt;|dsERR_NONE and valid handle|C[Call dsGetColorDepth with handle from previous step]\n    C --&gt;|dsERR_NONE|D[Compare the color depth &lt;br&gt;values from API and configuration file]\n    D --&gt;|loop through | B\n    D --&gt;|dsERR_NONE|E2[Test case fail]\n    B --&gt;|End of Iteration| F[Call dsVideoPortTerm]\n    F --&gt;|dsERR_NONE|G[Test case success]\n    F --&gt;|Not dsERR_NONE|F1[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-13","title":"Test 13","text":"Title Details Function Name <code>test_l2_dsVideoPort_SetAndGetPreferredColorDepth_source</code> Description Set preferred color depth for each port and compare get function Test Group 02 Test Case ID 013 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-13","title":"Test Procedure - Test 13","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get video port handle for each port type using <code>dsGetVideoPort</code> type = <code>dsVIDEOPORT_TYPE_RF</code> to <code>dsVIDEOPORT_TYPE_MAX</code>, index = 0 <code>dsERR_NONE</code> Should be successful 03 Set preferred color depth for each color depth type using <code>dsSetPreferredColorDepth</code> handle = from step 02, colorDepthSet = <code>dsDISPLAY_COLORDEPTH_8BIT</code> to <code>dsDISPLAY_COLORDEPTH_AUTO</code> <code>dsERR_NONE</code> Should be successful 04 Get preferred color depth using <code>dsGetPreferredColorDepth</code> handle = from step 02, colorDepthGet <code>dsERR_NONE</code> Should be successful 05 Compare set and get color depth colorDepthSet = colorDepthGet colorDepthSet should be equal to colorDepthGet Should be successful 06 Terminate video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Step1[Call dsVideoPortInit] --&gt;|dsERR_NONE| Step2{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 -- \"Not dsERR_NONE\" --&gt; Fail1[Test Case Failed]\n    Step2 --&gt;|dsERR_NONE and valid handle|Step3[Call dsSetPreferredColorDepth API]\n    Step3 --&gt;|dsERR_NONE|Step4[Call dsGetPreferredColorDepth API]\n    Step4 --&gt;|dsERR_NONE|Step5[Compare color depth values]\n    Step5 --&gt;|loop through | Step2\n    Step5 -- \"dsERR_NONE\" --&gt; Fail6[Test Case Failed]\n    Step2 --&gt;|End of Iteration|Step7[Call dsVideoPortTerm API]\n    Step7 --&gt;|dsERR_NONE|End[Test Case success]\n    Step7 --&gt;|Failure|TestcaseFail6[Testcase Fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-14","title":"Test 14","text":"Title Details Function Name <code>test_l2_dsVideoPort_GetQuantizationRange</code> Description Get each port QuantizationRange status and verify with the configuration file. Test Group 02 Test Case ID 014 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-14","title":"Test Procedure - Test 14","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port handle using <code>dsGetVideoPort</code> with <code>dsVIDEOPORT_TYPE_INTERNAL</code> as type and 0 as index type = <code>dsVIDEOPORT_TYPE_INTERNAL</code>, index = 0 <code>dsERR_NONE</code> Should be successful 03 Get the Quantization Range using <code>dsGetQuantizationRange</code> with the handle obtained from previous step handle = obtained from step 02 <code>dsERR_NONE</code> Should be successful 04 Verify the Quantization Range with the value from the configuration file quantization_range = value in <code>dsVideoPort/Ports/[port no]/quantization_ranges</code> Should be equal Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Start(Start) --&gt; Step1[Call dsVideoPortInit]\n    Step1 -- dsERR_NONE --&gt; Step2{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 -- Not dsERR_NONE --&gt; TestcaseFail1[Test case fail]\n    Step2 -- dsERR_NONE and valid handle --&gt; Step3[Call dsGetQuantizationRange with handle]\n    Step3 -- dsERR_NONE and valid quantization range --&gt; Step4[Compare quantization &lt;br&gt;range with configuration file]\n    Step4 --&gt;|loop through | Step2\n    Step4 -- Not dsERR_NONE --&gt; TestcaseFail5[Test case fail]\n    Step2  --&gt; |End of Iteration|Step5[Call dsVideoPortTerm]\n    Step5 -- dsERR_NONE --&gt; End[Test case success]\n    Step5 -- Not dsERR_NONE --&gt; TestcaseFail6[Test case fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-15","title":"Test 15","text":"Title Details Function Name <code>test_l2_dsVideoPort_GetMatrixCoefficients</code> Description Get each port MatrixCoefficients status and verify return <code>dsDISPLAY_MATRIXCOEFFICIENT_UNKNOWN</code> for source and with the configuration file. Test Group 02 Test Case ID 015 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L2_Low-Level_TestSpecification/#test-procedure-test-15","title":"Test Procedure - Test 15","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the video port using <code>dsVideoPortInit</code> None <code>dsERR_NONE</code> Should be successful 02 Get the video port with type=<code>dsVIDEOPORT_TYPE_INTERNAL</code> and index=1 using <code>dsGetVideoPort</code> type=<code>dsVIDEOPORT_TYPE_INTERNAL</code>, index=1 <code>dsERR_NONE</code> Should be successful 03 Get the Matrix Coefficients with handle obtained from <code>dsGetVideoPort</code> using <code>dsGetMatrixCoefficients</code> handle=handle obtained from <code>dsGetVideoPort</code> <code>dsERR_NONE</code> Should be successful 04 Verify the Matrix Coefficients with the value from the configuration file matrix_coefficients=<code>dsVideoPort/Ports/[port no]/matrix_coefficients</code> Should be equal Should be successful 05 Terminate the video port using <code>dsVideoPortTerm</code> None <code>dsERR_NONE</code> Should be successful <pre><code>graph TB\n    Start(Start) --&gt; Step1[Call dsVideoPortInit]\n    Step1 -- dsERR_NONE --&gt; Step2{For each supported&lt;br&gt; type and index &lt;br&gt; call dsGetVideoPort}\n    Step1 -- Not dsERR_NONE --&gt; TestcaseFail1[Test case fail]\n    Step2 -- dsERR_NONE and valid handle --&gt; Step3[Call dsGetMatrixCoefficients with handle]\n    Step3 -- dsERR_NONE --&gt; Step4[Compare the retrieved matrix_coefficients&lt;br&gt; with value from configuration file]\n    Step4 --&gt;|loop through | Step2\n    Step4 -- Not dsERR_NONE --&gt; Fail7[Test Case Fail]\n    Step2 --&gt;|End of Iteration| Step6[Call dsVideoPortTerm]\n    Step6 -- dsERR_NONE --&gt; End[Test Case Success]\n    Step6 -- Not dsERR_NONE --&gt; Fail6[Test Case Fail]</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/","title":"Device Settings Video Port L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 3 Test cases High Level Overview</li> <li>Level 3 Python Test Cases High Level Overview</li> <li>L3 Test Procedure Documentation</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Low Level Test Specification and Procedure Documentation for the Device Settings Video Port module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HDMI</code>- High-Definition Multimedia Interface</li> <li><code>HDCP</code>- High-bandwidth Digital Content Protection</li> <li><code>HDR</code> - High Dynamic Range</li> <li><code>HLG</code> - Hybrid Log-Gamma</li> <li><code>SDR</code> - Standard Dynamic Range</li> <li><code>Y</code>   - yes supported</li> <li><code>NA</code>  - Not Supported</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsVideoPort High Level TestSpec</li> <li><code>Interface header</code> - dsVideoPort HAL header</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"# Streams Name Streams description 1 vts_HDR10_stream Format: HDR10,Resolution: 3840 x 2160 (4K UHD),Color Depth: 10-bit,Color Space: Rec. 2020 2 vts_SDR_stream Format: SDR,Resolution: 1920 x 1080 3 vts_HLG_stream Format: HLG,Resolution: 3840 x 2160 or It can also be used with 1080p and 720p resolutions. 4 vts_DolbyVision_stream Format: Dolby Vision,Resolution: 3840 x 2160 (4K UHD),Color Depth: 10/12-bit,Color Space: Rec. 2020format and dynamic metadata. 5 vts_HDR10plus_stream Format: HDR10,Resolution: 3840 x 2160 (4K UHD),Color Depth: 10-bit,Color Space: Rec. 2020 and dynamic metadata capabilities. <p>Each test case need to verify with the each supported video port. Below are top test use-case for the video port.</p> # Test-case Description HAL APIs Source Sink Streams Number 1 Verify the Video content Formats with callbacks Play the pre-defined streams with different video content format(<code>HDR</code>,<code>HLG</code>,DolbyVision,..) and check the callbacks is triggered when the video content format changes <code>dsVideoFormatUpdateRegisterCB()</code> <code>dsGetVideoEOTF()</code> <code>NA</code> <code>Y</code> 1,2,3,4,5 2 Check DisplayConnected Verify the Display by enabling and disable each supported video port <code>dsEnableVideoPort()</code> <code>dsIsDisplayConnected()</code> <code>dsIsVideoPortActive()</code> <code>Y</code> <code>Y</code> 1 3 Select the <code>HDCP</code> Version Select the Supported <code>HDCP</code> version and verify <code>dsSetHdmiPreference()</code> <code>Y</code> <code>Y</code> <code>NA</code> 4 Verify the Resolution for source Play the pre-defined stream and set supported resolution and verify the resolution of the TV <code>dsSetResolution()</code> <code>Y</code> <code>NA</code> <code>NA</code> 5 Verify the <code>HDCP</code> status using callbacks for Source Power off and power on TV or pug/unplug <code>HDMI</code> and Check the <code>HDCP</code> status using callbacks(i.e.UNPOWERED,AUTHENTICATED,..) <code>dsEnableHDCP()</code> <code>Y</code> <code>NA</code> <code>NA</code> 6 Select video content formats for Source Select the Supported <code>HDR</code> modes &amp; Verify the video content formats using callbacks <code>dsSetForceHDRMode()</code> <code>Y</code> <code>NA</code> 1,2,3,4,5 7 Resets the video output to <code>SDR</code> for Source Play the <code>HDR</code> stream and verify the video content formats <code>dsResetOutputToSDR()</code> <code>Y</code> <code>NA</code> 1 8 Select preferred color depth for Source Select the Color depth from Supported list &amp; verify <code>dsSetPreferredColorDepth()</code> <code>Y</code> <code>NA</code> <code>NA</code> 9 sets the background color for Source Select the background color form supported list &amp; verify <code>dsSetBackgroundColor()</code> <code>Y</code> <code>NA</code> <code>NA</code>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of dsVideoPort L3 Python test cases:</p> <pre><code>---\ntitle: dsVideoPort - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- L3_TestHelperClass : inherits\n    L3_TestHelperClass ..&gt; dsVideoPort : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for dsVideoPort \"uses platformProfile.yaml\"\n    note for L3_TestHelperClass \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>dsVideoPort</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestHelperClass</li> <li>Each test class uses HelperClass to write a test case define in L3 Test use-cases.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file dsVidePort Profile</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file dsVideoPort_L3_testSetup.yml</p> </li> <li> <p>testSuite.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file dsVideoPort_testConfig.yml</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Low-Level_TestSpecification/#l3-test-procedure-documentation","title":"L3 Test Procedure Documentation","text":"<ul> <li>L3 test procedure doc</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/","title":"Device Settings Video Port L3 Test Case and Procedure Documentation","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Setting Up Test Environment</li> <li>Test Case Procedure</li> <li>dsVideoPort_test1_VerifyVideoContent_Format_Callback.py</li> <li>dsVideoPort_test2_EnableDisableAndVerifyPortStatus.py</li> <li>dsVideoPort_test3_VerifyHDCP_Version.py</li> <li>dsVideoPort_test4_VerifyResolution.py</li> <li>dsVideoPort_test5_VerifyHDCP_Callback.py</li> <li>dsVideoPort_test6_VerifyVideoContentFormats.py</li> <li>dsVideoPort_test7_ResetToSDRMode.py</li> <li>dsVideoPort_test8_VerifyColorDepth.py</li> <li>dsVideoPort_test9_VerifyBackgroundColor.py</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#overview","title":"Overview","text":"<p>This document describes the L3 Test case Procedure Documentation for the Device Settings Video Port module.</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code> - Original Equipment Manufacture</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HDMI</code>- High-Definition Multimedia Interface</li> <li><code>HDCP</code>- High-bandwidth Digital Content Protection</li> <li><code>HDR</code> - High Dynamic Range</li> <li><code>HLG</code> - Hybrid Log-Gamma</li> <li><code>SDR</code> - Standard Dynamic Range</li> <li><code>Y</code>   - yes supported</li> <li><code>NA</code>  - Not Supported</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - dsVideoPort High Level TestSpec</li> <li><code>dsVideoPort L3 Low Level Test Specification</code> - dsVideoPort L3 LowLevel TestSpec</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#rack-configuration-file","title":"Rack Configuration File","text":"<ul> <li>It identifies the rack configuration and platform used. We need to update our target device specif information in the rackconfig.yaml. In this file, update the configuration to define the console sessions for the device under test (DUT) Example Rack configuration File: <code>ut/host/tests/configs/example_rack_config.yml</code></li> <li>For more details refer RAFT and example_rack_config.yml</li> </ul> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases. ssh_player Plays the stream required for test case. ssh_hal_test Executes the HAL binary for the test case. <p>```yaml rackConfig:   - dut:       ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device       description: \"stb device under test\"       platform: \"stb\"       consoles:         - default:             type: \"ssh\"             port: 10022             username: \"root\"             ip: \"XXX.XXX.XXX\" # IP address of the device             password: ' '         - ssh_player:             type: \"ssh\"             port: 10022             username: \"root\"             ip: \"XXX.XXX.XXX\" # IP address of the device             password: ' '         - ssh_hal_test:             type: \"ssh\"             port: 10022             username: \"root\"             ip: \"XXX.XXX.XXX\" # IP address of the device             password: ' '       outbound:         download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device         upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location         upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"         httpProxy:   # Local proxy if required         workspaceDirectory: './logs/workspace'   # Local working directory</p> <pre><code>#### Device Configuration File\n\n  Example Device configuration File: `ut/host/tests/configs/deviceConfig.yml`\n\nFor more details refer [RAFT](https://github.com/rdkcentral/python_raft/blob/1.0.0/README.md) and [example_device_config.yml](https://github.com/rdkcentral/python_raft/blob/1.0.0/examples/configs/example_device_config.yml)\n\nUpdate the target directory where `HAL` binaries will be copied into the device. Also, map the profile to the source/sink settings `YAML` file path.\n\nEnsure the platform should match with the `DUT` platform in [Rack Configuration](#rack-configuration-file)\n\n```yaml\ndeviceConfig:\n    cpe1:\n        platform: \"xi-one\"\n        model: \"uk\"\n        soc_vendor: \"realtek\"\n        target_directory: \"/opt/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            #TODO: Use the single profile file which contains all details (ds, hdmi, etc)\n            profile: \"../../../../profiles/source/Source_4K_VideoPort.yaml\"\n            streams_download_url: \"\" #URL path from which the streams are downloaded to the device\n</code></pre> <ul> <li>Example Device Config file: deviceConfig.yml.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Each test case requires a stream name to be provided if required. If a test case involves multiple streams or requires validation using several streams, ensure that all necessary streams are added sequentially under the specific test case.</p> <p>The URL paths for the streams are defined in the deviceConfig.yml file, under the parameter <code>streams_download_url</code></p> <ul> <li>Example configuration file dsVideoPort_L3_testSetup.yml.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#test-suite-configuration","title":"Test Suite Configuration","text":"<p>Update the execute command according to the device path where <code>HAL</code> binaries are copied and Update the test suite for each level test case</p> <ul> <li>Example configuration file: dsVideoPort_testConfig.yml.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#test-case-procedure","title":"Test Case Procedure","text":""},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test1_verifyvideocontent_format_callbackpy","title":"dsVideoPort_test1_VerifyVideoContent_Format_Callback.py","text":"<p>Overview:</p> <p>This test plays pre-defined streams in various video content formats (HDR, HLG, Dolby Vision, etc.) and checks if the appropriate callbacks are triggered when the video format changes.</p> <p>Platform Supported:</p> <p>Sink</p> <p>User Input Required:</p> <p>No</p> <p>Acceptance Criteria:</p> <p>Play the pre-defined streams with different video content formats (HDR, HLG, Dolby Vision, etc.) and check that the callbacks are triggered when the video content format changes.</p> <p>Expected Results:</p> <p>The test will download and play multiple streams, each corresponding to a specific video format, and verify that the expected callbacks are triggered. After playback, the streams will be removed, and the test will pass if all expected callbacks are received.</p> <p>Test Steps:</p> <ul> <li>Run the Python file dsVideoPort_test1_VerifyVideoContent_Format_Callback.py with the required configuration:</li> </ul> <pre><code>dsVideoPort_test1_VerifyVideoContent_Format_Callback.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will download the required assets and begin execution, playing streams in various formats.</li> <li>For each video format, the test will verify that the appropriate callbacks are triggered:</li> <li>NONE Video Format Callback</li> <li><code>HDR10</code> Video Format Callback</li> <li><code>HLG</code> Video Format Callback</li> <li><code>Dolby Vision</code> Video Format Callback</li> <li><code>HDR10PLUS</code> Video Format Callback</li> <li><code>SDR</code> Video Format Callback</li> <li>The test will pass if all the required callbacks are detected; otherwise, it will fail.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test2_enabledisableandverifyportstatuspy","title":"dsVideoPort_test2_EnableDisableAndVerifyPortStatus.py","text":"<p>Overview:</p> <p>This test enables and disables video ports, requiring manual user interaction to verify if the video is displayed when the port is enabled, and if the display is blank when the port is disabled. The user is asked to confirm the video playback status.</p> <p>Platform Supported:</p> <p>Source, Sink</p> <p>User Input Required:</p> <p>Yes:User input is required to verify whether the video is playing or not with prompt question <code>Is Video Display on the port? (Y/N)</code> (This will be automated later).</p> <p>Acceptance Criteria:</p> <p>Verify the Display by enabling and disable each supported video port.</p> <p>Expected Results:</p> <p>The video is visible when the port is enabled and goes blank when the port is disabled. User responses (Y/N) will determine if the test passes.</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test2_EnableDisableAndVerifyPortStatus.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test2_EnableDisableAndVerifyPortStatus.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will download all required artifacts and streams, copy them to the target directory, and start execution.</li> <li>The test will play the stream, enable the video port, and ask the user to confirm the video playback status. It will then disable the port and ask the user to confirm that the display is blank.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test3_verifyhdcp_versionpy","title":"dsVideoPort_test3_VerifyHDCP_Version.py","text":"<p>Overview:</p> <p>This test is designed to verify the correct <code>HDCP</code> version used during video playback. The test will specifically enable <code>HDCP</code> 2.2 encryption and ask the user to confirm the version displayed using an AV analyzer connected to the video output. The user must verify if the correct <code>HDCP</code> version is being used.</p> <p>Platform Supported:</p> <p>Source, Sink</p> <p>User Input Required:</p> <p>Yes: The user is required to verify the <code>HDCP</code> version on an external AV analyzer connected to the device. (This will be automated later).</p> <p>Acceptance Criteria:</p> <p>The test must successfully enable HDCP 2.2 encryption, and the user must confirm that HDCP 2.X is displayed on the AV analyzer for the test to pass.</p> <p>Expected Results:</p> <p>The test will enable HDCP 2.2 encryption on the video output. The user will confirm the correct HDCP version using a supported AV analyzer, ensuring proper encryption is applied.</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test3_VerifyHDCP_Version.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test3_VerifyHDCP_Version.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>Download and copy all required assets to the target directory.</li> <li>Enable HDCP 2.2 encryption on the video output.</li> <li>Prompt the user to verify that HDCP 2.X is displayed on the AV analyzer.</li> <li>The test will pass if the user confirms that the correct HDCP version is being used.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test4_verifyresolutionpy","title":"dsVideoPort_test4_VerifyResolution.py","text":"<p>Overview:</p> <p>This test verifies the resolution settings supported by the source device. It sets different resolutions and checks additional parameters, including aspect ratio, SS mode, frame rate, and scan mode. The user must confirm the accuracy of these settings using an AV analyzer connected to the video output. The test involves manual verification of video parameters displayed on the AV analyzer.</p> <p>Platform Supported:</p> <p>Source</p> <p>User Input Required:</p> <p>Yes: The user must verify the video resolution and other attributes (aspect ratio, SS mode, frame rate, scan mode) using a connected AV analyzer. (This will be automated later).</p> <p>Acceptance Criteria:</p> <p>The user verifies that the correct resolution, aspect ratio, SS mode, frame rate, and scan mode are displayed on the AV analyzer for each tested video resolution.</p> <p>Expected Results:</p> <p>The test sets various resolutions on the video output and prompts the user to confirm the correctness of the settings via an AV analyzer. If all settings match, the test will pass</p> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test4_VerifyResolution.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test4_VerifyResolution.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will download the required artifacts and streams, then copy them to the target directory.</li> <li>For each supported resolution, the test will set the following parameters and prompt the user for confirmation using an AV analyzer:</li> <li>Resolution (e.g., 720x480, 1920x1080)</li> <li>Aspect Ratio (e.g., 4:3, 16:9)</li> <li>SS Mode (e.g., 2D, 3D)</li> <li>Frame Rate (e.g., 29.97, 60 Hz)</li> <li>Scan Mode (e.g., Interlaced, Progressive)</li> <li>The test will repeat step 3 for all supported resolutions.</li> <li>If the user confirms the correct settings for all resolutions and parameters, the test will pass.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test5_verifyhdcp_callbackpy","title":"dsVideoPort_test5_VerifyHDCP_Callback.py","text":"<p>Overview:</p> <p>This test verifies <code>HDCP</code> status using callbacks during HDMI plug and unplug events. The test will ask the user to physically disconnect and reconnect the <code>HDMI</code> cable and then verify whether the appropriate <code>HDCP</code> callbacks for \"plug\" and \"unplug\" events are received and logged.</p> <p>Platform Supported:</p> <p>Source</p> <p>User Input Required:</p> <p>Yes: The user is required to unplug and plug the <code>HDMI</code> cable and confirm actions using the AV analyzer. (This will be automated in future versions.)</p> <p>Acceptance Criteria:</p> <ul> <li>The user successfully unplugs and plugs the <code>HDMI</code> cable.</li> <li>The system receives the appropriate <code>HDCP</code> status callbacks: \"HDMI Unplug Callback found\" and \"HDMI Plug Callback found.\"</li> </ul> <p>Expected Results:</p> <ul> <li>The test prompts the user to physically disconnect and reconnect the HDMI cable.</li> <li>The system detects the HDMI plug/unplug events and verifies the corresponding HDCP callbacks.</li> </ul> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test5_VerifyHDCP_Callback.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test5_VerifyHDCP_Callback.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will automatically download the necessary artifacts and streams, copy them to the target directory, and begin execution.</li> <li>The test prompts the user to perform the following actions:</li> <li>Unplug the <code>HDMI</code> cable when prompted with:<ul> <li><code>UnPlug the HDMI Cable? (Y/N):</code></li> <li>The user must unplug the <code>HDMI</code> cable and confirm by entering 'y'.</li> </ul> </li> <li>Plug the HDMI cable back in when prompted with:<ul> <li><code>Plug the HDMI Cable? (Y/N):</code></li> <li>The user must plug the <code>HDMI</code> cable and confirm by entering 'y'.</li> </ul> </li> <li>The user must also confirm that the following HDCP callbacks are received and logged:</li> <li><code>HDMI Unplug Callback found</code></li> <li><code>HDMI Plug Callback found</code></li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test6_verifyvideocontentformatspy","title":"dsVideoPort_test6_VerifyVideoContentFormats.py","text":"<p>Overview:</p> <p>This test verifies the supported <code>HDR</code> (High Dynamic Range) video content formats by playing various predefined streams and checking their formats via callbacks. The user will confirm the displayed formats using an AV analyzer.</p> <p>Platform Supported:</p> <p>Source</p> <p>User Input Required:</p> <p>Yes: The user needs to verify HDR formats using an AV analyzer(This will be automated in future versions with callbacks.)</p> <p>Acceptance Criteria:</p> <ul> <li>The test will play streams in different HDR formats.</li> <li>The user must verify and confirm the video content format displayed on the analyzer for each HDR mode.</li> </ul> <p>Expected Results:</p> <ul> <li>The test will automatically download and play predefined video streams in different HDR content formats.</li> <li>The user must confirm the displayed format using an AV analyzer for formats like HDR10, HLG, Dolby Vision, and HDR10+.</li> <li>The test passes if the user confirms all HDR formats were displayed correctly.</li> </ul> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test6_VerifyVideoContentFormats.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test6_VerifyVideoContentFormats.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will automatically download the necessary artifacts and streams, copy them to the target directory, and begin execution.</li> <li> <p>The test will play streams in various HDR content formats and prompt the user to confirm the format displayed on the analyzer:</p> </li> <li> <p>Is dsHDRSTANDARD_HDR10 displayed on the analyzer? (Y/N)</p> </li> <li>Is dsHDRSTANDARD_HLG displayed on the analyzer? (Y/N)</li> <li>Is dsHDRSTANDARD_DolbyVision displayed on the analyzer? (Y/N)</li> <li>Is dsHDRSTANDARD_HDR10PLUS displayed on the analyzer? (Y/N)</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test7_resettosdrmodepy","title":"dsVideoPort_test7_ResetToSDRMode.py","text":"<p>Overview:</p> <p>This test verifies the ability to reset the video output from <code>HDR</code> to <code>SDR</code> . The user will confirm if the video format has changed successfully from <code>HDR</code> to <code>SDR</code> using a display analyzer.</p> <p>Platform Supported:</p> <p>Source</p> <p>User Input Required:</p> <p>Yes: The user will verify whether the video playback has switched from HDR to SDR. (This will be automated in future versions.)</p> <p>Acceptance Criteria:</p> <ul> <li>The test will play an HDR stream, and the video content format will be reset to SDR.</li> <li>The user must verify that the playback format changes from HDR to SDR.</li> <li>The test will query the user with: \"Is Video Display on the port?\" to confirm if SDR mode is enabled.</li> </ul> <p>Expected Results:</p> <ul> <li>The test will download and play an HDR stream.</li> <li>It will switch the playback from HDR to SDR mode.</li> <li>The user must confirm that the video display is now in SDR mode using an analyzer or visual confirmation.</li> </ul> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test7_ResetToSDRMode.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test7_ResetToSDRMode.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will automatically download the necessary artifacts and streams, copy them to the target directory, and begin execution.</li> <li>The test will play <code>HDR</code> video content and switch the playback output to <code>SDR</code> mode. The user must verify that the output has changed to <code>SDR</code>:</li> <li>Is Video Playback in <code>HDR</code>on the port? (Y/N):</li> <li>If the answer is \"Yes\", the test passes.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test8_verifycolordepthpy","title":"dsVideoPort_test8_VerifyColorDepth.py","text":"<p>Overview:</p> <p>This test verifies that the video output color depth on supported video ports can be correctly set and confirmed by the user using an AV analyzer or through command-line verification. The test focuses on verifying the 8-bit color depth configuration, which the source device supports.</p> <p>Platform Supported:</p> <p>Source</p> <p>User Input Required:</p> <p>Yes: The user will verify if the color depth has been correctly set using an AV analyzer or command-line output. (This will be automated in future versions.)</p> <p>Acceptance Criteria:</p> <ul> <li>The test will set the color depth to 8-bit, and the user will confirm if the output has been set correctly.</li> <li>The user can verify this by inspecting the AV analyzer or running the command HdmiClient get-res to check the color depth.</li> </ul> <p>Expected Results:</p> <ul> <li>The test will set the color depth to 8-bit (supported by the source device).</li> <li>The user will confirm if the video output matches the set color depth:</li> <li>Is dsDISPLAY_COLORDEPTH_10BIT displayed on the Analyzer (Y/N)?</li> </ul> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test8_VerifyColorDepth.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test8_VerifyColorDepth.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will automatically download the necessary artifacts and streams, copy them to the target directory, and begin execution.</li> <li>The test will configure the color depth to 8-bit, which is supported by the source device.</li> <li>The user will be asked to confirm if the color depth has been correctly set by checking the AV analyzer or running the command:</li> <li><code>Is dsVIDEO_BGCOLOR_BLUE displayed on the Analyzer (Y/N)?</code></li> <li>If the answer is <code>Yes,</code> the test will pass.</li> </ul>"},{"location":"external_content/device_settings_test/docs/pages/dsVideoPort/ds-video-port_L3_Test-Procedure/#dsvideoport_test9_verifybackgroundcolorpy","title":"dsVideoPort_test9_VerifyBackgroundColor.py","text":"<p>Overview:</p> <p>This test verifies that the video output background color on supported video ports can be correctly set and confirmed by the user. The test allows the user to select a background color from a supported list and asks for confirmation of the color setting via an AV analyzer.</p> <p>Platform Supported:</p> <p>Source</p> <p>User Input Required:</p> <p>Yes: The user will verify if the background color has been correctly set using an AV analyzer.(This will be automated in future versions.)</p> <p>Acceptance Criteria:</p> <p>he test will set the background color from the supported list and ask the user to confirm whether the color is displayed correctly.</p> <p>Expected Results:</p> <ul> <li>The test will set the background color from the supported list and ask the user to verify each color:</li> <li>Is dsVIDEO_BGCOLOR_BLUE displayed on the Analyzer (Y/N)?</li> <li>Is dsVIDEO_BGCOLOR_BLACK displayed on the Analyzer (Y/N)?</li> <li>Is dsVIDEO_BGCOLOR_NONE displayed on the Analyzer (Y/N)?</li> <li>If the user answers \"Yes\" to all three questions, the test will pass.</li> </ul> <p>Test Steps:</p> <ul> <li>Run the Python file <code>dsVideoPort_test9_VerifyBackgroundColor.py</code> with the appropriate configuration:</li> </ul> <pre><code>dsVideoPort_test9_VerifyBackgroundColor.py --config /host/tests/configs/example_rack_config.yml --deviceConfig /host/tests/configs/deviceConfig.yml\n</code></pre> <ul> <li>The test will automatically download the necessary artifacts and streams, copy them to the target directory, and begin execution.</li> <li>The test will set the background color from the supported list and prompt the user for confirmation. The user will be asked to verify the following colors:</li> <li>Is dsVIDEO_BGCOLOR_BLUE displayed on the Analyzer (Y/N)?</li> <li>Is dsVIDEO_BGCOLOR_BLACK displayed on the Analyzer (Y/N)?</li> <li>Is dsVIDEO_BGCOLOR_NONE displayed on the Analyzer (Y/N)?</li> <li>If the answers to all three questions are \"Yes,\" the test will pass.</li> </ul>"},{"location":"external_content/hdmi_cec/","title":"HDMI CEC HAL Documentation","text":""},{"location":"external_content/hdmi_cec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/hdmi_cec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>CEC</code>    - Consumer Electronics Control</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> </ul>"},{"location":"external_content/hdmi_cec/#references","title":"References","text":"<ul> <li><code>HDMI-CEC Specification</code> - High-Definition Multimedia Interface, Specification Version 1.4b, (https://www.hdmi.org/)</li> <li>Downloadable via this link</li> <li>refer to Supplement 1 - Consumer Electronics Control (CEC) </li> </ul>"},{"location":"external_content/hdmi_cec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the module stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]--&gt;x[HDMI CEC HAL];\nx[HDMI CEC HAL]--&gt;z[HDMI CEC SOC Driver];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>This interface provides a set of <code>APIs</code> to facilitate communication through the driver for <code>CEC</code> messages with other <code>CEC</code> devices connected with HDMI cable.</p> <p>The interface retrieves and discovers logical and physical address of the host device, it is responsibile for transmitting and receiving messages with remote device(s) synchronously / asynchronously.</p> <p>The <code>CEC</code> protocol responsibilities will lie between the <code>caller</code> and the <code>HAL</code>.</p> <ul> <li>The <code>caller</code> must be responsible for <code>CEC</code> higher level protocol as defined in <code>HDMI-CEC Specification</code> Section <code>CEC 12</code>.</li> <li>The <code>caller</code> must pass fully formed <code>CEC</code> messages to the <code>HAL</code> for the transmission.</li> <li>The <code>HAL</code> must be responsible for physical device discovery and announcements on the <code>CEC</code> network as defined in the <code>HDMI-CEC Specification</code> Section <code>CEC 10</code>.</li> <li>The driver layer is responsible for the physical layer as defined in the Section <code>CEC 4</code> (Electrical Specification) and Section <code>CEC 5</code> (Signalling and Bit Timings). The driver layer is out-of-scope for this document.</li> </ul>"},{"location":"external_content/hdmi_cec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p><code>CEC</code> message transmit operation must complete within one second. Desired <code>CEC</code> response time is 200 milliseconds and maximum response time must be 1 second as provided in the <code>CEC</code> specifications (<code>HDMI-CEC Specification</code>). <code>Caller</code> is responsible to perform retry operations as per the <code>CEC</code> specification requirements. <code>Caller</code> will retry each transmission in line with a requirement as specified in Section <code>CEC 7.1</code> of the HMDI-CEC specification.</p>"},{"location":"external_content/hdmi_cec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>HdmiCecOpen()</code> before calling any other <code>API</code>.</p>"},{"location":"external_content/hdmi_cec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any caller invoking the <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/hdmi_cec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/hdmi_cec/#memory-model","title":"Memory Model","text":"<p>For transmit messages, it is upto the caller to allocate and free the memory for the message buffer. For receive messages, the <code>HAL</code> is responsible for memory management. The memory allocated cannot exceed 20 bytes (<code>HDMI-CEC Specification</code> Section <code>CEC 6</code>).</p>"},{"location":"external_content/hdmi_cec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions MUST not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/hdmi_cec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>For asynchronous transmit and receive operations, the following <code>APIs</code> and callback registrations are used:</p> <ol> <li>For async transmit use: <code>HdmiCecTxAsync()</code></li> <li>For async receive call back use: <code>HdmiCecSetRxCallback()</code></li> <li>For async transmit ack use: <code>HdmiCecSetTxCallback()</code></li> </ol> <p>The caller is required to return the callback context as fast as possible.</p>"},{"location":"external_content/hdmi_cec/#blocking-calls","title":"Blocking calls","text":"<p>There are no blocking calls. Synchronous calls must complete within a reasonable time period in accordance with any relevant <code>CEC</code> specification. Any call that can fail due to the lack of response from the connected device must have a timeout period in accordance with any relevant <code>CEC</code> specification and the function must return the relevant error code.</p>"},{"location":"external_content/hdmi_cec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/hdmi_cec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/hdmi_cec/#non-functional-requirements","title":"Non-functional requirements","text":""},{"location":"external_content/hdmi_cec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG and INFO must be disabled by default and enabled when required.</p>"},{"location":"external_content/hdmi_cec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and CPU utilization.</p>"},{"location":"external_content/hdmi_cec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as error.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged, to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/hdmi_cec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0. </p>"},{"location":"external_content/hdmi_cec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library and must be named as <code>libRCECHal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/hdmi_cec/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</p>"},{"location":"external_content/hdmi_cec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>None</p>"},{"location":"external_content/hdmi_cec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header files.</p>"},{"location":"external_content/hdmi_cec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The caller is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> using function: <code>HdmiCecOpen()</code> before making any other <code>API</code> calls. This call also discovers the physical address based on the connection topology. In case of source devices, <code>HdmiCecOpen()</code> must initiate the logical address discovery as part of this routine. In case of sink devices, logical address will be fixed and set using the <code>HdmiCecAddLogicalAddress()</code>. If <code>HdmiCecOpen()</code> call fails, the <code>HAL</code> must return the respective error code, so that the caller can retry the operation.</p> </li> <li> <p>Once logical address and physical address are assigned, the caller will be able to send and receive the respective <code>CEC</code> messages.</p> </li> <li> <p>For asynchronous receive operations, use the callback function: <code>HdmiCecSetRxCallback()</code>. the caller must register a callback after initialisation.</p> </li> <li> <p>For synchronous transmit, use the function: <code>HdmiCecTx()</code>.</p> </li> <li> <p>For asynchronous transmit, use the function: <code>HdmiCecTxAsync()</code>. The caller must register a callback via <code>HdmiCecSetTxCallback()</code> in order to receive the status or acknowledgement.</p> </li> </ol> <p>3.De-intialise the <code>HAL</code> using the function: <code>HdmiCecClose()</code>.</p> <p>NOTE: The module would operate deterministically if the above call sequence is followed.</p>"},{"location":"external_content/hdmi_cec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/hdmi_cec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as HDMI CEC HAL\n    participant Driver as HDMI Device Control/Driver\n    Caller-&gt;&gt;HAL:HdmiCecOpen()\n    Note over HAL: SOC intialises and discovers &lt;br&gt; physical address based on the connection topology &lt;br&gt; source devices discovers logical address internally  based on device type.\n    HAL-&gt;&gt;Driver: soc intialises\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:HdmiCecSetRxCallback()\n    HAL-&gt;&gt;Driver: Setting a receiver callback in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:HdmiCecSetTxCallback()\n    HAL-&gt;&gt;Driver:Setting a transmit callback in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecAddLogicalAddress()\n    Note over Caller: Sink devices must set the logical address using the API &lt;br&gt; HdmiCecAddLogicalAddress (Only for sink devices)\n    HAL-&gt;&gt;Driver: add logical address in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecGetLogicalAddress()\n    HAL-&gt;&gt;Driver:Get logical address from soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecGetPhysicalAddress()\n    HAL-&gt;&gt;Driver:Get physical address in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecTx()\n    Note over Caller,HAL: sync CEC transmit message\n    HAL-&gt;&gt;Driver: Transmit packet in soc side\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Driver--&gt;&gt;HAL:RxCallback()\n    Note over HAL: For CEC message received from the remote device, HdmiCecSetRxCallback() will be triggered\n    HAL--&gt;&gt;Caller:HdmiCecRxCallback() triggered\n    Caller -&gt;&gt;HAL:HdmiCecClose()\n    Note over Caller,HAL: SOC Un-initialises \n    HAL-&gt;&gt;Driver: Soc Un-initialises\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/hdmi_cec/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/hdmi_cec/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/hdmi_cec/CHANGELOG/#1310","title":"1.3.10","text":"<ul> <li>gh #11 Modified the description of result param in HdmiCecTx <code>#12</code></li> </ul>"},{"location":"external_content/hdmi_cec/CHANGELOG/#139","title":"1.3.9","text":"<p>28 June 2024</p> <ul> <li>gh #4 HDMI Spec Version update <code>#10</code></li> <li>Bumped CHANGELOG.md - 1.3.9 <code>4af0a90</code></li> <li>Merge tag '1.3.8' into develop <code>7fd9b82</code></li> </ul>"},{"location":"external_content/hdmi_cec/CHANGELOG/#138","title":"1.3.8","text":"<p>22 May 2024</p> <ul> <li>gh #6 Update HDMI CEC Interface <code>#7</code></li> <li>gh #6 CEC Architecture Review comment addressal <code>5a770e1</code></li> <li>gh #6 HdmiCecRemoveLogicalAddress Update &amp; HdmiCecTxAsync deprecation <code>deed402</code></li> <li>Bumped CHANGELOG.md - 1.3.8 <code>406ee58</code></li> </ul>"},{"location":"external_content/hdmi_cec/CHANGELOG/#137","title":"1.3.7","text":"<p>14 November 2023</p> <ul> <li>Updated build_ut.sh, generate_docs.sh and gitignore <code>#3</code></li> <li>Baseline version <code>55c1046</code></li> <li>Updated CHANGELOG.md - 1.3.7 <code>a9daa8d</code></li> <li>Updated LICENSE file name in header <code>aebaa51</code></li> </ul>"},{"location":"external_content/hdmi_cec/CHANGELOG/#020","title":"0.2.0","text":"<p>21 March 2024</p> <ul> <li>RDK6 Changes <code>3d03b3c</code></li> <li>Added CHANGELOG.md - 0.2.0 <code>196b3e8</code></li> <li>Initial commit <code>67e87e9</code></li> </ul>"},{"location":"external_content/hdmi_cec/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/","title":"HDMI CEC HAL Documentation","text":""},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HDMI</code>   - High-Definition Multimedia Interface</li> <li><code>CEC</code>    - Consumer Electronics Control</li> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>Caller</code> - Any user of the interface via the <code>APIs</code></li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#references","title":"References","text":"<ul> <li><code>HDMI-CEC Specification</code> - High-Definition Multimedia Interface, Specification Version 1.4b, (https://www.hdmi.org/)</li> <li>Downloadable via this link</li> <li>refer to Supplement 1 - Consumer Electronics Control (CEC) </li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the module stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]--&gt;x[HDMI CEC HAL];\nx[HDMI CEC HAL]--&gt;z[HDMI CEC SOC Driver];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>This interface provides a set of <code>APIs</code> to facilitate communication through the driver for <code>CEC</code> messages with other <code>CEC</code> devices connected with HDMI cable.</p> <p>The interface retrieves and discovers logical and physical address of the host device, it is responsibile for transmitting and receiving messages with remote device(s) synchronously / asynchronously.</p> <p>The <code>CEC</code> protocol responsibilities will lie between the <code>caller</code> and the <code>HAL</code>.</p> <ul> <li>The <code>caller</code> must be responsible for <code>CEC</code> higher level protocol as defined in <code>HDMI-CEC Specification</code> Section <code>CEC 12</code>.</li> <li>The <code>caller</code> must pass fully formed <code>CEC</code> messages to the <code>HAL</code> for the transmission.</li> <li>The <code>HAL</code> must be responsible for physical device discovery and announcements on the <code>CEC</code> network as defined in the <code>HDMI-CEC Specification</code> Section <code>CEC 10</code>.</li> <li>The driver layer is responsible for the physical layer as defined in the Section <code>CEC 4</code> (Electrical Specification) and Section <code>CEC 5</code> (Signalling and Bit Timings). The driver layer is out-of-scope for this document.</li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p><code>CEC</code> message transmit operation must complete within one second. Desired <code>CEC</code> response time is 200 milliseconds and maximum response time must be 1 second as provided in the <code>CEC</code> specifications (<code>HDMI-CEC Specification</code>). <code>Caller</code> is responsible to perform retry operations as per the <code>CEC</code> specification requirements. <code>Caller</code> will retry each transmission in line with a requirement as specified in Section <code>CEC 7.1</code> of the HMDI-CEC specification.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>HdmiCecOpen()</code> before calling any other <code>API</code>.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any caller invoking the <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#memory-model","title":"Memory Model","text":"<p>For transmit messages, it is upto the caller to allocate and free the memory for the message buffer. For receive messages, the <code>HAL</code> is responsible for memory management. The memory allocated cannot exceed 20 bytes (<code>HDMI-CEC Specification</code> Section <code>CEC 6</code>).</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>Although this interface is not required to be involved in any of the power management operations, the state transitions MUST not affect its operation. e.g. on resumption from a low power state, the interface must operate as if no transition has occurred.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>For asynchronous transmit and receive operations, the following <code>APIs</code> and callback registrations are used:</p> <ol> <li>For async transmit use: <code>HdmiCecTxAsync()</code></li> <li>For async receive call back use: <code>HdmiCecSetRxCallback()</code></li> <li>For async transmit ack use: <code>HdmiCecSetTxCallback()</code></li> </ol> <p>The caller is required to return the callback context as fast as possible.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>There are no blocking calls. Synchronous calls must complete within a reasonable time period in accordance with any relevant <code>CEC</code> specification. Any call that can fail due to the lack of response from the connected device must have a timeout period in accordance with any relevant <code>CEC</code> specification and the function must return the relevant error code.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":""},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG and INFO must be disabled by default and enabled when required.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and CPU utilization.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as error.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged, to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0. </p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library and must be named as <code>libRCECHal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>None</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header files.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The caller is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ol> <li> <p>Initialize the <code>HAL</code> using function: <code>HdmiCecOpen()</code> before making any other <code>API</code> calls. This call also discovers the physical address based on the connection topology. In case of source devices, <code>HdmiCecOpen()</code> must initiate the logical address discovery as part of this routine. In case of sink devices, logical address will be fixed and set using the <code>HdmiCecAddLogicalAddress()</code>. If <code>HdmiCecOpen()</code> call fails, the <code>HAL</code> must return the respective error code, so that the caller can retry the operation.</p> </li> <li> <p>Once logical address and physical address are assigned, the caller will be able to send and receive the respective <code>CEC</code> messages.</p> </li> <li> <p>For asynchronous receive operations, use the callback function: <code>HdmiCecSetRxCallback()</code>. the caller must register a callback after initialisation.</p> </li> <li> <p>For synchronous transmit, use the function: <code>HdmiCecTx()</code>.</p> </li> <li> <p>For asynchronous transmit, use the function: <code>HdmiCecTxAsync()</code>. The caller must register a callback via <code>HdmiCecSetTxCallback()</code> in order to receive the status or acknowledgement.</p> </li> </ol> <p>3.De-intialise the <code>HAL</code> using the function: <code>HdmiCecClose()</code>.</p> <p>NOTE: The module would operate deterministically if the above call sequence is followed.</p>"},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/hdmi_cec/docs/pages/hdmi-cec_halSpec/#operational-call-sequence","title":"Operational Call Sequence","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as HDMI CEC HAL\n    participant Driver as HDMI Device Control/Driver\n    Caller-&gt;&gt;HAL:HdmiCecOpen()\n    Note over HAL: SOC intialises and discovers &lt;br&gt; physical address based on the connection topology &lt;br&gt; source devices discovers logical address internally  based on device type.\n    HAL-&gt;&gt;Driver: soc intialises\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:HdmiCecSetRxCallback()\n    HAL-&gt;&gt;Driver: Setting a receiver callback in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:HdmiCecSetTxCallback()\n    HAL-&gt;&gt;Driver:Setting a transmit callback in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecAddLogicalAddress()\n    Note over Caller: Sink devices must set the logical address using the API &lt;br&gt; HdmiCecAddLogicalAddress (Only for sink devices)\n    HAL-&gt;&gt;Driver: add logical address in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecGetLogicalAddress()\n    HAL-&gt;&gt;Driver:Get logical address from soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecGetPhysicalAddress()\n    HAL-&gt;&gt;Driver:Get physical address in soc\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:HdmiCecTx()\n    Note over Caller,HAL: sync CEC transmit message\n    HAL-&gt;&gt;Driver: Transmit packet in soc side\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Driver--&gt;&gt;HAL:RxCallback()\n    Note over HAL: For CEC message received from the remote device, HdmiCecSetRxCallback() will be triggered\n    HAL--&gt;&gt;Caller:HdmiCecRxCallback() triggered\n    Caller -&gt;&gt;HAL:HdmiCecClose()\n    Note over Caller,HAL: SOC Un-initialises \n    HAL-&gt;&gt;Driver: Soc Un-initialises\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/hdmi_cec_test/","title":"Unit Testing Suite For HDMI CEC HAL","text":""},{"location":"external_content/hdmi_cec_test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Reference Documents</li> <li>Notes</li> </ul>"},{"location":"external_content/hdmi_cec_test/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>- Hardware Abstraction Layer</li> <li><code>HDMI</code> - High Definition Multimedia Interface</li> <li><code>CEC</code> - Consumer Electronics Control</li> <li><code>L1</code> - Functional Tests</li> <li><code>L2</code> - Module functional Testing</li> <li><code>L3</code> - Module testing with External Stimulus is required to validate and control device</li> <li><code>API</code> - Application Programming Interface</li> </ul>"},{"location":"external_content/hdmi_cec_test/#description","title":"Description","text":"<p>This repository contains the Unit Test Suites(L1 &amp; L2) for HDMI CEC <code>HAL</code>.</p>"},{"location":"external_content/hdmi_cec_test/#reference-documents","title":"Reference Documents","text":"SNo Document Name Document Description Document Link 1 <code>HAL</code> Specification Document This document provides specific information on the APIs for which tests are written in this module hdmi-cec_halSpec.md 2 High Level Test Spec for sink device High Level Test Specification Documentation for the <code>HDMI</code> <code>CEC</code> Sink device hdmi-cec-sink_High-Level_TestSpec.md 3 <code>L2</code> Low Level Test Spec for sink device <code>L2</code> Low Level Test Specification and Procedure Documentation for the <code>HDMI</code> <code>CEC</code> Sink device hdmi-cec-sink_L2_Low-Level_TestSpec.md 4 High Level Test Spec for Source device High Level Test Specification Documentation for the <code>HDMI</code> <code>CEC</code> Source device hdmi-cec-source_High-Level_TestSpec.md 5 <code>L2</code> Low Level Test Spec for Source device <code>L2</code> Low Level Test Specification and Procedure Documentation for the <code>HDMI</code> <code>CEC</code> Source device hdmi-cec-source_L2_Low-Level_TestSpec.md 6 <code>L3</code> Low Level Test Specification <code>L3</code> Low Level Test Specification for the <code>HDMI</code> <code>CEC</code> hdmi-cec-L3-Low-Level_TestSpec.md 7 <code>L3</code> Test procedure document <code>L3</code> Test procedure document for the <code>HDMI</code> <code>CEC</code> hdmi-cec-L3_TestProcedure.md"},{"location":"external_content/hdmi_cec_test/#notes","title":"Notes","text":"<ul> <li>All APIs need to be implemented in this current version. If any API is not supported, please add stub implementation with return type HDMI_CEC_IO_OPERATION_NOT_SUPPORTED for the same.</li> <li>Building against the actual library may introduce SOC dependencies. Hence, a template SKELETON library is created without SOC dependencies. On the real platform (target), it can be mounted, copied and bound with the actual library.</li> <li>When running the binary, remember to include a profile file as an argument for designated test cases. The following example illustrates this:</li> </ul> <pre><code>./hal_test -p sink_hdmiCEC.yml\n</code></pre> <p>Alternatively, use the run.sh script with the profile file:</p> <pre><code>./run.sh -p /absolute/path/to/profile/file\n</code></pre> <ul> <li>Profile files define the configuration for the platform available at sink HDMI CEC, source HDMI CEC, stb source device, tv panel</li> <li>vcomponent is an alpha release.</li> <li>Install Python Environment and Activation Scripts please check theHPK Documentation</li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/hdmi_cec_test/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#140","title":"1.4.0","text":"<ul> <li>gh #44 Initial L3 C-Test Code generation. <code>#45</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#133","title":"1.3.3","text":"<p>7 November 2024</p> <ul> <li>gh #58 l1 logic update fix <code>#60</code></li> <li>gh #61 updated the intiator and destination address in the log <code>cd92f1c</code></li> <li>gh #61 L1 Fix on Logical address update <code>d76034e</code></li> <li>gh #61 L1 logical address update <code>bb0ea75</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#132","title":"1.3.2","text":"<p>5 November 2024</p> <ul> <li>gh #58 Issue fix L1 and L2 <code>#59</code></li> <li>gh #41 Support State commands (AddDevice, RemoveDevice, PrintStatus) <code>#46</code></li> <li>Fixed #50 : updated activate &amp; added test_helper <code>#50</code></li> <li>Baseline #50 setup layout <code>28aa818</code></li> <li>Added #50 baseline requirements <code>d119127</code></li> <li>Added example config #50 <code>1d972fd</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#131","title":"1.3.1","text":"<p>4 September 2024</p> <ul> <li>gh #53 Update L1 and L2 according to new pre post condition. <code>#55</code></li> <li>gh #52 Update L1 and L2 for pre post condition update <code>7910ceb</code></li> <li>gh #53 Update L1 and L2 for pre and post condition <code>0afa1da</code></li> <li>gh #53 Update L1 L2 with post and pre condition. <code>30f601c</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#130","title":"1.3.0","text":"<p>13 August 2024</p> <ul> <li>gh #47 L1 Test code cleanup <code>#49</code></li> <li>gh #30 VTS L1 Enhancement - Test Profile Changes - HDMI CEC <code>#33</code></li> <li>gh #36 Update L1 suite with specification 1.3.9 <code>#38</code></li> <li>Document the control plane commands that will be supported <code>#40</code></li> <li>Feature/issue18 control plane integration <code>#37</code></li> <li>Feature/issues9: Support emulating a cec network <code>#29</code></li> <li>gh #47 L1 cod cleanup <code>ffdb87a</code></li> <li>gh #36 Addressing review comments <code>91ee018</code></li> <li>gh #36 Update L1 with specification 1.3.9 <code>ab12bd6</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#120","title":"1.2.0","text":"<p>28 June 2024</p> <ul> <li>gh #24 hdmicec source &amp; sink l2 tests  <code>#28</code></li> <li>Feature/issues15 emulator startup <code>#21</code></li> <li>Update <code>#19</code></li> <li>Update with Sink tests <code>9655adf</code></li> <li>Update based on review discussion <code>ab6f668</code></li> <li>Update with generated L2 code and specification document <code>769045a</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#110","title":"1.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #11 hdmi_cec: Test Profile: Adding MACRO ENABLE_ENHANCED_ERROR_CODE to enalbe/disable the enhanced error code tests <code>#12</code></li> <li>Capture the YAML Template and design for CEC Emulator <code>#8</code></li> <li>Create hdmi_cec_emulator_design.md <code>84741c3</code></li> <li>Handling Enhanced error code with kvp profile <code>117c8d4</code></li> <li>Adding MACRO ENABLE_ENHANCED_ERROR_CODE <code>a77ad32</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#104","title":"1.0.4","text":"<p>11 May 2024</p> <ul> <li>fixing the usage of UT core functions  <code>#10</code></li> <li>gh #1 Updated UT version2 and removed unnecessary clean up <code>284ac93</code></li> <li>gh #1 replace UT fatal to non fatal &amp; updated the test suite <code>bb6bc68</code></li> <li>gh #1 Updated the ut assert true <code>febc59d</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#103","title":"1.0.3","text":"<p>12 December 2023</p> <ul> <li>Updated README.md with hal &amp; haltest supported version <code>2150135</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>c948d2a</code></li> <li>Merge tag '1.0.2' into develop <code>4bf3988</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CHANGELOG/#102","title":"1.0.2","text":"<p>5 December 2023</p> <ul> <li>baseline version <code>9f45b9e</code></li> <li>Added CHANGELOG.md - 1.0.2 <code>1c8f1c3</code></li> <li>minior fix for doxgen warning <code>8e7777a</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/","title":"HDMI CEC L3 Test Document","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>References</li> <li>Level 3 Test Procedure</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the L3 Test Procedure for the HDMI CEC module.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>CEC</code>    -  Consumer Electronics Control</li> <li><code>HAL</code>    -  Hardware Abstraction layer</li> <li><code>HDMI</code>   -  High Definition Multimedia Interface</li> <li><code>API</code>    -  Application Program Interface</li> <li><code>SoC</code>    -  System on Chip</li> <li><code>DUT</code>    -  Device Under Test</li> <li><code>LA</code>     -  Logical Address</li> <li><code>PA</code>     -  Physical Address</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#references","title":"References","text":"<ul> <li>CEC Adaptor: Pulse Eight</li> <li><code>HAL</code> interface file: hdmi_cec_driver.h</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"# Test-case Description HAL APIs Source Sink 1 Transmit CEC Commands Send predefined <code>CEC</code> commands from the DUT and verify if the command is successfully transmitted using the CEC adapter <code>HdmiCecTx()</code> <code>Y</code> <code>Y</code> 2 Receive CEC commands Send predefined <code>CEC</code> commands from the CEC adapter, verify if the <code>DUT</code> successfully receives the command, and check the response through call-backs. <code>HdmiCecTx()</code> <code>Y</code> <code>Y</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of HDMI CEC Python test cases:</p> <pre><code>---\ntitle: HDMI-CEC - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- hdmiCECHelperClass : inherits\n    hdmiCECHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; hdmiCEC : uses\n    note for testControl \"uses rackConfig.yml and deviceConfig.yml\"\n    note for hdmiCEC \"uses platformProfile.yml\"\n    note for L3_TestClasses \"uses hdmiCECTestCommands.yml\"\n    note for ut_raft \"suite Navigator uses testSuite.yml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft</li> <li>hdmiCEC</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3-Low-Level_TestSpec/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file sink_hdmiCEC</p> </li> <li> <p>hdmiCECTestCommands.yaml</p> </li> <li>This configuration file contains the list of <code>CEC</code> commands.</li> <li> <p>Example configuration file hdmiCECTestCommands.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file hdmiCEC_testConfig.yml</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/","title":"HDMI CEC HAL L3 Python Test Procedure","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Test Cases</li> <li>hdmiCEC_L3_Runall.py</li> <li>hdmiCEC_test01_TransmitCECCommands.py</li> <li>hdmiCEC_test02_ReceiveCECCommands.py</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> <li><code>HDMI</code>   -  High Definition Multimedia Interface</li> <li><code>API</code>    -  Application Program Interface</li> <li><code>SoC</code>    -  System on Chip</li> <li><code>DUT</code>    -  Device Under Test</li> <li><code>LA</code>     -  Logical Address</li> <li><code>PA</code>     -  Physical Address</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>The picture below depicts the HDMI CEC L3 Test Functionality Setup. This simple setup has an HDMI CEC Pulse-eight USB adaptor, which acts as a source device and can send the required commands (using libcec tool commands) and respond to the received CEC Commands.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ensure all devices in the test setup support the <code>HDMI</code> <code>CEC</code> feature for the test duration.</li> <li>HDMI drivers must be properly installed and active on the platform before initiating the test.</li> </ul> <pre><code>graph TB\nC[PC] &lt;--&gt; |USB| A\nA[Pulse-Eight CEC Adaptor ] &lt;--&gt; |HDMI| B[DUT]\nA[Pulse-Eight CEC Adaptor ] &lt;--&gt; |HDMI| D[Other Test Device]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#pulse-eight-cec-adaptor-tool","title":"Pulse-Eight CEC Adaptor tool","text":"<p>The Pulse-Eight CEC adaptor is used to frame and send commands to the DUT. It utilizes the libCEC library for HDMI CEC activities, and the cec-client tool plays a key role in test automation within RAFT.</p> <ul> <li>Adaptor Details: Pulse Eight</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#installation-instructions","title":"Installation Instructions","text":"<ul> <li>Linux</li> </ul> <pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install cec-utils\n</code></pre> <ul> <li>Windows</li> </ul> <p>Download the libcec Tool and follow installation steps.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#example-cec-client-commands","title":"Example <code>cec-client</code> Commands","text":"<ul> <li>List Device Details:</li> </ul> <pre><code>cec-client -l\n</code></pre> <ul> <li>Scan for Connected Devices:</li> </ul> <pre><code>echo 'scan' | cec-client -s -d 1\n</code></pre> <ul> <li>Send CEC Commands:</li> </ul> <pre><code>echo 'tx 10:8F' | cec-client -s -d 1\n\nCommand Format:\ntx &lt;source Logical address&gt;&lt;Destination logical Address&gt;:&lt;Opcode&gt;:&lt;Payload bytes&gt;\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#python-environment","title":"Python Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>Refer to the following resources for more details:</p> <ul> <li>RAFT</li> <li>example_rack_config.yml</li> </ul> <p>Update the configuration to define the console sessions for the DUT, cec-client details, and outbound settings.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#console-sessions","title":"Console Sessions","text":"Console Session Description default Downloads the bins required for test cases ssh_hal_test Executes the <code>HAL</code> binary for the test case"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#cec-controller","title":"CEC Controller","text":"<p><code>RAFT</code> supports two types of cec controllers:</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#remote-controller","title":"Remote controller","text":"<p>For adaptors connected to a remote server, use the configuration below:</p> <pre><code>      hdmiCECController:\n        type: remote-cec-client    # Use remote cec controller\n        adaptor: /dev/ttyACM0      # Adaptor port\n        address: XXX.XXX.XXX.XXX   # IP address of the server\n        username: root             # Login username\n        password: ' '              # Login password\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#local-controller","title":"Local controller","text":"<p>For adaptors connected directly to the server running the tests, use the configuration below:</p> <pre><code>      hdmiCECController:\n        type: cec-client           # Use local cec controller\n        adaptor: /dev/ttyACM0      # adaptor port\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#example-rack-configuration","title":"Example Rack Configuration","text":"<pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"http://localhost:8000/\"    # download location for the CPE device\n        httpProxy:   # Local Proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n      hdmiCECController:\n        type: remote-cec-client\n        adaptor: /dev/ttyACM0\n        address: XXX.XXX.XXX.XXX\n        username: root\n        password: ' '\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>Refer to the following resources for more details:</p> <ul> <li>RAFT</li> <li>example_device_config.yml</li> </ul> <p>Update the following fields:</p> <ul> <li>Target Directory: Specify the <code>target_directory</code> path where HAL binaries will be copied.</li> <li>Device Profile: Provide the path and profile file for the <code>test/profile</code>.</li> <li>Platform: Ensure the platform matches the <code>dut</code> platform in the Rack Configuration</li> </ul> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"tv\"\n        model: \"uk\"\n        soc_vendor: \"soc\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\"\n        test:\n            profile: \"../../../profiles/sink/sink_hdmiCEC.yml\"\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: hdmiCEC_testConfig.yml</p> <p>Specify the command to run the HAL binary within this file.</p> <pre><code>hdmicec:\n    description: \"hdmi CEC testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#hdmicec_l3_runallpy","title":"hdmiCEC_L3_Runall.py","text":"<p>This python file runs all the tests</p> <pre><code>python hdmiCEC_L3_Runall.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#hdmicec_test01_transmitceccommandspy","title":"hdmiCEC_test01_TransmitCECCommands.py","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#platform-support-test01","title":"Platform Support - test01","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>No - (This is a automated case)</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<ul> <li>The test verifies that the device under test (DUT) can successfully transmit HDMI-CEC commands to connected devices as defined in the test profile.</li> <li>Transmission should be correctly initiated and logged by the HDMI-CEC controller.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test is considered successful if:</p> <ul> <li>All HDMI-CEC commands listed in the <code>YAML</code> profile are transmitted without errors.</li> <li>The test script validates that the transmission is initiated and logged correctly by the HDMI-CEC controller.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<p>Preparation:</p> <ul> <li>Ensure the <code>DUT</code> is connected to the HDMI-CEC controller devices via HDMI cables.</li> <li>Verify that configuration files for the test environment are correctly set up.</li> </ul> <p>Execution:</p> <p>Run the Python script with the following command:</p> <pre><code>python hdmiCEC_test01_TransmitCECCommands.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre> <p>Functionality:</p> <ul> <li>The script initializes the HDMI-CEC controller session.</li> <li>It transmits HDMI-CEC commands from the DUT to the connected devices.</li> </ul> <p>Validation:</p> <ul> <li>The script checks if the HDMI-CEC controller logs confirm the transmission of each command.</li> <li>Transmission status is logged with details such as source, destination, opcode, and payload.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-logs-and-artifacts-test01","title":"Test Logs and Artifacts - test01","text":"<p>Summary Logs:</p> <ul> <li>A comprehensive log file is generated, detailing the execution status of each command.</li> <li> <p>Log file path: &lt;\"PATH\"&gt;/ut/logs/rack&lt;#&gt;/slot&lt;#&gt;/&lt;\"DATE-TIME\"&gt;/test_summary.log.</p> </li> <li> <p>Transmission Status:</p> </li> <li>Logs include information about the success or failure of each transmitted command.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-conclusion-test01","title":"Test Conclusion - test01","text":"<p>The test script will display a final PASS/FAIL result based on the following conditions:</p> <ul> <li>PASS: All CEC commands are successfully transmitted as listed in the YAML profile, and transmission logs confirm initiation by the HDMI-CEC controller.</li> <li>FAIL: Any transmission error or failure to initiate commands.</li> </ul> <p>Summary logs are saved for further review and debugging.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#hdmicec_test02_receivececcommandspy","title":"hdmiCEC_test02_ReceiveCECCommands.py","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#platform-support-test02","title":"Platform Support - test02","text":"<ul> <li>Source</li> <li>Sink</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>No -  (This is a automated case)</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<ul> <li>The test verifies whether the device under test (DUT) can reliably receive HDMI-CEC commands.</li> <li>The received callback data must match the expected values, including:</li> <li>Source logical address</li> <li>Destination logical address</li> <li>Opcode</li> <li>Payload</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test is considered successful if:</p> <ul> <li>All transmitted HDMI-CEC commands are successfully received by the DUT.</li> <li>The callback data accurately reflects the transmitted command parameters (source, destination, opcode, and payload).</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<p>Preparation:</p> <ul> <li>Ensure the DUT is powered on and connected to the HDMI-CEC controller.</li> <li>Verify the configuration files for the test environment are properly set up.</li> </ul> <p>Execution:</p> <p>Run the Python script with the following command:</p> <pre><code>python hdmiCEC_test02_ReceiveCECCommands.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre> <p>Functionality:</p> <ul> <li>The script initializes the HDMI-CEC controller.</li> <li>It sends HDMI-CEC commands to the DUT's logical address, including directed and broadcast messages.</li> <li>The DUT processes these commands, and the script reads the callback data.</li> </ul> <p>Verification:</p> <ul> <li>The script validates the callback data received by the DUT against the transmitted parameters (source, destination, opcode, payload).</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-logs-and-artifacts-test02","title":"Test Logs and Artifacts - test02","text":"<p>Summary Logs:</p> <ul> <li>The script generates a detailed log file summarizing the test execution.</li> <li>Log file path: &lt;\"PATH\"&gt;/ut/logs/rack&lt;#&gt;/slot&lt;#&gt;/&lt;\"DATE-TIME\"&gt;/test_summary.log</li> <li>Logs include information on received commands, validation results, and any discrepancies.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-L3_TestProcedure/#test-conclusion-test02","title":"Test Conclusion - test02","text":"<p>The test script will display a final PASS/FAIL result based on the following conditions:</p> <ul> <li>PASS: All received HDMI-CEC commands and callback data match the expected values.</li> <li>FAIL: Any mismatch in the callback data or failure to receive commands.</li> </ul> <p>Summary logs are saved for review and troubleshooting</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/","title":"HDMI CEC Sink High-Level Test Specification Document","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>HDMI-CEC RDK HAL Functionality</li> <li>Test scenarios</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>CEC</code>  - Consumer Electronics Control</li> <li><code>HAL</code>  - Hardware Abstraction layer</li> <li><code>HDMI</code> - High Definition Multimedia Interface</li> <li><code>DUT</code>  - Device Under Test</li> <li><code>L2</code>   - Level 2 Testing ()</li> <li><code>L3</code>   - Level 3 Testing ()</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#scope","title":"Scope","text":"<p>This document defines the requirements for testing the HDMI CEC device from a level 2/3 based on being a sink device.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#overview","title":"Overview","text":"<p>Consumer Electronics Control (CEC) is a single-wire bidirectional bus within an HDMI system, facilitating communication among interconnected products. HDMI-CEC establishes a protocol enabling high-level control functions between audiovisual devices linked via an HDMI network, facilitating communication and control among them. Communication can occur in either Direct messaging mode or Broadcast mode.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#hdmi-cec-rdk-hal-functionality","title":"HDMI-CEC RDK HAL Functionality","text":"<p>The HAL layers within RDK serve as a bridge between the underlying low-level SoC drivers and the higher-level RDK layers that utilize the functionality offered by these HAL functions. Caller will manage the discovery of logical addresses in sink devices, while HAL needs to facilitate sending and receiving the CEC commands on the network. Specifically concerning the CEC Module, the HAL layers facilitate the following functionalities on sink devices:</p> <ol> <li>Provision to set, get, and remove the logical address</li> <li>Provision to get the Physical address</li> <li>Provision to Tx and Rx the CEC data</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#test-scenarios","title":"Test scenarios","text":"<p>The HAL CEC layer enables the transmission and reception of CEC frames on the CEC bus. However, it does not manage or validate any particular CEC opcode commands to confirm the supported HAL CEC opcodes for transmission or reception.</p> <p>Managing the opcodes is the responsibility of the caller. The existing test cases will validate responses from connected devices for a subset of opcodes as part of the testing procedure.</p> S.No. Test Functionality Description 1 Logical address Facilitating the Discovery of logical addresses, Setting, getting, and removing the logical address of the device (for sink devices) 2 Physical Address Retrieving the physical address 3 CEC Synchronous Transmission Transmitting CEC frames and reporting on their acknowledgement 4 CEC Receive functionality Receiving CEC Information from other devices and passing it to the layer above through registered callback function 5 CEC HotPlug Functionality Managing CEC during Hotplug and HotUnplug events"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#logical-address-discovery","title":"Logical Address Discovery","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 1 Logical address Get the logical address of the <code>DUT</code> without actually adding the Logical Address and the API should return 0x0F as the default logical address. HdmiCecGetLogicalAddress <code>Y</code> <code>NA</code> <code>NA</code> a Setup all valid logical addresses b/w 0x00 to 0x0F for the <code>DUT</code> and retrieve each to ensure proper functionality, using HAL APIs. HdmiCecAddLogicalAddress, HdmiCecGetLogicalAddress, HdmiCecRemoveLogicalAddress <code>Y</code> <code>NA</code> <code>NA</code> b Invoke the HAL API to delete the <code>DUT</code> logical address and verify that it is removed successfully. HdmiCecAddLogicalAddress, HdmiCecRemoveLogicalAddress, HdmiCecGetLogicalAddress <code>Y</code> <code>NA</code> <code>NA</code> c After deleting the <code>DUT</code> logical address, try to send a broadcast CEC Command (as per 1.4b HDMI CEC spec) and confirm transmission is successful. HdmiCecAddLogicalAddress, HdmiCecRemoveLogicalAddress, HdmiCecTx <code>Y</code> <code>NA</code> <code>NA</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#emulator-requirements","title":"Emulator Requirements","text":"<ul> <li>Boot with control configuration with various configurations having a predefined set of nodes:</li> <li>configuration to support the discovery of logical addresses. The caller provides the logical address, and HAL checks the availability of this address and feedback the same to the caller.</li> <li>Verify for the valid logical address and return the appropriate error code based on the logical address availability.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#physical-address","title":"Physical Address","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 2 Physical Address Verify the physical address allocated through the HAL function. HdmiCecGetPhysicalAddress Y NA Verify the physical addresses allocated by connecting two sink devices through an HDMI switch. HdmiCecGetPhysicalAddress NA Y Enable the television connected to <code>DUT</code> to declare its physical address first before <code>DUT</code>."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#emulator-requirements-physical-address","title":"Emulator Requirements - Physical Address","text":"<ul> <li>Boot control configuration to setup the CEC network nodes</li> <li>Scenario to have two sink devices on the network</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#control-plane-requirements-physical-address","title":"Control Plane Requirements - Physical Address","text":"<ul> <li>The control plane will allow removing or adding a node to the network.</li> <li>allowing add sink node before the <code>DUT</code> switched ON.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#cec-synchronous-transmission","title":"CEC Synchronous Transmission","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 3 CEC Transmission Verify the correct transmission of the supported CEC commands (as per 1.4b HDMI CEC spec) to the connected device and ensure it is acknowledged properly. HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control plane to switch ON a CEC-supported device on the HDMI network so that it shall respond to the basic commands Broadcast a supported CEC Command to all the devices connected to the network without any error HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control plane to switch ON a CEC-supported device on the HDMI network to act on the broadcasted command Transmit a CEC Command (as per 1.4b HDMI CEC spec) to put the connected device into standby mode and await the device's response. Monitoring the behaviour of the connected device accordingly. HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control plane to monitor the behaviour of the connected devices. Transmit a HDMI CEC Command (as per 1.4b HDMI CEC spec) to get the CEC Version of a device that doesn't exist. HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress Y NA Control plane can unplug or switch off a previously existing CEC device"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#emulator-requirements-cec-transmission","title":"Emulator Requirements - CEC Transmission","text":"<ul> <li>Boot configuration</li> <li>Min case scenario multiple network nodes</li> <li>Max case scenario multiple cec nodes</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#control-plane-requirements-cec-transmission","title":"Control Plane Requirements - CEC Transmission","text":"<ul> <li>The control plane will allow adding a device that can respond to the CEC Frames sent by <code>DUT</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#cec-receive-functionality","title":"CEC Receive functionality","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 5 CEC Receive functionality Transmit a CEC Command that expects a response (Eg. GetCECVersion) to a connected device and see the response is received correctly. Set the Rx Callback before sending the data. Validate the received CEC Version. HdmiCecAddLogicalAddress, HdmiCecSetRxCallback, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control plane to switch ON a CEC device that can respond to the Transmitted CEC Command Transmit a CEC command from the connected devices and consider the Acknowledgement and responses are received correctly from the host device (<code>DUT</code> TV here) HdmiCecAddLogicalAddress, HdmiCecSetRxCallback, HdmiCecRemoveLogicalAddress NA Y Control panel to control the third-party devices to Transmit the required commands to  <code>DUT</code> Transmit an OSD CEC command from the connected devices and consider the Acknowledgement and responses are received correctly from the host device (<code>DUT</code> TV here). Make the OSD String to max length HdmiCecAddLogicalAddress, HdmiCecSetRxCallback, HdmiCecRemoveLogicalAddress NA Y Control panel to control the third-party devices to Transmit the required commands to  <code>DUT</code> Transmit an OSD CEC command from the connected devices continuously for 30 seconds changing the patterns in the payload and considering the Acknowledgement and responses are received correctly from the host device (<code>DUT</code> TV here). Make the OSD String to max length HdmiCecAddLogicalAddress, HdmiCecSetRxCallback, HdmiCecRemoveLogicalAddress NA Y Control panel to control the third-party devices to Transmit the required commands to  <code>DUT</code>. Also, Control plane to detect the OSD Display on the Sink device to validate Set the Logical address to 0 on <code>DUT</code> and make sure that it doesn't receive the messages sent to devices with different logical address. HdmiCecAddLogicalAddress, HdmiCecSetRxCallback, HdmiCecRemoveLogicalAddress NA Y Control Plane to initiate a command to send CEC frames from CEC adaptor with a different logical address other than zero"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#emulator-requirements-cec-receive-functionality","title":"Emulator Requirements - CEC Receive functionality","text":"<ol> <li>Emulate the Tx and Rx HAL functionalities with the required responses.</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#control-plane-requirements-cec-receive-transmission","title":"Control Plane Requirements - CEC Receive Transmission","text":"<ul> <li>The control plane will allow adding a device that can respond to the CEC Frames sent by <code>DUT</code></li> <li>The control plane to initiate CEC Transmissions from the connected devices as expected by the <code>DUT</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#cec-hotplug-functionality","title":"CEC HotPlug Functionality","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 6 CEC HotPlug Functionality Generate a Hotplug event by disconnecting the device connected to the HDMI port of the Sink Platform. Validating whether the CEC Transmission (use Polling command) works when the HDMI port is disconnected should result in ACK not being received while the TX still works as expected. HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control Panel to control the Hotplug activities Check the behaviour when a device has been remove from the network which is not directly connected to the TV device.  Send a CEC Tx command with acknowledgement using HAL Interface and check the behaviour. The Tx command should succeed, but the message should not be Acknowledged. HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control Panel to control the external devices connected."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#emulator-requirements-cec-hotplug-functionality","title":"Emulator Requirements - CEC HotPlug Functionality","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#control-plane-requirements-cec-hotplug-functionality","title":"Control Plane Requirements - CEC HotPlug Functionality","text":"<ol> <li>Control plane to initiate the HotPlug activity by commanding an IP power switch to the OFF State to which the Node device is connected.</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#-","title":"-----------","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#hardware-verification-testing-requirements","title":"Hardware Verification Testing Requirements","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 7 Introduce fault in the CEC Bus Observe the behaviour when the CEC line is pulled high during the CEC Transmission using a CEC Adaptor that provision to keep the CEC line pulled high HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y CEC Adaptor used shall have a provision to introduce the fault. The control plane should be able to command to pull the CEC line high, else it should follow a manual process 8 Overloading the CEC bus. Overload the CEC bus with too many messages  (by connecting more devices in the network) and observe the behaviour HdmiCecAddLogicalAddress, HdmiCecTx, HdmiCecRemoveLogicalAddress NA Y Control plane to initiate the CEC Transmission through all the connected devices continuously with a command that expects the response as well to overload the CEC Network."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#emulator-requirements-hardware-verification","title":"Emulator Requirements - Hardware verification","text":"<ol> <li>Emulator to support the HDMI_CEC_IO_SENT_FAILED during the above scenarios</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#control-plane-requirements","title":"Control Plane Requirements","text":"<ol> <li> <p>Control Plane to control the external devices to pull the CEC line high.</p> </li> <li> <p>Control Plan to initiate multiple CEC commands from the different devices connected to the network.</p> </li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#-_1","title":"-----------","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#boot-configuartion","title":"Boot configuartion","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#module-configuration-requirements","title":"Module Configuration Requirements","text":"<p>The module must be configured during the boot sequence in the case of emulation as if it were a real hardware device with or without multiple connected HDMI nodes.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_High-Level_TestSpec/#test-configuration-for-sink-devices","title":"Test Configuration for Sink Devices","text":"<p>The following information shall be helpful for further running the Automation Rack Test for this specific module and further configuration will help for the Design and Development of Virtual Device.</p> <p>Configurations:</p> <pre><code>  Device:\n    Type: Source / Sink\n    Platform_Manufacturer: sony/Samsung etc.\n    Platform_Model:  xyz\n    Port: 3, 4\n    HDMI Node: 1-3 etc.\n    CEC_Ports: 1, x, y\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/","title":"HDMI CEC Sink L2 Low-Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the level 2 Low-Level Test Specification and Procedure Documentation for the HDMI CEC Sink module.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>  - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>   - Unit Test(s)</li> <li><code>HDMI</code> - High-Definition Multimedia Interface</li> <li><code>CEC</code>  - Consumer Electronics Control</li> <li><code>DUT</code>  - Device Under Test</li> <li><code>API</code>  - Application Program Interface</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps an open-source framework that can be expanded to the requirements for future frameworks.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - hdmi-cec-sink_High-Level_TestSpec.md</li> <li><code>HDMI CEC HAL Interface file</code> - hdmi_cec_driver.h</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are intended to test the HDMI CEC HAL module's operation on sink devices according to the L2 Test specification.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_hdmi_cec_sink_hal_GetDefaultLogicalAddress</code> Description Get the logical address of the <code>DUT</code> without actually adding the Logical Address and the API should return 0x0F as the default logical address. Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions: None</p> <p>Dependencies: None</p> <p>User Interaction: If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Call the pre-requisite API HdmiCecOpen() handle = 0 HDMI_CEC_IO_SUCCESS Should be successful 02 Call the API HdmiCecGetLogicalAddress() handle = valid handle, logicalAddress = 0 HDMI_CEC_IO_SUCCESS Should be successful 03 Check the logical address logicalAddress = 0x0F Should be successful 04 Call the post-requisite API HdmiCecClose() handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\nA[Call HdmiCecOpen] --&gt;|HDMI_CEC_IO_SUCCESS| B[Call HdmiCecGetLogicalAddress]\nA --&gt;|Failure| A1[Test case fail]\nB --&gt;|HDMI_CEC_IO_SUCCESS| C[Check logical address]\nB --&gt;|Failure| B1[Test case fail]\nC --&gt;|Logical address is 0x0F| D[Call HdmiCecClose]\nC --&gt;|Logical address is not 0x0F| C1[Test case fail]\nD --&gt;|HDMI_CEC_IO_SUCCESS| E[Test case pass]\nD --&gt;|Failure| D1[Test case fail]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_hdmi_cec_sink_hal_AddAndGetLogicalAddress</code> Description Setup all valid logical addresses b/w 0x00 to 0x0F for the <code>DUT</code> and retrieve each to ensure proper functionality, using HAL APIs. Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions: None</p> <p>Dependencies: None</p> <p>User Interaction: If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-procedure-test-2","title":"Test Procedure Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Open HDMI CEC HAL using HdmiCecOpen API handle = valid pointer HDMI_CEC_IO_SUCCESS Should be successful 02 Loop over the range of valid logical addresses (0x00 to 0x0F) i = 0 to 0x0F N/A N/A 03 Add logical address using HdmiCecAddLogicalAddress API handle = valid handle, logicalAddress = i HDMI_CEC_IO_SUCCESS Should be successful 04 Retrieve logical address using HdmiCecGetLogicalAddress API handle = valid handle, logicalAddress = valid pointer HDMI_CEC_IO_SUCCESS, logicalAddress = i Should be successful 05 Remove logical address using HdmiCecRemoveLogicalAddress API handle = valid handle, logicalAddress = i HDMI_CEC_IO_SUCCESS Should be successful 06 Close HDMI CEC HAL using HdmiCecClose API handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\nA[HdmiCecOpen] --&gt;|HDMI_CEC_IO_SUCCESS| B{Loop 0x00 to 0x0F}\nB --&gt; |HDMI_CEC_IO_SUCCESS| C[HdmiCecAddLogicalAddress]\nC --&gt; |HDMI_CEC_IO_SUCCESS| D[HdmiCecGetLogicalAddress]\nD --&gt; |HDMI_CEC_IO_SUCCESS &amp; Address Match| E[HdmiCecRemoveLogicalAddress]\nE --&gt; |HDMI_CEC_IO_SUCCESS| B\nB --&gt; |End of Loop| F[HdmiCecClose]\nA --&gt;|Failure| G[Test case fail]\nF --&gt;|Failure| K[Test case fail]\nF --&gt;|HDMI_CEC_IO_SUCCESS| L[Test case success]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_hdmi_cec_sink_hal_RemoveLogicalAddress</code> Description Invoke the HAL API to delete the <code>DUT</code> logical address and verify that it is removed successfully. Test Group 02 Test Case ID 003 Priority High <p>Pre-Conditions: None</p> <p>Dependencies: None</p> <p>User Interaction: If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-procedure-test-3","title":"Test Procedure Test 3","text":"Variation / Steps Description Test Data Expected Result Notes 01 Open the HDMI CEC HAL using HdmiCecOpen API handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful 02 Add a logical address using HdmiCecAddLogicalAddress API handle = valid handle, logicalAddress = 0x00 HDMI_CEC_IO_SUCCESS Should be successful 03 Get the logical address using HdmiCecGetLogicalAddress API handle = valid handle, logicalAddress = valid buffer HDMI_CEC_IO_SUCCESS , logicalAddress = 0x00 Should be successful 04 Remove the logical address using HdmiCecRemoveLogicalAddress API handle = valid handle, logicalAddress = 0x00 HDMI_CEC_IO_SUCCESS Should be successful 05 Get the logical address using HdmiCecGetLogicalAddress API handle = valid handle, logicalAddress = valid buffer HDMI_CEC_IO_SUCCESS , logicalAddress = 0x0F Should be successful 06 Close the HDMI CEC HAL using HdmiCecClose API handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\nA[HdmiCecOpen] -- \"HDMI_CEC_IO_SUCCESS\" --&gt; B[HdmiCecAddLogicalAddress]\nA -- \"Failure\" --&gt; A1[Test case fail]\nB -- \"HDMI_CEC_IO_SUCCESS\" --&gt; C[HdmiCecGetLogicalAddress]\nB -- \"Failure\" --&gt; B1[Test case fail]\nC -- \"HDMI_CEC_IO_SUCCESS &amp; Logical Address = current logical address\" --&gt; D[HdmiCecRemoveLogicalAddress]\nC -- \"Failure\" --&gt; C1[Test case fail]\nD --\"HDMI_CEC_IO_SUCCESS\" --&gt;E[HdmiCecGetLogicalAddress]\nD -- \"Failure\" --&gt; D1[Test case fail]\nE -- \"HDMI_CEC_IO_SUCCESS &amp; Logical Address = 0x0F\" --&gt; F[HdmiCecClose]\nE -- \"Failure\" --&gt; E1[Test case fail]\nF -- \"HDMI_CEC_IO_SUCCESS\" --&gt; G[Test case pass]\nF -- \"Failure\" --&gt; F1[Test case fail]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-4","title":"Test 4","text":"Title Details Function Name <code>test_l2_hdmi_cec_sink_hal_BroadcastHdmiCecCommand</code> Description After deleting the <code>DUT</code> logical address, try to send a broadcast CEC Command (as per 1.4b HDMI CEC spec) and confirm transmission is successful. Test Group 02 Test Case ID 004 Priority High <p>Pre-Conditions: None</p> <p>Dependencies: None</p> <p>User Interaction: If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-procedure-test-4","title":"Test Procedure Test 4","text":"Variation / Steps Description Test Data Expected Result Notes 01 Open HDMI CEC using HdmiCecOpen handle = valid buffer HDMI_CEC_IO_SUCCESS Should be successful 02 Add logical address using HdmiCecAddLogicalAddress handle = valid handle, logicalAddresses = 0x0 HDMI_CEC_IO_SUCCESS Should be successful 03 Remove logical address using HdmiCecRemoveLogicalAddress handle = valid handle, logicalAddresses = 0x0 HDMI_CEC_IO_SUCCESS Should be successful 04 Broadast CEC message using HdmiCecTx handle = valid handle, buf = {0x0F, 0x84, 0x00, 0x00}, len = sizeof(buf), result = valid buffer HDMI_CEC_IO_SUCCESS Should be successful 05 Check the result of transmission result = valid buffer HDMI_CEC_IO_SENT_BUT_NOT_ACKD Should be successful 06 Close HDMI CEC using HdmiCecClose handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\nA[HdmiCecOpen] -- \"HDMI_CEC_IO_SUCCESS\" --&gt; B[HdmiCecAddLogicalAddress]\nA -- \"Failure\" --&gt; A1[Test case fail]\nB -- \"HDMI_CEC_IO_SUCCESS\" --&gt; C[HdmiCecRemoveLogicalAddress]\nB -- \"Failure\" --&gt; B1[Test case fail]\nC -- \"HDMI_CEC_IO_SUCCESS\" --&gt; D[HdmiCecTx]\nC -- \"Failure\" --&gt; C1[Test case fail]\nD -- \"HDMI_CEC_IO_SUCCESS\" --&gt; E[Check HdmiCecTx result]\nD -- \"Failure\" --&gt; D1[Test case fail]\nE -- \"HDMI_CEC_IO_SENT_AND_ACKD\" --&gt; F[HdmiCecClose]\nE -- \"Failure\" --&gt; E1[Test case fail]\nF -- \"HDMI_CEC_IO_SUCCESS\" --&gt; G[Test case success]\nF -- \"Failure\" --&gt; F1[Test case fail]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-5","title":"Test 5","text":"Title Details Function Name <code>test_l2_hdmi_cec_sink_hal_VerifyPhysicalAddress</code> Description Verify the valid physical address allocated through the HAL function. Test Group 02 Test Case ID 005 Priority High <p>Pre-Conditions: None</p> <p>Dependencies: None</p> <p>User Interaction: If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-procedure-test-5","title":"Test Procedure Test 5","text":"Variation / Steps Description Test Data Expected Result Notes 01 Call the pre-requisite API HdmiCecOpen() handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful 02 Call the API HdmiCecGetPhysicalAddress() handle = valid handle, physicalAddress = valid address HDMI_CEC_IO_SUCCESS Should be successful 03 Check the return status of HdmiCecGetPhysicalAddress() status = return status of HdmiCecGetPhysicalAddress() HDMI_CEC_IO_SUCCESS Should be successful 04 Verify that the physical address obtained is equal to 0.0.0.0 physicalAddress = obtained physical address physicalAddress == 0x0000 (as per HDMI Spec 1.4b and section 8.7.2) Should be successful 05 Call the post-requisite API HdmiCecClose() handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\nA[HdmiCecOpen] --&gt;|HDMI_CEC_IO_SUCCESS| B[HdmiCecGetPhysicalAddress]\nB --&gt;|HDMI_CEC_IO_SUCCESS| C{Verify Physical Address == 0.0.0.0}\nB --&gt;|Failure| B1[Test case fail]\nC --&gt;|Success| D[HdmiCecClose]\nC --&gt;|Failure| C1[Test case fail]\nD --&gt;|HDMI_CEC_IO_SUCCESS| E[Test case success]\nD --&gt;|Failure| D1[Test case fail]\nA --&gt;|Failure| A1[Test case fail]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-6","title":"Test 6","text":"Title Details Function Name <code>test_l2_hdmi_cec_sink_hal_TransmitCECCommand</code> Description DUT transmits a CEC Command (as per 1.4b HDMI CEC spec) to get the CEC version of the device that doesn't exist. Test Group 02 Test Case ID 006 Priority High <p>Pre-Conditions: None</p> <p>Dependencies: None</p> <p>User Interaction: If the user chooses to run the test in interactive mode, then the test case has to be selected via the console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-sink_L2_Low-Level_TestSpec/#test-procedure-test-6","title":"Test Procedure Test 6","text":"Variation / Steps Description Test Data Expected Result Notes 01 Open HDMI CEC HAL using HdmiCecOpen handle = valid buffer HDMI_CEC_IO_SUCCESS Should be successful 02 Add logical address using HdmiCecAddLogicalAddress handle = valid handle, logicalAddresses = 0x0 HDMI_CEC_IO_SUCCESS Should be successful 03 Transmit CEC command using HdmiCecTx for a non existing device handle = valid handle, buf = {0x47, 0x9F}, len = sizeof(buf), result = valid buffer HDMI_CEC_IO_SUCCESS, result = HDMI_CEC_IO_SENT_BUT_NOT_ACKD Should be successful 04 Remove logical address using HdmiCecRemoveLogicalAddress handle = valid handle, logicalAddresses = 0x4 HDMI_CEC_IO_SUCCESS Should be successful 05 Close HDMI CEC HAL using HdmiCecClose handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\nA[HdmiCecOpen] -- \"HDMI_CEC_IO_SUCCESS\" --&gt; B[HdmiCecAddLogicalAddress]\nA -- \"Not HDMI_CEC_IO_SUCCESS\" --&gt; A1[Test case fail]\nB -- \"HDMI_CEC_IO_SUCCESS\" --&gt; C[Prepare CEC message]\nB -- \"Not HDMI_CEC_IO_SUCCESS\" --&gt; B1[Test case fail]\nC --&gt; D[HdmiCecTx]\nD -- \"HDMI_CEC_IO_SENT_BUT_NOT_ACKD\" --&gt; E[HdmiCecRemoveLogicalAddress]\nD -- \"Not HDMI_CEC_IO_SENT_BUT_NOT_ACKD\" --&gt; D1[Test case fail]\nE -- \"HDMI_CEC_IO_SUCCESS\" --&gt; F[HdmiCecClose]\nE -- \"Not HDMI_CEC_IO_SUCCESS\" --&gt; E1[Test case fail]\nF -- \"HDMI_CEC_IO_SUCCESS\" --&gt; G[Test case success]\nF -- \"Not HDMI_CEC_IO_SUCCESS\" --&gt; F1[Test case fail]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/","title":"HDMI CEC Test Document","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>HDMI-CEC RDK HAL Functionality</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>CEC</code>  - Consumer Electronics Control</li> <li><code>HAL</code>  - Hardware Abstraction layer</li> <li><code>HDMI</code> - High Definition Multimedia Interface</li> <li><code>L2</code>   - Level 2 Testing ()</li> <li><code>L3</code>   - Level 3 Testing ()</li> <li><code>DUT</code>  - Device Under Test</li> <li><code>Sink device</code> - An equipment or technology that receives an input signal or data from another device or system.</li> <li><code>Source Device</code> - An equipment or technology that provides an input signal or data to another device or system.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#scope","title":"Scope","text":"<p>This document defines the requirements for testing the HDMI CEC device from a level 2/3 based on being a source device.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#overview","title":"Overview","text":"<p>Consumer Electronics Control (CEC) is a single-wire bidirectional bus within an HDMI system, facilitating communication among interconnected products. HDMI-CEC establishes a protocol enabling high-level control functions between audiovisual devices linked via an HDMI network, facilitating communication and control among them. Communication can occur in either Direct messaging mode or Broadcast mode. </p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#hdmi-cec-rdk-hal-functionality","title":"HDMI-CEC RDK HAL Functionality","text":"<p>The HAL layers within RDK serve as a bridge between the underlying low-level SoC drivers and the higher-level RDK layers that utilize the functionality offered by these HAL functions. Specifically concerning the CEC Module, the HAL layers facilitate the following functionalities:</p> <ul> <li>Logical Address discovery </li> <li>Get a Logical address</li> <li>Get a Physical address</li> <li>Synchronous transmission, and communication via hotplug connectivity</li> </ul> <p>The interface of the test is available here: Hdmicec HAL header</p> <p>The Hdmicec Hal Spec document: Hdmicec HAL Spec</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#test-scenarios","title":"Test scenarios","text":"<p>The HAL CEC layer facilitates the transmission and reception of CEC information on the CEC bus. It does not handle any specific opcode commands, nor does it validate supported HAL CEC opcodes for sending or receiving.</p> <p>The caller is responsible for managing the opcodes. The current test cases will verify responses from connected devices for a subset of opcodes as part of the testing process.</p> S.No. Test Functionality Description 1 Logical address Facilitating the Discovery of logical addresses by getting the logical address of the device (for source devices) 2 Physical Address Retrieving the physical address 3 CEC Synchronous Transmission Transmitting CEC frames and reporting on their acknowledgement 4 CEC Receive functionality Receiving CEC information from other devices and passing it to the layer above through a registered callback function 5 CEC HotPlug Functionality Managing CEC during Hotplug and HotUnplug events"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#logical-address-discovery","title":"Logical Address Discovery","text":"Description HAL APIs L2 L3 Control plane requirements Trying to get a logical address discovered during CEC open, and validate the return value when the <code>DUT</code> is not connected to a Sink device. It should return HDMI_CEC_IO_LOGICALADDRESS_UNAVAILABLE. HdmiCecOpen Y N Get the logical address discovered during CEC open and validate the address for a proper playback/tuner device. This will add the logical address, as per source functionality. As the connected device will be a playback device, the valid logical address would be 4, 8, and 11. HdmiCecOpen HdmiCecGetLogicalAddress N Y Connect 5 playback devices using a switch, and attempt to discover a logical address with the fifth device, which exceeds the number of logical ports for playback devices. It should return HDMI_CEC_IO_LOGICALADDRESS_UNAVAILABLE HdmiCecOpen N Y Rapidly connect and disconnect HDMI connection in 100ms connection and 100ms disconnection cycle. HdmiCecOpen  HdmiCecGetLogicalAddress N Y"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#emulator-requirements","title":"Emulator Requirements","text":"<ul> <li>Boot with control configuration with various configurations having a predefined set of nodes:</li> <li>configuration to support the discovery of logical addresses. The caller creates a proper logical address during Open and that should be provided when HdmiCecOpen is used.</li> <li>Verify for the valid logical address and return the appropriate error code based on the logical address availability.  </li> <li>The emulator should simulate the logical address that a source device can provide.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#control-plane-requirements","title":"Control Plane Requirements","text":"<ul> <li>The control plane will allow removing or adding a node to the network.</li> <li>allowing adding/removing source node</li> <li>Allow adding/removing of sink node</li> <li>allow the use of multiple source nodes</li> <li>Support the CEC commands from the external devices on L3 Test Cases. </li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#physical-address","title":"Physical Address","text":"Description HAL APIs L2 L3 Control plane requirements Enable a sink device connected to the DUT first to get the valid physical address allocated through the HAL function. The physical address should be 1.0.0.0 HdmiCecGetPhysicalAddress N Y Verify the physical addresses allocated by connecting a source and sink device through an HDMI switch. The physical address should 1.1.0.0 HdmiCecGetPhysicalAddress N Y Enable the television connected to <code>DUT</code> to declare its physical address first before <code>DUT</code>. Connect a sink device to the source device, get the physical address. Disconnect the sink device and attempt to get the physical address again HdmiCecGetPhysicalAddress N Y <p>@note Calling HdmiCecGetPhysicalAddress when no device is connected to <code>DUT</code> is not a valid test because HdmiCecOpen has not been initiated.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#emulator-requirements-physical-address","title":"Emulator Requirements - Physical Address","text":"<ul> <li>Boot control configuration to setup the CEC network nodes<ul> <li>Emulator to provide a valid physical address when requested.</li> </ul> </li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#control-plane-requirements-physical-address","title":"Control Plane Requirements - Physical Address","text":"<ul> <li>The control plane will allow removing or adding a node to the network.</li> <li>allowing add source node before the <code>DUT</code> switched ON.  </li> <li>allowing add sink node before the <code>DUT</code> switched ON.    </li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#cec-synchronous-transmission","title":"CEC Synchronous Transmission","text":"Description HAL APIs L2 L3 Control plane requirements Transmit a CEC Command (as per 1.4b HDMI CEC spec) to get the CEC Version for a logical address that doesn't exist after the connected device is disconnected. Result should return HDMI_CEC_IO_SENT_BUT_NOT_ACKD. HdmiCecTx N Y Control plane can unplug or switch off a previously existing CEC device Transmit a CEC Command (as per 1.4b HDMI CEC spec) to get the CEC Version for supported CEC commands (as per 1.4b HDMI CEC spec) after the connected device is disconnected. Result should return HDMI_CEC_IO_SENT_BUT_NOT_ACKD. HdmiCecTx N Y Control plane can unplug or switch off a previously existing CEC device Verify the correct transmission of the supported CEC commands (as per 1.4b HDMI CEC spec) to the connected device and ensure it is acknowledged properly. The result should return HDMI_CEC_IO_SENT_AND_ACKD. HdmiCecTx N Y Control plane to switch ON a CEC-supported device on the HDMI network so that it shall respond to the basic commands Broadcast a supported CEC Command to all the devices connected to the network without any error. The result should return HDMI_CEC_IO_SENT_AND_ACKD HdmiCecTx N Y Control plane to switch ON a CEC-supported device on the HDMI network to act on the broadcasted command Transmit a CEC Command (as per 1.4b HDMI CEC spec) to put the connected device into standby mode and await the device's response. Monitoring the behavior of the connected device accordingly. The result should return HDMI_CEC_IO_SENT_AND_ACKD. HdmiCecTx N Y Control plane to monitor the behavior of the connected devices."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#emulator-requirements-cec-transmission","title":"Emulator Requirements - CEC Transmission","text":"<ul> <li>Boot configuration</li> <li>Min case scenario multiple network nodes</li> <li>Max case scenario multiple cec nodes</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#control-plane-requirements-cec-transmission","title":"Control Plane Requirements - CEC Transmission","text":"<ul> <li>The control plane will allow adding a device that can respond to the CEC Frames sent by <code>DUT</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#cec-receive-functionality","title":"CEC Receive functionality","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 5 CEC Receive functionality Transmit a CEC Command that expects a response (Eg. GetCECVersion) to a connected device and see the response is received correctly. Set the Rx Callback before sending the data. Validate the received CEC Version. HdmiCecSetRxCallback HdmiCecTx N Y Control plane to switch ON a CEC device that can respond to the Transmitted CEC Command Transmit a CEC command from the connected devices and consider the Acknowledgement and responses are received correctly from the host device (<code>DUT</code> TV here) HdmiCecSetRxCallback N Y Control panel to control the third-party devices to Transmit the required commands to  <code>DUT</code> Transmit an OSD CEC command from the connected devices and consider the Acknowledgement and responses are received correctly from the host device (<code>DUT</code> TV here). Make the OSD String to max length HdmiCecSetRxCallback N Y Control panel to control the third-party devices to Transmit the required commands to  <code>DUT</code> Transmit an OSD CEC command from the connected devices continuously for 30 seconds changing the patterns in the payload and considering the Acknowledgement and responses are received correctly from the host device (<code>DUT</code> TV here). Make the OSD String to max length HdmiCecSetRxCallback N Y Control panel to control the third-party devices to Transmit the required commands to  <code>DUT</code>. Also, Control plane to detect the OSD Display on the Sink device to validate Set the Logical address to 0 on <code>DUT</code> and make sure that it doesn't receive the messages sent to devices with different logical address. HdmiCecSetRxCallback N Y Control Plane to initiate a command to send CEC frames from CEC adaptor with a different logical address other than zero"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#emulator-requirements-cec-receive-functionality","title":"Emulator Requirements - CEC Receive functionality","text":"<ol> <li>Emulate the Tx and Rx HAL functionalities with the required responses.</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#control-plane-requirements-cec-transmission_1","title":"Control Plane Requirements - CEC Transmission","text":"<ul> <li>The control plane will allow adding a device that can respond to the CEC Frames sent by <code>DUT</code></li> <li>The control plane to initiate CEC Transmissions from the connected devices as expected by the <code>DUT</code></li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#cec-hotplug-functionality","title":"CEC HotPlug Functionality","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 6 CEC HotPlug Functionality Generate a Hotplug event by disconnecting the device connected to the HDMI port of the Source Platform. Validating whether the CEC Transmission (use Polling command) works when the HDMI port is disconnected should result in ACK not being received while the TX still works as expected. HdmiCecTx N Y Control Panel to control the Hotplug activities Check the behaviour when a device has been remove from the network which is not directly connected to the TV device.  Send a CEC Tx command with acknowledgment using HAL Interface and check the behaviour. The Tx command should succeed, but the message should not be Acknowledged. HdmiCecTx N Y Control Panel to control the external devices connected."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#emulator-requirements-cec-hotplug-functionality","title":"Emulator Requirements - CEC HotPlug Functionality","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#control-plane-requirements-cec-hotplug-functionality","title":"Control Plane Requirements - CEC HotPlug Functionality","text":"<ol> <li>Control plane to initiate the HotPlug activity by commanding an IP power switch to the OFF State to which the Node device is connected.</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#-","title":"-----------","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#hardware-verification-testing-requirements","title":"Hardware Verification Testing Requirements","text":"S.No. Test Functionality Description HAL APIs L2 L3 Control plane requirements 7 Introduce fault in the CEC Bus Observe the behaviour when the CEC line is pulled high during the CEC Transmission using a CEC Adaptor that provision to keep the CEC line pulled high HdmiCecTx N Y CEC Adaptor used shall have a provision to introduce the fault. The control plane should be able to command to pull the CEC line high, else it should follow a manual process 8 Overloading the CEC bus. Overload the CEC bus with too many messages  (by connecting more devices in the network) and observe the behaviour HdmiCecTx N Y Control plane to initiate the CEC Transmission through all the connected devices continuously with a command that expects the response as well to overload the CEC Network."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#emulator-requirements_1","title":"Emulator Requirements","text":"<ol> <li>Emulator to support the HDMI_CEC_IO_SENT_FAILED during the above scenarios</li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#control-plane-requirements_1","title":"Control Plane Requirements","text":"<ol> <li>Control Plane to control the external devices to pull the CEC line high.</li> <li>Control Plan to initiate multiple CEC commands from the different devices connected to the network. </li> </ol>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#boot-configuartion","title":"Boot configuartion","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#module-configuration-requirements","title":"Module Configuration Requirements","text":"<p>The module must be configured during the boot sequence in the case of emulation as if it were a real hardware device with or without multiple connected HDMI nodes.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_High-Level_TestSpec/#test-configuration-for-source-devices","title":"Test Configuration for Source Devices","text":"<p>The following information shall be helpful for further running the Automation Rack Test for this specific module and further configuration will help for the Design and Development of Virtual Device.</p> <p>Configurations:</p> <pre><code>  Device:\n    Type: Source / Sink\n    Platform_Manufacturer: sony/Samsung etc.\n    Platform_Model:  xyz\n    Port: 3, 4\n    HDMI Node: 1-3 etc.\n    CEC_Ports: 1, x, y\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/","title":"HDMI CEC Source L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the Source level 2 Low Level Test Specification and Procedure Documentation for the HDMI CEC HAL module Source.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - hdmi-cec-source_High-Level_TestSpec.md</li> <li><code>HDMI CEC HAL Interface file</code> - hdmi_cec_driver.h</li> </ul>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_hdmi_cec_source_hal_ValidateLogicalAddressUnavailability_source</code> Description Trying to get a logical address discovered during CEC open and validate the return value when the <code>DUT</code> is not connected to a Sink device. It should return HDMI_CEC_IO_LOGICALADDRESS_UNAVAILABLE. Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi-cec-source_L2_Low-Level_TestSpec/#test-procedure","title":"Test Procedure","text":"Variation / Steps Description Test Data Expected Result Notes 01 Invoke HdmiCecOpen with a valid handle when the <code>DUT</code> is not connected to a Sink device handle = valid handle HDMI_CEC_IO_LOGICALADDRESS_UNAVAILABLE Should be successful 02 If the status is HDMI_CEC_IO_SUCCESS, invoke HdmiCecClose with the handle handle = valid handle HDMI_CEC_IO_SUCCESS Should be successful <pre><code>graph TB\n    Step1[Call HdmiCecOpen] --&gt;|Success| Step2[Check returned status]\n    Step1 --&gt;|Failure| TestFail1[Test Case Failed: HdmiCecOpen failed]\n    Step2 --&gt;|Status is &lt;br&gt; HDMI_CEC_IO_LOGICALADDRESS_UNAVAILABLE| Step4[TestCase Success]\n    Step2 --&gt;|Status is &lt;br&gt; HDMI_CEC_IO_SUCCESS or HDMI_CEC_IO_ALREADY_OPEN| TestFail2[Test Case Failed]\n    TestFail2 --&gt;|Status is HDMI_CEC_IO_SUCCESS| Step3[Call HdmiCecClose]\n    Step3 --&gt;|Success| Step5[HdmiCecClose success]\n    Step3 --&gt;|Failure| TestFail3[Test Case Failed: HdmiCecClose failed]</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/","title":"hdmi_cec_VirtualComponent_ControlPlaneCommands","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#overview-of-hdmi-cec-virtual-component-control-plane-commands","title":"Overview of HDMI-CEC Virtual Component Control Plane Commands","text":"<p>The HDMI-CEC virtual component enables comprehensive testing of HDMI-CEC functionalities through the control plane. Testers can interact with the virtual component using four primary types of commands, each serving a distinct purpose:</p> <p>Command: Directly trigger specific HDMI-CEC commands between devices, simulating real-world user interactions.</p> <p>Event: Simulate HDMI-CEC events like hotplug (device connection/disconnection) to test how devices react.</p> <p>Config: Modify the virtual CEC network configuration, changing device types, connections, and capabilities.</p> <p>State: Dynamically add or remove devices during testing and print the current status for debugging.</p> <p>Each command type is structured as a YAML payload, which is outlined in detail in the following sections. These payloads allow testers to precisely control the virtual HDMI-CEC environment, replicating various scenarios and edge cases.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#1-command","title":"1. Command","text":"<p>HDMI Consumer Electronics Control (CEC) commands are designed to allow control of multiple devices through a single remote control and enable devices to communicate with each other. These commands are categorized based on their functionalities and the end-user features they support.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-cec-command","title":"Example YAML CEC Command","text":"<pre><code>---\nhdmicec:\n  command: SetOsdName\n  initiator: Sony HomeTheatre\n  destination: IPSTB\n  parameters:\n    osd_name: IPSTB\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#2-event","title":"2. Event","text":"<p>This category of messages allow the test user to trigger changes in the virtual component state machine.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-event","title":"Example Event","text":"<p>Command to trigger a hotplug event from device connected in Port 2: <pre><code>hdmicec:\n    command: hotplug\n    port: 2\n    connected: false\n</code></pre></p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#3-config","title":"3. Config","text":"<p>Test user can also trigger a re-configuration of the initial profile with which the emulator state machine was set up, like the device type (Sink or Source) and the list of devices in the network etc.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-config-change-trigger","title":"Example config change trigger","text":"<pre><code>---\nhdmicec:\n  config:\n    emulated_device: IPSTB\n    number_ports: 1\n    ports:\n      - id: 1\n        type: out\n        cec_supported: true\n        arc_supported: false\n    number_devices: 3\n    device_map:\n      - name: Sony TV\n        type: TV\n        version: 4\n        active_source: false\n        vendor_info: SONY\n        pwr_status: on\n        number_chlidren: 2\n        children:\n         -  name: IPSTB\n            type: PlaybackDevice\n            version: 4 \n            active_source: true\n            vendor: TEST_VENDOR\n            pwr_status: on\n            port_id: 1\n            num_children: 0\n\n         -  name: Chromecast\n            type: PlaybackDevice\n            version: 4\n            active_source: false\n            vendor: GOOGLE\n            pwr_status: on\n            port_id: 1\n            num_children: 0\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#4-state","title":"4. State","text":"<p>Test user can trigger state changes by dynamically adding or removing device(s). Debug printing of the current status of virtual component in logs can also be triggered.</p> Status YAML Payload Action <code>AddDevice</code> <pre>---\rhdmicec:\r  state: AddDevice\r  parameters:\r    parent: TV\r   name: TestDevice\r    type: PlaybackDevice\r    version: 4\r    active_source: false\r    vendor: TEST_VENDOR\r    pwr_status: on\r    port_id: 2\r    number_children: 0</pre> Adds the new device as a child to given parent <code>RemoveDevice</code> <pre>---\rhdmicec:\r  state: RemoveDevice\r  parameters:\r    name: TestDevice\r</pre> Removes a device and its children from the Virtual Component state. <code>PrintStatus</code> <pre>---\rhdmicec:\r  state: PrintStatus\r  parameters:\r    status: Devices</pre> Prints the current network of devices"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters-for-printstatus","title":"Parameters for <code>PrintStatus</code>","text":"Parameter Description Values <code>status</code> Specific status <code>Devices</code>, <code>Ports</code>, <code>General</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-state-trigger-to-add-a-new-device-to-a-parent-port","title":"Example state trigger to add a new device to a parent port.","text":"<pre><code>hdmicec:\n    state: AddDevice\n    prameters:\n       parent: TV\n       name: TestDevice\n       type: PlaybackDevice\n       version: 4\n       active_source: false\n       vendor: TEST_VENDOR\n       pwr_status: on\n       port_id: 2\n       number_children: 0\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-state-trigger-to-print-status-of-devices-connected","title":"Example state trigger to print status of devices connected","text":"<pre><code>hdmicec:\n    state: PrintStatus\n    parameters:\n       status: Devices\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#anatomy-of-the-yaml-cec-command","title":"Anatomy of the YAML CEC Command","text":"<p>The YAML representation of CEC commands provides a structured and human-readable format for defining and triggering HDMI-CEC commands. These YAML commands closely follow the CEC specifications but are more descriptive in nature.</p> <pre><code>---\nhdmicec:\n  command: # The CEC command to be executed (e.g., SetOsdName, ActiveSource, UserControlPressed, etc.)\n  initiator: # The device sending the command (e.g., Sony HomeTheatre, IPSTB, TV, etc.)\n  destination: # The device receiving the command (e.g., TV, IPSTB, Broadcast, etc.)\n  parameters: # Optional: Additional parameters required for the command\n    # Add specific parameters below as needed for the command\n    osd_name: # Example: OSD name to be set (for SetOsdName command)\n    device_name: # Example: Physical address of the device (for ActiveSource or ReportPhysicalAddress commands)\n    ui_command: # Example: User interface command (for UserControlPressed command)\n    device_type: # Example: Device type (for ReportPhysicalAddress command)\n    deck_info: # Example: Deck status information (for DeckStatus command)\n    tuner_info: # Example: Tuner status information\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#components-of-the-yaml-cec-command","title":"Components of the YAML CEC Command","text":""},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#root-element-hdmicec","title":"Root Element (hdmicec):","text":"<p>The root element of the YAML file, indicating that this is a CEC command.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#command","title":"Command:","text":"<p>The command key specifies the CEC command to be executed. Example: SetOsdName is the command to set the On-Screen Display name of a device.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#initiator","title":"Initiator:","text":"<p>The initiator key indicates the device that is sending the command. All devices are identified by its unique name that is configured in the profile YAML. The virtual component takes care of converting the device names into physical and logical addresses internaly.</p> <p>Example: Sony HomeTheatre is the device initiating the command.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#destination","title":"Destination:","text":"<p>The destination key specifies the target device that will receive the command. Example: IPSTB is the device receiving the command.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters","title":"Parameters:","text":"<p>The parameters key holds a dictionary of additional data required for the command. Example: For the SetOsdName command, the parameters section includes an osd_name key with the value IPSTB.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#using-the-parameters-section-in-different-cec-commands","title":"Using the Parameters Section in Different CEC Commands","text":"<p>The <code>parameters</code> section in the YAML CEC command is used to provide additional data required for executing specific CEC commands. The parameters vary depending on the command being issued. Below are examples and descriptions of how the <code>parameters</code> section can be used in different CEC commands.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-1-setosdname","title":"Example 1: SetOsdName","text":"<p>The <code>SetOsdName</code> command sets the On-Screen Display (OSD) name for a device. This command requires an <code>osd_name</code> parameter to specify the name to be set.</p> <pre><code>---\nhdmicec:\n  command: SetOsdName\n  initiator: Sony HomeTheatre\n  destination: IPSTB\n  parameters:\n    osd_name: IPSTB\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-2-activesource","title":"Example 2: ActiveSource","text":"<p>The ActiveSource command is used to indicate which device is currently the active source. This command requires a physical_address parameter. <pre><code>---\nhdmicec:\n  command: ActiveSource\n  initiator: IPSTB\n  destination: TV\n  parameters:\n    physical_address: 0x1000\n</code></pre></p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-3-usercontrolpressed","title":"Example 3: UserControlPressed","text":"<p>The UserControlPressed command simulates a button press on the remote control. This command requires a ui_command parameter to specify the user interface command. <pre><code>---\nhdmicec:\n  command: UserControlPressed\n  initiator: TV\n  destination: IPSTB\n  parameters:\n    ui_command: Select\n</code></pre></p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#hdmi-cec-command-categories-based-on-end-user-features","title":"HDMI-CEC Command Categories Based on End User Features","text":"<p>HDMI CEC commands are categorized based on their functionalities and the end-user features they support.</p> <p>Below are some of the commonly used categories of CEC commands:</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#1-one-touch-play","title":"1. One Touch Play","text":"<p>Commands in this category are used to turn on devices and switch them to the correct input automatically.</p> Command YAML Payload Action How to Trigger in Real Setup <code>ActiveSource</code> <pre>---\rhdmicec:\r  command: \"ActiveSource\"\r  initiator: \"IPSTB\"\r  destination: \"Broadcast\"\r  parameters:\r    device_name: \"TV\"</pre> Announces that the initiator is the active source Automatically triggered when a device becomes active <code>ImageViewOn</code> <pre>---\rhdmicec:\r  command: \"ImageViewOn\"\r  initiator: \"DVD Player\"\r  destination: \"TV\"</pre> Switches the TV to the initiator's input Using a DVD player remote control to turn on the TV <code>TextViewOn</code> <pre>---\rhdmicec:\r  command: \"TextViewOn\"\r  initiator: \"DVD Player\"\r  destination: \"TV\"</pre> Switches the TV to the initiator's input with text display Using a DVD player remote control to turn on the TV"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads","title":"Example YAML Payloads","text":"<p>Active Source:</p> <pre>\n---\nhdmicec:\n  command: \"ActiveSource\"\n  initiator: \"IPSTB\"\n  destination: \"Broadcast\"\n  parameters:\n    device_name: \"TV\"\n</pre> <p>Image View On:</p> <pre>\n---\nhdmicec:\n  command: \"ImageViewOn\"\n  initiator: \"DVD Player\"\n  destination: \"TV\"\n</pre> <p>Text View On:</p> <pre>\n---\nhdmicec:\n  command: \"TextViewOn\"\n  initiator: \"DVD Player\"\n  destination: \"TV\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#2-one-touch-record","title":"2. One Touch Record","text":"<p>Allows whatever is shown on the TV screen to be recorded on a selected Recording Device.</p> Command YAML Payload Action How to Trigger in Real Setup <code>RecordOn</code> <pre>---\rhdmicec:\r  command: RecordOn\r  initiator: TV\r  destination: RecordingDevice\r  parameters:\r    source: Tuner</pre> Starts recording on the specified recording device Using a TV remote control to start recording on a DVR <code>RecordOff</code> <pre>---\rhdmicec:\r  command: RecordOff\r  initiator: TV\r  destination: RecordingDevice</pre> Stops recording on the specified recording device Using a TV remote control to stop recording on a DVR <code>RecordStatus</code> <pre>---\rhdmicec:\r  command: RecordStatus\r  initiator: RecordingDevice\r  destination: TV\r  parameters:\r    status: Recording</pre> Reports the current recording status of the device Automatically triggered by the recording device to inform status"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters-for-recordon","title":"Parameters for <code>RecordOn</code>","text":"Parameter Description Values <code>source</code> Source of the recording <code>Tuner</code>, <code>ExternalInput</code>, <code>Auxiliary</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters-for-recordstatus","title":"Parameters for <code>RecordStatus</code>","text":"Parameter Description Values <code>status</code> Indicates the current recording status <code>Recording</code>, <code>NoRecording</code>, <code>InsufficientSpace</code>, <code>AlreadyRecording</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_1","title":"Example YAML Payloads","text":"<p>Record On - Tuner Source:</p> <pre>\n---\nhdmicec:\n  command: RecordOn\n  initiator: TV\n  destination: RecordingDevice\n  parameters:\n    source: Tuner\n</pre> <p>Record Off:</p> <pre>\n---\nhdmicec:\n  command: RecordOff\n  initiator: TV\n  destination: RecordingDevice\n</pre> <p>Record Status - Recording:</p> <pre>\n---\nhdmicec:\n  command: RecordStatus\n  initiator: RecordingDevice\n  destination: TV\n  parameters:\n    status: Recording\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#3-routing-control","title":"3. Routing Control","text":"<p>These commands manage the routing of signals between devices, ensuring the correct source is displayed on the TV.</p> Command YAML Payload Action How to Trigger in Real Setup <code>RoutingChange</code> <pre>---\rhdmicec:\r  command: \"RoutingChange\"\r  initiator: \"AV Receiver\"\r  destination: \"Broadcast\"\r  parameters:\r    from_device: \"DVD Player\"\r    to_device: \"TV\"</pre> Notifies that the source device has changed from one to another Automatically triggered when the AV Receiver changes the input source <code>RoutingInformation</code> <pre>---\rhdmicec:\r  command: \"RoutingInformation\"\r  initiator: \"AV Receiver\"\r  destination: \"Broadcast\"\r  parameters:\r    device_name: \"TV\"</pre> Provides information about the current routing path Automatically triggered to inform the routing path change <code>RequestActiveSource</code> <pre>---\rhdmicec:\r  command: \"RequestActiveSource\"\r  initiator: \"TV\"\r  destination: \"Broadcast\"</pre> Requests the active source device to identify itself Using a TV remote control to switch inputs <code>SetStreamPath</code> <pre>---\rhdmicec:\r  command: \"SetStreamPath\"\r  initiator: \"TV\"\r  destination: \"Broadcast\"\r  parameters:\r    device_name: \"AV Receiver\"</pre> Sets the stream path to the specified device Using a TV remote control to select the AV Receiver <code>InactiveSource</code> <pre>---\rhdmicec:\r  command: \"InactiveSource\"\r  initiator: \"DVD Player\"\r  destination: \"TV\"</pre> Notifies that the initiator device is no longer the active source Automatically triggered when the DVD Player is turned off <code>ReportPhysicalAddress</code> <pre>---\rhdmicec:\r  command: \"ReportPhysicalAddress\"\r  initiator: \"AV Receiver\"\r  destination: \"Broadcast\"\r  parameters:\r    device_name: \"TV\"</pre> Provides the physical address of the device Automatically triggered when a device is connected <code>GivePhysicalAddress</code> <pre>---\rhdmicec:\r  command: \"GivePhysicalAddress\"\r  initiator: \"TV\"\r  destination: \"AV Receiver\"</pre> Requests the physical address of the destination device Using a TV remote control to identify the AV Receiver"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_2","title":"Example YAML Payloads","text":"<p>Routing Change:</p> <pre>\n---\nhdmicec:\n  command: \"RoutingChange\"\n  initiator: \"AV Receiver\"\n  destination: \"Broadcast\"\n  parameters:\n    from_device: \"DVD Player\"\n    to_device: \"TV\"\n</pre> <p>Routing Information:</p> <pre>\n---\nhdmicec:\n  command: \"RoutingInformation\"\n  initiator: \"AV Receiver\"\n  destination: \"Broadcast\"\n  parameters:\n    device_name: \"TV\"\n</pre> <p>Request Active Source:</p> <pre>\n---\nhdmicec:\n  command: \"RequestActiveSource\"\n  initiator: \"TV\"\n  destination: \"Broadcast\"\n</pre> <p>Set Stream Path:</p> <pre>\n---\nhdmicec:\n  command: \"SetStreamPath\"\n  initiator: \"TV\"\n  destination: \"Broadcast\"\n  parameters:\n    device_name: \"AV Receiver\"\n</pre> <p>Inactive Source:</p> <pre>\n---\nhdmicec:\n  command: \"InactiveSource\"\n  initiator: \"DVD Player\"\n  destination: \"TV\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#4-deck-control","title":"4. Deck Control","text":"<p>These commands control the playback devices, such as recorders and players.</p> Command YAML Payload Action How to Trigger in Real Setup <code>DeckControl</code> <pre>---\rhdmicec:\r  command: DeckControl\r  initiator: TV\r  destination: PlaybackDevice1\r  parameters:\r    deck_info: Play</pre> Controls deck functions such as play, pause, etc. Using a TV remote control to control playback functions <code>GiveDeckStatus</code> <pre>---\rhdmicec:\r  command: GiveDeckStatus\r  initiator: TV\r  destination: PlaybackDevice1\r  parameters:\r    status_request: On</pre> Requests the current status of the playback device Automatically triggered by TV to get the status of the playback device <code>Play</code> <pre>---\rhdmicec:\r  command: Play\r  initiator: TV\r  destination: PlaybackDevice1\r  parameters:\r    play_mode: PlayForward</pre> Starts playback on the specified playback device Using a TV remote control to play content <code>DeckStatus</code> <pre>---\rhdmicec:\r  command: DeckStatus\r  initiator: PlaybackDevice1\r  destination: TV\r  parameters:\r    deck_info: Play</pre> Reports the current status of the playback device Automatically triggered by the playback device to inform its status"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters-for-deckcontrol","title":"Parameters for <code>DeckControl</code>","text":"Parameter Description Values <code>deck_info</code> Indicates the deck control mode <code>Play</code>, <code>Pause</code>, <code>Stop</code>, <code>Rewind</code>, <code>FastForward</code>, <code>Eject</code>, <code>Seek</code> <code>seek_time</code> Time to seek to in milliseconds <code>0</code> to <code>n</code> (where <code>n</code> is the duration of the content in ms)"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#possible-values-for-status_request","title":"Possible Values for <code>status_request</code>","text":"Prameter Possible Values Description <code>status_request</code> <code>\"On\"</code>, <code>\"Off\"</code>, <code>\"Once\"</code> Requests status information from the device. \"On\" requests continuous updates, \"Off\" stops updates, \"Once\" requests a single update."},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters-for-play","title":"Parameters for <code>Play</code>","text":"Parameter Description Values <code>play_mode</code> Indicates the play mode <code>PlayForward</code>, <code>PlayReverse</code>, <code>Still</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#parameters-for-deckstatus","title":"Parameters for <code>DeckStatus</code>","text":"Parameter Description Values <code>deck_info</code> Indicates the current status of the deck <code>Play</code>, <code>Pause</code>, <code>Stop</code>, <code>Rewind</code>, <code>FastForward</code>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_3","title":"Example YAML Payloads","text":"<p>Deck Control - Play Command:</p> <pre>\n---\nhdmicec:\n  command: DeckControl\n  initiator: TV\n  destination: PlaybackDevice1\n  parameters:\n    deck_info: Play\n</pre> <p>Give Deck Status Command:</p> <pre>\n---\nhdmicec:\n  command: GiveDeckStatus\n  initiator: TV\n  destination: PlaybackDevice1\n  parameters:\n    status_request: 1\n</pre> <p>Play Command:</p> <pre>\n---\nhdmicec:\n  command: Play\n  initiator: TV\n  destination: PlaybackDevice1\n  parameters:\n    play_mode: PlayForward\n</pre> <p>Deck Status - Playing:</p> <pre>\n---\nhdmicec:\n  command: DeckStatus\n  initiator: PlaybackDevice1\n  destination: TV\n  parameters:\n    deck_info: Play\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#5-osd-display","title":"5. OSD Display","text":"<p>These commands manage the On-Screen Display settings and information.</p> Command YAML Payload Action How to Trigger in Real Setup <code>SetOsdString</code> <pre>---\rhdmicec:\r  command: \"SetOsdString\"\r  initiator: \"PlaybackDevice1\"\r  destination: \"TV\"\r  parameters:\r    osd_string: \"IPSTB\"</pre> Sets the OSD (On-Screen Display) string on the TV Automatically triggered when the playback device sets the OSD string <code>SetOsdName</code> <pre>---\rhdmicec:\r  command: \"SetOsdName\"\r  initiator: \"TV\"\r  destination: \"Broadcast\"\r  parameters:\r    osd_name: \"IPSTB\"</pre> Sets the OSD (On-Screen Display) name on all devices Automatically triggered when the TV sets the OSD name <code>GiveOSDName</code> <pre>---\rhdmicec:\r  command: \"GiveOSDName\"\r  initiator: \"TV\"\r  destination: \"Broadcast\"</pre> Requests the OSD (On-Screen Display) name from all devices Using a TV remote control to request OSD name from all devices"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_4","title":"Example YAML Payloads","text":"<p>Set OSD String (\"IPSTB\") on TV:</p> <pre>\n---\nhdmicec:\n  command: \"SetOsdString\"\n  initiator: \"PlaybackDevice1\"\n  destination: \"TV\"\n  parameters:\n    osd_string: \"IPSTB\"\n</pre> <p>Set OSD Name (\"IPSTB\") on all devices:</p> <pre>\n---\nhdmicec:\n  command: \"SetOsdName\"\n  initiator: \"TV\"\n  destination: \"Broadcast\"\n  parameters:\n    osd_name: \"IPSTB\"\n</pre> <p>Give OSD Name (Request from TV):</p> <pre>\n---\nhdmicec:\n  command: \"GiveOSDName\"\n  initiator: \"TV\"\n  destination: \"Broadcast\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#6-device-menu-control","title":"6. Device Menu Control","text":"<p>Commands to control the device's menu interface, enabling navigation and selection of menu items.</p> Command YAML Payload Action How to Trigger in Real Setup <code>MenuRequest</code> <pre>---\rhdmicec:\r  command: \"MenuRequest\"\r  initiator: \"TV\"\r  destination: \"PlaybackDevice1\"</pre> Requests the menu from the playback device Using a TV remote control to request the menu from the device <code>MenuStatus</code> <pre>---\rhdmicec:\r  command: \"MenuStatus\"\r  initiator: \"PlaybackDevice1\"\r  destination: \"TV\"\r  parameters:\r    status: \"activated\"</pre> Provides the status of the menu Automatically triggered to inform the TV of the menu status <code>UserControlPressed</code> <pre>---\rhdmicec:\r  command: \"UserControlPressed\"\r  initiator: \"TV\"\r  destination: \"PlaybackDevice1\"\r  parameters:\r    ui_command: \"Select\"</pre> Sends a user control command (Select) to the playback device Using a TV remote control to send a select command to the device"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_5","title":"Example YAML Payloads","text":"<p>Menu Request:</p> <pre>\n---\nhdmicec:\n  command: \"MenuRequest\"\n  initiator: \"TV\"\n  destination: \"PlaybackDevice1\"\n</pre> <p>Menu Status:</p> <pre>\n---\nhdmicec:\n  command: \"MenuStatus\"\n  initiator: \"PlaybackDevice1\"\n  destination: \"TV\"\n  parameters:\n    status: \"activated\"\n</pre> <p>User Control Pressed (Select):</p> <pre>\n---\nhdmicec:\n  command: \"UserControlPressed\"\n  initiator: \"TV\"\n  destination: \"PlaybackDevice1\"\n  parameters:\n    ui_command: \"Select\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#7-remote-control-passthrough","title":"7. Remote Control Passthrough","text":"<p>Allows remote control commands to be sent directly to devices.</p> Command YAML Payload Action How to Trigger in Real Setup <code>UserControlPressed</code> <pre>---\rhdmicec:\r  command: \"UserControlPressed\"\r  initiator: \"TV\"\r  destination: \"PlaybackDevice1\"\r  parameters:\r    ui_command: \"Play\"</pre> Sends a user control command (Play) to the playback device Using a TV remote control to send a play command to the device <code>UserControlReleased</code> <pre>---\rhdmicec:\r  command: \"UserControlReleased\"\r  initiator: \"TV\"\r  destination: \"PlaybackDevice1\"\r  parameters:\r    ui_command: \"Play\"</pre> Sends a user control command (Play release) to the playback device Using a TV remote control to release the play command on the device"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_6","title":"Example YAML Payloads","text":"<p>User Control Pressed (Play):</p> <pre>\n---\nhdmicec:\n  command: \"UserControlPressed\"\n  initiator: \"TV\"\n  destination: \"PlaybackDevice1\"\n  parameters:\n    ui_command: \"Play\"\n</pre> <p>User Control Released (Play):</p> <pre>\n---\nhdmicec:\n  command: \"UserControlReleased\"\n  initiator: \"TV\"\n  destination: \"PlaybackDevice1\"\n  parameters:\n    ui_command: \"Play\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#8-power-status","title":"8. Power Status","text":"<p>These commands manage the power state of devices, such as putting them into standby mode.</p> Command YAML Payload Action How to Trigger in Real Setup <code>GiveDevicePowerStatus</code> <pre>---\rhdmicec:\r  command: \"GiveDevicePowerStatus\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"</pre> Requests the power status of the audio system Using a TV remote control to request power status from the audio system <code>ReportPowerStatus</code> <pre>---\rhdmicec:\r  command: \"ReportPowerStatus\"\r  initiator: \"AudioSystem\"\r  destination: \"TV\"\r  parameters:\r    power_status: \"on\"</pre> Provides the power status of the audio system Automatically triggered to inform the TV of the audio system power status <code>Standby</code> <pre>---\rhdmicec:\r  command: \"Standby\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"</pre> Puts the audio system into standby mode Using a TV remote control to send a standby command to the audio system"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_7","title":"Example YAML Payloads","text":"<p>Give Device Power Status:</p> <pre>\n---\nhdmicec:\n  command: \"GiveDevicePowerStatus\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n</pre> <p>Report Power Status (On):</p> <pre>\n---\nhdmicec:\n  command: \"ReportPowerStatus\"\n  initiator: \"AudioSystem\"\n  destination: \"TV\"\n  parameters:\n    power_status: \"on\"\n</pre> <p>Standby:</p> <pre>\n---\nhdmicec:\n  command: \"Standby\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#9-system-audio-control","title":"9. System Audio Control","text":"<p>When an Audio Amplifier / Receiver is connected with the TV, functionality like volume can be controlled using any of the remote controls of any cec enabled devices in the system.</p> Command YAML Payload Action How to Trigger in Real Setup <code>GiveAudioStatus</code> <pre>---\rhdmicec:\r  command: \"GiveAudioStatus\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"</pre> Requests the audio system status Using a TV remote control to get the status of the audio system <code>GiveSystemAudioModeStatus</code> <pre>---\rhdmicec:\r  command: \"GiveSystemAudioModeStatus\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"</pre> Requests the audio system mode status Using a TV remote control to get the current audio system mode <code>ReportAudioStatus</code> <pre>---\rhdmicec:\r  command: \"ReportAudioStatus\"\r  initiator: \"AudioSystem\"\r  destination: \"TV\"</pre> Provides the audio system status Automatically triggered to inform the TV of the audio system status <code>ReportShortAudioDescriptor</code> <pre>---\rhdmicec:\r  command: \"ReportShortAudioDescriptor\"\r  initiator: \"AudioSystem\"\r  destination: \"TV\"</pre> Provides the audio capabilities of the audio system Automatically triggered to inform the TV of the audio capabilities <code>RequestAudioDescriptor</code> <pre>---\rhdmicec:\r  command: \"RequestAudioDescriptor\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"</pre> Requests the audio capabilities from the audio system Using a TV remote control to request audio capabilities from the audio system"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_8","title":"Example YAML Payloads","text":"<p>Give Audio Status:</p> <pre>\n---\nhdmicec:\n  command: \"GiveAudioStatus\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n</pre> <p>Give System Audio Mode Status:</p> <pre>\n---\nhdmicec:\n  command: \"GiveSystemAudioModeStatus\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n</pre> <p>Report Audio Status:</p> <pre>\n---\nhdmicec:\n  command: \"ReportAudioStatus\"\n  initiator: \"AudioSystem\"\n  destination: \"TV\"\n</pre> <p>Report Short Audio Descriptor:</p> <pre>\n---\nhdmicec:\n  command: \"ReportShortAudioDescriptor\"\n  initiator: \"AudioSystem\"\n  destination: \"TV\"\n</pre> <p>Request Audio Descriptor:</p> <pre>\n---\nhdmicec:\n  command: \"RequestAudioDescriptor\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#10-system-information","title":"10. System Information","text":"Command YAML Payload Action How to Trigger in Real Setup <code>GetCECVersion</code> <pre>---\rhdmicec:\r  command: \"GetCECVersion\"\r  initiator: \"TV\"\r  destination: \"Broadcast\"</pre> Requests the CEC version from all devices Automatically triggered to get the CEC version <code>GetMenuLanguage</code> <pre>---\rhdmicec:\r  command: \"GetMenuLanguage\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"</pre> Requests the menu language from the audio system Using TV remote control to request menu language from audio system <code>SetMenuLanguage</code> <pre>---\rhdmicec:\r  command: \"SetMenuLanguage\"\r  initiator: \"TV\"\r  destination: \"AudioSystem\"\r  parameters:\r    menu_language: \"ENG\"</pre> Sets the menu language on the audio system Automatically triggered to set the menu language on the audio system <code>ReportPhysicalAddress</code> <pre>---\rhdmicec:\r  command: \"ReportPhysicalAddress\"\r  initiator: \"AudioSystem\"\r  destination: \"TV\"\r  parameters:\r    physical_address: [16, 0]</pre> Reports the physical address of the audio system to the TV Automatically triggered to report physical address to the TV"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_VirtualComponent_ControlPlaneCommands/#example-yaml-payloads_9","title":"Example YAML Payloads","text":"<p>Get CEC Version (Request from TV):</p> <pre>\n---\nhdmicec:\n  command: \"GetCECVersion\"\n  initiator: \"TV\"\n  destination: \"Broadcast\"\n</pre> <p>Get Menu Language (Request from TV):</p> <pre>\n---\nhdmicec:\n  command: \"GetMenuLanguage\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n</pre> <p>Set Menu Language (\"ENG\") on AudioSystem:</p> <pre>\n---\nhdmicec:\n  command: \"SetMenuLanguage\"\n  initiator: \"TV\"\n  destination: \"AudioSystem\"\n  parameters:\n    menu_language: \"ENG\"\n</pre> <p>Report Physical Address (AudioSystem to TV):</p> <pre>\n---\nhdmicec:\n  command: \"ReportPhysicalAddress\"\n  initiator: \"AudioSystem\"\n  destination: \"TV\"\n  parameters:\n    physical_address: [16, 0]\n</pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/","title":"Virtual Component for HDMI CEC HAL","text":"<ul> <li>The HDMI CEC HAL interface test shall be enhanced to support a virtual component that can be used inside a Virtual device to emulate a real device that supports HDMI CEC.</li> <li>Currently, rdk-halif-test-hdmi_cec supports a skeleton (stubbed out) implementation of the interface defined in rdk-halif-hdmi_cec. This shall be enhanced to support a virtual component that mimics operations of a real device.</li> <li>The Virtual Component (vComponent) implementation shall replace the Skeleton implementation as the default.</li> <li>A Common Virtual Component interface with Intitialize and Deinitialize methods shall be defined.</li> <li>Virtual Component shall be built as a separate binary (shared lib).</li> <li>A Virtual device (vDevice) shall include one or more vComponents to cater a test setup.</li> </ul> <p>When the vComponent process is started, vComponent_HdmiCec_Initialize shall be called with YAML configuration file passed into it using the '-p' parameter.</p> <pre><code>`./run -p tv_panel_5_devices.yaml`\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#yaml-template-for-profile","title":"YAML Template for Profile","text":"<p>Below is the YAML template for the vComponent profile defintion. This YAML template intends to provide a blueprint of a profile config through anchor references. An actual profile would be a derivation of this template. The profile config provides a way to represent a CEC bus with a number of devices connected in a parent/children hierarchy starting from the root device. The <code>emulated_device</code> attribute defines the friendly name of the emulated vDevice. An emulated devcie can either be a Sink Device (TV) like or a Source Device like Settop boxes. The <code>device_map</code> list is a representation of the CEC bus and its networked devices. Each device can have a number of children and the <code>children</code> array lists the devices.</p> <pre><code>---\nhdmicec:\n  #Device logical types - Hints for emulator to auto allocate logical address\n  device_type: &amp;device_type \n    - TV\n    - PlaybackDevice\n    - AudioSystem\n    - RecordingDevice\n    - Tuner\n    - Reserved\n    - Unregistered\n\n  #Port ID - Integer [1 to 15]\n  port_id: &amp;port_id \n    !!int\n\n  #Enum specifying port type\n  #All references shown in the configuration templates are intended to provide possible values for the given type.\n  #In practice, the below field would be defined as,\n  # port_type: in\n  port_type: &amp;port_type\n    - in\n    - out\n\n  #Vendor Info - Name and IEEE RAC vendor code\n  vendor: &amp;vendor\n    - TOSHIBA\n    - SAMSUNG\n    - DENON\n    - MARANTZ\n    - LOEWE\n    - ONKYO\n    - MEDION\n    - TOSHIBA2\n    - APPLE\n    - HARMAN_KARDON2\n    - GOOGLE\n    - AKAI\n    - AOC\n    - PANASONIC\n    - PHILIPS\n    - DAEWOO\n    - YAMAHA\n    - GRUNDIG\n    - PIONEER\n    - LG\n    - SHARP\n    - SONY\n    - BROADCOM\n    - SHARP2\n    - VIZIO\n    - BENQ\n    - HARMAN_KARDON\n    - TEST_VENDOR\n    - UNKNOWN\n\n  #HDMI CEC Version supported by device\n  cec_version: &amp;cec_version \n    - 0  #Unknown\n    - 1  #1.2\n    - 2  #1.2A\n    - 3  #1.3\n    - 4  #1.3A\n    - 5  #1.4\n    - 6  #2.0\n\n  #Power Status of the device\n  power_status: &amp;power_status \n    - on\n    - off\n    - standby\n\n  # Emulated Device's Information\n  emulated_device: !!str # e.g, TVPanel \n  number_ports: !!int\n  ports: #Variable sized array of Ports belonging to Emulated device\n    - id: *port_id\n  #All references shown in the configuration templates are intended to provide possible values for the given type.\n  #In practice, the below field would be defined as,\n  # port_type: in\n      type: *port_type  # Type of Port from &amp;port_type\n      cec_supported: !!bool\n      arc_supported: !!bool\n    - id: *port_id\n      type: *port_type\n      cec_supported: !!bool\n      arc_supported: !!bool\n\n  number_devices: !!int # Total number of devices in the network\n  device_map: # Map of devices starting from the Root Device (A TV) and multiple levels of children\n    - name: !!str  #Unique name identifying the device.\n      type: *device_type  #Type of device from device_type list. The top parent must be a root device (TV)\n      version: *cec_version\n      active_source: !!bool\n      vendor_info: *vendor\n      pwr_status: *power_status\n      port_id: !!int  #Port id of the parent to which this device is connected. For root device, this will be 0.\n      number_children: !!int  #Number of children connected to this device\n      children:   #Array of devices that are connected to this parent\n      - name: !!str\n        type: *device_type\n        version: *cec_version\n        active_source: !!bool\n        vendor_info: *vendor\n        pwr_status: *power_status\n        port_id: !!int  #Port id of the parent to which this device is connected\n        number_children: !!int # 0, If no devices are connected. This parameter must be present for all devices\n\n      - name: !!str\n        type: *device_type\n        version: *cec_version\n        active_source: !!bool\n        vendor_info: *vendor\n        pwr_status: *power_status\n        port_id: !!int  #Port id of the parent to which this device is connected\n        number_children: !!int # 0, If no devices are connected.\n        children:\n          - name: !!str\n            type: *device_type\n            version: *cec_version\n            active_source: !!bool\n            vendor_info: *vendor\n            pwr_status: *power_status\n            port_id: !!int  #Port id of the parent to which this device is connected\n            number_children: !!int # 0, If no devices are connected.\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#an-example-sink-profile","title":"An example Sink profile","text":"<p>Below is an example profile for a virtual TV Device emulating a TV Panel with a few devices connected to it on the CEC bus. A Sample profile config in YAML with a network of devices representing a TV as the root device (Sink), connected with an Audio System connected on the HDMI port 1 and a Sony PS3 connected on its HDMI port 2. The Audio system has a IPSTB box connected on its HDMI port 2 and a chromecast connected on its port 1.</p> <pre><code>---\nhdmicec:\n    emulated_device: TVPanel\n    number_ports: 3\n    ports:\n      - id: 1\n        type: in\n        cec_supported: true\n        arc_supported: true\n      - id: 2\n        type: in\n        cec_supported: true\n        arc_supported: true\n      - id: 3\n        type: in\n        cec_supported: true\n        arc_supported: false\n\n    number_devices: 5\n    device_map:\n      - name: TVPanel\n        type: TV\n        version: 4\n        active_source: false\n        vendor: TEST_VENDOR\n        pwr_status: on\n        port_id: 0\n        number_children: 2\n        children:\n        - name: Sony HomeTheatre\n          type: AudioSystem\n          version: 4\n          active_source: false\n          vendor: SONY\n          pwr_status: on\n          port_id: 1\n          number_children: 2\n          children: \n            - name: Chromecast\n              type: PlaybackDevice\n              version: 4\n              active_source: false\n              vendor: GOOGLE\n              pwr_status: on\n              port_id: 1\n              number_children: 0\n            - name: IPSTB\n              type: PlaybackDevice\n              version: 4\n              active_source: false\n              vendor: TEST_VENDOR\n              pwr_status: on\n              port_id: 2\n              number_children: 0\n        - name: SONY PS3\n          type: PlaybackDevice\n          version: 4\n          active_source: false\n          vendor: SONY\n          pwr_status: on\n          port_id: 2\n          number_children: 0\n</code></pre> <p>The vComponent on loading the profile, creates an internal map for the device network and auto allocate HDMI CEC physical and logical addresses. This makes it easier to manage user triggers using the Friendly Name of the device.</p> <p>For the above example sink profile, the expected physical and logical address allocation would be as below.</p> Device Type Physical Address Logical Address TVPanel TV 0.0.0.0 0 SONY HomeTheatre AudioSystem 1.0.0.0 5 SONY PS3 PlaybackDevice 2.0.0.0 4 IPSTB PlaybackDevice 1.2.0.0 8 Chromecast PlaybackDevice 1.1.0.0 11"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#vcomponent-interface","title":"vComponent Interface","text":"<p>The vComponent will have a common interface that needs to be implemented along with the HAL driver interface functions in hdmi_cec_driver.h.</p> <p><code>vcHdmiCec.h</code></p> <pre><code>vcHdmiCec_t* vcHdmiCec_Initialize( void );\n\nvcHdmiCec_Status_t vcHdmiCec_Open( vcHdmiCec_t* pVCHdmiCec, char* pProfilePath, bool enableCPMsgs );\n\nvcHdmiCec_Status_t vcHdmiCec_Close( vcHdmiCec_t* pVCHdmiCec );\n\nvcHdmiCec_Status_t vcHdmiCec_Deinitialize( vcHdmiCec_t *pvComponent );\n</code></pre> <p>vcHdmiCec_Open will use the YAML decoding functionality via the Key-Value Pair (KVP) module available currently as part of the ut_core to read the profile parameters and create the initial state machine with number of HDMI Ports and the network of devices attached on the CEC bus. In addition, vComponent will also intialise the control plane with the websocket port.</p> <p>The control plane inititialise function may look like this. This will setup the websocket server.</p> <pre><code>ut_controlPlane_instance_t instance = UT_ControlPlane_Init(port);\n</code></pre> <p>The vComponent will also register with the control plane to receive callbacks when there is a command trigger from the Test user. These are YAML messages over Websocket. The register mechanism shall look like below,</p> <pre><code>UT_ControlPlane_RegisterCallbackOnMessage(instance, \"hdmicec.command\", &amp;myCallback);\n</code></pre> <p>The state machine of the Hdmi CEC hal is setup by populating its data structures by retreiving from the profile config. Below is an example of information about HDMI ports populated. The info on devices connected to the CEC bus is populated in a similar way to set up the initial state machine.</p> <pre><code>#define MAX_OSD_NAME_LENGTH 16\n\ntypedef enum {\n    INPUT,\n    OUTPUT\n} port_type_t;\n\ntyedef enum {\n  ON,\n  STANDBY,\n  OFF\n}power_status_t;\n\ntypedef struct port_info {\n  uint8_t id;\n  uint16_t physical_address;\n  port_type_t type;\n  bool cec_supported;\n  bool arc_supported;\n} port_info_t;\n\ntypedef struct device {\n   uint32_t version;\n   uint16_t physical_address;\n   uint8_t logical_address;\n   bool active_source;\n   uint32_t vendor_id;\n   power_status_t power_status;\n   char osd_name[MAX_OSD_NAME_LENGTH];\n}\n\n\n\n---\nut_kvp_instance_t kvp_instance = ut_kvp_createInstance();\nut_kvp_status_t status = ut_kvp_read(&amp;kvp_instance, profile);\nuint32_t num_ports = ut_kvp_getUInt32Field(&amp;kvp_instance, \"hdmicec.num_ports\");\n\nport_info_t *ports = (port_info_t*)malloc(size(port_info_t) * num_ports);\n\nchar prefix_name[] = \"hdmicec.ports.\";\nfor(int i = 0; i &lt; ports; i++)\n{\n.......\n}\n---\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#control-plane-message-flow","title":"Control Plane Message flow","text":"<p>The emulator also sets up the data structures to manage HdmiCec Tx and Rx callbacks when the respective interface function is called. This includes the threading mechanisms required to trigger callbacks to caller of HdmiCec driver. Below diagram depicts a typical call sequence with emulator handling commands from Test user and triggering HdmiCec Rx callback.</p> <pre><code>sequenceDiagram\n    vcomponent_main-&gt;&gt;+vcomponent_lib: vComponent_HdmiCec_Initialize(profile)\n    vcomponent_lib-&gt;&gt;+control_plane: UT_ControlPlane_Init(port)\n    control_plane--&gt;&gt;-vcomponent_lib: return\n    vcomponent_lib--&gt;&gt;-vcomponent_main: return\n    Note over control_plane: Setup Websocket server\n    vcomponent_lib-&gt;&gt;+control_plane: UT_ControlPlane_RegisterCallbackOnMessage\n    control_plane--&gt;&gt;-vcomponent_lib: return\n    Note over vcomponent_lib: Get KVP parameters, Setup device network\n    hal_user-&gt;&gt;+vcomponent_lib: HdmiCecOpen\n    vcomponent_lib--&gt;&gt;-hal_user: return\n    hal_user-&gt;&gt;+vcomponent_lib: HdmiCecSetRxCallback\n    vcomponent_lib--&gt;&gt;-hal_user: return\n    hal_user-&gt;&gt;+vcomponent_lib: HdmiCecGetLogicalAddress\n    vcomponent_lib--&gt;&gt;-hal_user: return\n    hal_user-&gt;+vcomponent_lib: HdmiCecGetPhysicalAddress\n    vcomponent_lib--&gt;&gt;-hal_user: return\n    hal_user-&gt;&gt;+vcomponent_lib: HdmiCeTx\n    vcomponent_lib--&gt;&gt;-hal_user: return\n      Note over Test User: hdmicec: &lt;br&gt; command: hotplug &lt;br&gt; port:1 &lt;br&gt; connected: true\n    Test User-&gt;&gt;control_plane: YAML Message with Command\n    control_plane-&gt;&gt;+vcomponent_lib: Command Callback\n    vcomponent_lib-&gt;&gt;+hal_user: HdmiCecRxCallback triggered\n      hal_user--&gt;-vcomponent_lib: return\n      vcomponent_lib--&gt;-control_plane: return\n\n</code></pre> <p>Some sample commands from control plane</p> <p>Command to trigger a hotplug event from device connected in Port 2:</p> <pre><code>hdmicec:\n    command: hotplug\n    port: 2\n    connected: false\n</code></pre> <p>User presses power on button in PS3 to come out of standby and makes the PS3 the active source. Command to make virtual component, a TV, to switch to Power on:</p> <pre><code>---\nhdmicec:\n    command: ImageViewOn\n    initiator: SONY PS3\n    destination: TVPanel\n</code></pre> <p>The above command should trigger 2 call backs from the emulator to hal user. The emulator should be able to translate the commands received from test user into CEC message payload and trigger the call back.</p> <p>With the above setup, user trigger messages shall be as in the table below.</p> User Trigger Yaml Message RX Callback Data Action ImageViewOn <pre>---  \rhdmicec:  \r  command: ImageViewOn  \r  initiator: SONY PS3  \r  destination: TVPanel</pre> 40:04 TV Powers On and enters display state SetOSDName <pre>---  \rhdmicec:  \r  command: SetOSDName  \r  initiator: IPSTB  \r  destination: TVPanel \r  osd_name: osd_name: IPSTB</pre> 80:04:49:50:53:54:42 TV Powers On and enters display state ActiveSource <pre>---  \rhdmicec:  \r  command: ActiveSource  \r  initiator: IPSTB  \r  destination: TVPanel</pre> 80:47:12:00 Switches to relevant HDMI port Standby <pre>---  \rhdmicec:  \r  command: Standby  \r  initiator: TVPanel  \r  destination: Broadcast</pre> 0F:36 Broadcasts all devices to go to standby Hotplug <pre>---  \rhdmicec:  \r  command: hotplug  \r  port: 1  \r  connected: false</pre> None Reset logical address and change power state Give Physical address <pre>---  \rhdmicec:  \r  command: GivePhysicalAddress  \r  initiator: Sony HomeTheatre  \r  destination: IPSTB</pre> 54:83 HdmiCecTx should be triggered with ReportPhysicalAddress"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#one-touch-play-feature","title":"One Touch Play Feature","text":"<p>The One touch play feature allows a source device to become the active source with a single button press. Typically, in a real home setup, when the user presses play on a playback device that is connected to the TV, CEC messages are sent to the TV and the CEC bus to inform that the playback device has started streaming content. The TV on receiving the ImageViewOn message, will come out of the standby if needed and enters the display state. Subsequently, the playback device also broadcasts an ActiveSource message which allows the TV to switch to the relevant HDMI port that the playback device is connected on. The below sequence diagram shows how this senario can be emulated using the control plane to trigger the CEC messages. Here the Test user sends the YAML messages over websocket or http to the control plane.</p> <pre><code>sequenceDiagram\nNote over Test User: hdmicec: &lt;br&gt; command: ImageViewOn &lt;br&gt; initiator: SONY PS3 &lt;br&gt; destination: TVPanel\nTest User-&gt;&gt;+control_plane: command\ncontrol_plane-&gt;&gt;+vcomponent_lib: command callback\nvcomponent_lib-&gt;&gt;+hal_user: HdmiCecRxCallback (IMAGE_VIEW_ON msg)\nhal_user--&gt;&gt;-vcomponent_lib: return\nNote over Test User: hdmicec: &lt;br&gt; command: ActiveSource &lt;br&gt; initiator: SONY PS3 &lt;br&gt; destination: Broadcast\nTest User-&gt;&gt;+control_plane: command\ncontrol_plane-&gt;&gt;+vcomponent_lib: command callback\nvcomponent_lib-&gt;&gt;+hal_user: HdmiCecRxCallback (ACTIVE_SOURCE msg)\nhal_user--&gt;&gt;-vcomponent_lib: return\n\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#standby-feature","title":"Standby Feature","text":"<p>Command to trigger a Broadcast message from Playback Device 1 to put all devices to standby (toggle)</p> <pre><code>---\nhdmicec:\n    command: Standby\n    initiator: IPSTB\n    destination: Broadcast\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#device-menu-control","title":"Device Menu Control","text":"<p>Command to trigger a Device Menu Control command from Playback Device 2 to mute.</p> <pre><code>---\nhdmicec:\n    command: UserControl\n    initiator: SONY PS3\n    destination: TVPanel\n    ui_command: Mute\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#validating-l3-tests-using-validation-profile","title":"Validating L3 Tests using validation profile","text":"<p>Level 3 tests validate end-to-end functionality for a specific feature. In case of HDMI CEC L3 tests, when user triggers a command message the test can vaildate the callback data that is received through the HdmiCec Receive callback. For this, the validation profile and the actual profile shall be linked in a way they can be used to validate a particular test. For e.g, when the user triggers ActiveSource command through control plane, the yaml payload consists of Device Names as the primary handles, but the Receive callbacks that are generated as response for the commands contain raw cec data buffer that follow the HDMI CEC Specifications. This means, the L3 test will only have logical and physical addresses. The validation profile yaml can contain specific payload information to calidate against for a particualar test which corresponds to a selected main profile. In other words, tv_panel_5_devices.yaml profile will have a corresponding tv_panel_5_devices_vp.yaml.</p> <p>An example validation yaml for a particular profile.</p> <pre><code>---\nhdmicec:\n  ActiveSource:\n    input:\n      initiator: SONY PS3\n      destination: TVPanel\n    result:\n      initiator: 4\n      destination: 0\n      opcode: 0x82   # Opcode as defined in HDMI CEC Specification\n      parameters:\n        size: 2\n        data: [20, 0] # Physical address 2.0.0.0\n  SetOSDName:\n     input:\n      initiator: IPSTB\n      destination: TVPanel\n      osd_name: IPSTB\n     result:\n      initiator: 4\n      destination: 0\n      opcode: 0x49 # Opcode as defined in HDMI CEC Specification\n      parameters:\n        size:\n        data: [0x49,0x50,0x53,0x54,0x42] # \"IPSTB\" in hex ascii\n</code></pre>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#reconfiguring-the-vcomponent","title":"Reconfiguring the vComponent","text":"<p>Test user can also trigger a re-configuration of the initial profile with which the emulator state machine was set up, like the device type (Sink or Source) and the list of devices in the network etc.</p> <p>Command to trigger a re-configuration of the initial state. The following config represents that the emulated device is Playback Device 1 and is connected to a TV on its Port. The TV also has a Chromecast connected to it on port 2.</p> <pre><code>---\nhdmicec:\n  config:\n    emulated_device: IPSTB\n    number_ports: 1\n    ports:\n      - id: 1\n        type: out\n        cec_supported: true\n        arc_supported: false\n    number_devices: 3\n    device_map:\n      - name: Sony TV\n        type: TV\n        version: 4\n        active_source: false\n        vendor_info: SONY\n        pwr_status: on\n        number_chlidren: 2\n        children:\n         -  name: IPSTB\n            type: PlaybackDevice\n            version: 4 \n            active_source: true\n            vendor: TEST_VENDOR\n            pwr_status: on\n            port_id: 1\n            num_children: 0\n\n         -  name: Chromecast\n            type: PlaybackDevice\n            version: 4\n            active_source: false\n            vendor: GOOGLE\n            pwr_status: on\n            port_id: 1\n            num_children: 0\n</code></pre> <p>The above configuration yaml instructs the emulator about the following devices connected.</p> <pre><code>mindmap\n  root[Sony TV - 0.0.0.0]\n    id[IPSTB - 1.0.0.0]\n    id[Chromecast - 2.0.0.0]\n</code></pre> <p>This will trigger a complete reconfiguration of the emulator state machine by deleting and reconstructing its internal data base.</p>"},{"location":"external_content/hdmi_cec_test/docs/pages/hdmi_cec_virtual_component_design/#tasks-breakdown-for-mvp","title":"Tasks Breakdown for MVP","text":"<pre><code>mindmap\n  root((HDMI CEC Emulator))\n    Library\n      Init/Deinit\n      Load values from Profile config\n        KVP\n      Makery - Build/Install\n      ::icon(fa fa-wrench)\n      Setup State machine\n        Local data structures\n            Build device network topology\n        Threading for callbacks\n    Process\n      Main driver to start Emulator\n      Makery - Build/Install\n      ::icon(fa fa-wrench)\n      Sample Profile config YAMLs\n      Test Menus - Emulator init and basic CEC\n    User Triggers\n    ::icon(fa fa-user)\n      Initialize control plane with endpoint\n      id)User Commands(\n        Active Source Request\n        Add/Remove devices\n        Catalogue of Commands\n        Dynamic base config change\n</code></pre>"},{"location":"external_content/power_manager/","title":"Power Manager HAL Documentation","text":""},{"location":"external_content/power_manager/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Sequence Diagram</li> <li>State Diagram</li> </ul>"},{"location":"external_content/power_manager/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>:    Hardware Abstraction Layer</li> <li><code>CPE</code>:    Customer Premises Equipment</li> <li><code>CPU</code>:    Central Processing Unit</li> <li><code>IR</code>:     Infra-red</li> <li><code>HDMI</code>:   High-Definition Multimedia Interface</li> <li><code>A/V</code>:    Audio/Video</li> <li><code>HDD</code>:    Hard Drive Disk</li> </ul>"},{"location":"external_content/power_manager/#references","title":"References","text":""},{"location":"external_content/power_manager/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the module stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Power Manager HAL];\nx[Power Manager HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>This interface provides a set of <code>APIs</code> to facilitate communication through the <code>caller</code> and <code>HAL</code>.</p> <p>The Power manger <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set the power state, and query and set the wake up source.</p>"},{"location":"external_content/power_manager/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":""},{"location":"external_content/power_manager/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>PLAT_INIT()</code> before calling any other <code>API</code>.</p>"},{"location":"external_content/power_manager/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/power_manager/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/power_manager/#memory-model","title":"Memory Model","text":"<p>The <code>caller</code> is responsible to pass message buffer and free it for transmit request.</p>"},{"location":"external_content/power_manager/#power-management-requirements","title":"Power Management Requirements","text":"<p>The Power Manager <code>HAL</code> is involved to set the power management states ON, OFF, STANDBY, and LIGHT_SLEEP. </p>"},{"location":"external_content/power_manager/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface is not required to support asynchronous notification.</p>"},{"location":"external_content/power_manager/#blocking-calls","title":"Blocking calls","text":"<p>There are no blocking calls. Synchronous calls must complete within a reasonable time period. Any call that can fail due to the lack of response from the connected device must have a timeout period and the function must return the relevant error code.</p>"},{"location":"external_content/power_manager/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/power_manager/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/power_manager/#non-functional-requirements","title":"Non functional requirements","text":""},{"location":"external_content/power_manager/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/power_manager/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and CPU utilization.</p>"},{"location":"external_content/power_manager/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/power_manager/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/power_manager/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library and must be named as <code>libiarmmgrs-power-hal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/power_manager/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</p>"},{"location":"external_content/power_manager/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/power_manager/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/power_manager/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ul> <li> <p>Initialize the <code>HAL</code> using function: <code>PLAT_INIT()</code> before making any other <code>API</code> calls.  If <code>PLAT_INIT()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>Power status settings can be controlled using the functions <code>PLAT_API_SetPowerState()</code> and <code>PLAT_API_SetWakeupSrc()</code> and existing status can be queried using the functions <code>PLAT_API_GetPowerState()</code> and <code>PLAT_API_GetWakeupSrc()</code>.</p> </li> <li> <p>De-initialize the <code>HAL</code> using the function: <code>PLAT_TERM()</code>.</p> </li> </ul>"},{"location":"external_content/power_manager/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as Power Manager HAL\n    participant Device as HAL Device Control/Driver\n    Caller-&gt;&gt;HAL:PLAT_INIT()\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_SetPowerState()\n    Note over HAL: Sets the current power state.\n    HAL-&gt;&gt;Device:Setting power mode.\n    Device--&gt;&gt;HAL:Return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_GetPowerState()\n    Note over HAL: Gets the current power state.\n    HAL-&gt;&gt;Device:Getting current Power Mode\n    Device--&gt;&gt;HAL:Return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_SetWakeupSrc()\n    Note over HAL: Sets the wake-up source.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_GetWakeupSrc()\n    Note over HAL: Gets the current wake-up source.\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:PLAT_TERM()\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/power_manager/#state-diagram","title":"State Diagram","text":"<pre><code>flowchart TD\n    PO[Powered On]\n    POF[Powered Off]\n    SB[Standby]\n    LS[Light Sleep]\n    DS[DeepSleep]\n    PO --&gt;|Application Initiated, State: Standby, User Inaction, Power Off| SB\n    PO --&gt;|Crash/Pysical Power OFF| POF\n    SB --&gt;|Application Initiated, State: Deep Sleep, User Inaction/Time Out| DS\n    SB --&gt;|Application Initiated, State: ON, Key Pressed/CEC/MD/FFV| PO\n    SB --&gt;|Reboot / Reboot/Physical Power Off| POF\n    LS --&gt;|Application Initiated, State: Deep Sleep, User Inaction/Time Out| DS\n    LS --&gt;|Application Initiated, State: ON, Key Pressed/CEC/MD/FFV| PO\n    LS --&gt;|Reboot / Physical Power Off| POF\n    DS --&gt;|DS Timeout/MD/FFV, Key Pressed/CEC, WoL/WoWL| LS\n    DS --&gt;|DS Timeout/MD/FFV, Key Pressed/CEC, WoL/WoWL, When Light Sleep is not available| SB\n    DS --&gt;|Physical Power Off| POF\n    POF --&gt;|Cold boot / Plugin / Reset / Reboot| SB</code></pre>"},{"location":"external_content/power_manager/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/power_manager/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/power_manager/CHANGELOG/#103","title":"1.0.3","text":"<ul> <li>gh #3 Update based on review comments <code>#9</code></li> <li>post condation is added for plat_init in the interface file <code>aa60776</code></li> <li>Merge tag '1.0.2' into develop <code>f726b45</code></li> </ul>"},{"location":"external_content/power_manager/CHANGELOG/#102","title":"1.0.2","text":"<p>13 November 2023</p> <ul> <li>Bumped CHANGELOG.md - 1.0.2 <code>a1c1f09</code></li> <li>Updated License file name in header <code>578e520</code></li> <li>Merge tag '1.0.1' into develop <code>c3b2470</code></li> </ul>"},{"location":"external_content/power_manager/CHANGELOG/#101","title":"1.0.1","text":"<p>9 November 2023</p> <ul> <li>updated build_ut.sh generate_doc gitignore <code>#1</code></li> <li>Base files added <code>f2b93e7</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>dbd5eb9</code></li> <li>Initial commit <code>ea4de5b</code></li> </ul>"},{"location":"external_content/power_manager/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/power_manager/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/","title":"Power Manager HAL Documentation","text":""},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Sequence Diagram</li> <li>State Diagram</li> </ul>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>:    Hardware Abstraction Layer</li> <li><code>CPE</code>:    Customer Premises Equipment</li> <li><code>CPU</code>:    Central Processing Unit</li> <li><code>IR</code>:     Infra-red</li> <li><code>HDMI</code>:   High-Definition Multimedia Interface</li> <li><code>A/V</code>:    Audio/Video</li> <li><code>HDD</code>:    Hard Drive Disk</li> </ul>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#references","title":"References","text":""},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#description","title":"Description","text":"<p>The diagram below describes a high-level software architecture of the module stack.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\ny[Caller]&lt;--&gt;x[Power Manager HAL];\nx[Power Manager HAL]&lt;--&gt;z[SOC Drivers];\nstyle y fill:#99CCFF,stroke:#333,stroke-width:0.3px,align:left\nstyle z fill:#fcc,stroke:#333,stroke-width:0.3px,align:left\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px,align:left</code></pre> <p>This interface provides a set of <code>APIs</code> to facilitate communication through the <code>caller</code> and <code>HAL</code>.</p> <p>The Power manger <code>HAL</code> provides a set of <code>APIs</code> to initialize, query and set the power state, and query and set the wake up source.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":""},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p><code>Caller</code> must initialize by calling <code>PLAT_INIT()</code> before calling any other <code>API</code>.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe. Any <code>caller</code> invoking the <code>APIs</code> must ensure calls are made in a thread safe manner.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#process-model","title":"Process Model","text":"<p>This interface is required to support a single instantiation with a single process.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#memory-model","title":"Memory Model","text":"<p>The <code>caller</code> is responsible to pass message buffer and free it for transmit request.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>The Power Manager <code>HAL</code> is involved to set the power management states ON, OFF, STANDBY, and LIGHT_SLEEP. </p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface is not required to support asynchronous notification.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>There are no blocking calls. Synchronous calls must complete within a reasonable time period. Any call that can fail due to the lack of response from the connected device must have a timeout period and the function must return the relevant error code.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All the <code>APIs</code> must return error synchronously as a return argument. <code>HAL</code> is responsible for handling system errors (e.g. out of memory) internally.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement for the interface to persist any setting information. <code>Caller</code> is responsible to persist any settings related to the <code>HAL</code>.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#non-functional-requirements","title":"Non functional requirements","text":""},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. INFO and DEBUG must be disabled by default and enabled when required.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to not cause excessive memory and CPU utilization.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed, e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#licensing","title":"Licensing","text":"<p>The <code>HAL</code> implementation is expected to released under the Apache License 2.0.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#build-requirements","title":"Build Requirements","text":"<p>The source code must build into a shared library and must be named as <code>libiarmmgrs-power-hal.so</code>. The build mechanism must be independent of Yocto.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by the component architects.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>This interface is not required to have any platform or product customizations.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file.</p>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>The <code>caller</code> is expected to have complete control over the life cycle of the <code>HAL</code>.</p> <ul> <li> <p>Initialize the <code>HAL</code> using function: <code>PLAT_INIT()</code> before making any other <code>API</code> calls.  If <code>PLAT_INIT()</code> call fails, the <code>HAL</code> must return the respective error code, so that the <code>caller</code> can retry the operation.</p> </li> <li> <p>Power status settings can be controlled using the functions <code>PLAT_API_SetPowerState()</code> and <code>PLAT_API_SetWakeupSrc()</code> and existing status can be queried using the functions <code>PLAT_API_GetPowerState()</code> and <code>PLAT_API_GetWakeupSrc()</code>.</p> </li> <li> <p>De-initialize the <code>HAL</code> using the function: <code>PLAT_TERM()</code>.</p> </li> </ul>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>%%{ init : { \"theme\" : \"default\", \"flowchart\" : { \"curve\" : \"stepBefore\" }}}%%\n   sequenceDiagram\n    participant Caller as Caller\n    participant HAL as Power Manager HAL\n    participant Device as HAL Device Control/Driver\n    Caller-&gt;&gt;HAL:PLAT_INIT()\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_SetPowerState()\n    Note over HAL: Sets the current power state.\n    HAL-&gt;&gt;Device:Setting power mode.\n    Device--&gt;&gt;HAL:Return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_GetPowerState()\n    Note over HAL: Gets the current power state.\n    HAL-&gt;&gt;Device:Getting current Power Mode\n    Device--&gt;&gt;HAL:Return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_SetWakeupSrc()\n    Note over HAL: Sets the wake-up source.\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL:PLAT_API_GetWakeupSrc()\n    Note over HAL: Gets the current wake-up source.\n    HAL--&gt;&gt;Caller:return\n    Caller -&gt;&gt;HAL:PLAT_TERM()\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/power_manager/docs/pages/power-manager_halSpec/#state-diagram","title":"State Diagram","text":"<pre><code>flowchart TD\n    PO[Powered On]\n    POF[Powered Off]\n    SB[Standby]\n    LS[Light Sleep]\n    DS[DeepSleep]\n    PO --&gt;|Application Initiated, State: Standby, User Inaction, Power Off| SB\n    PO --&gt;|Crash/Pysical Power OFF| POF\n    SB --&gt;|Application Initiated, State: Deep Sleep, User Inaction/Time Out| DS\n    SB --&gt;|Application Initiated, State: ON, Key Pressed/CEC/MD/FFV| PO\n    SB --&gt;|Reboot / Reboot/Physical Power Off| POF\n    LS --&gt;|Application Initiated, State: Deep Sleep, User Inaction/Time Out| DS\n    LS --&gt;|Application Initiated, State: ON, Key Pressed/CEC/MD/FFV| PO\n    LS --&gt;|Reboot / Physical Power Off| POF\n    DS --&gt;|DS Timeout/MD/FFV, Key Pressed/CEC, WoL/WoWL| LS\n    DS --&gt;|DS Timeout/MD/FFV, Key Pressed/CEC, WoL/WoWL, When Light Sleep is not available| SB\n    DS --&gt;|Physical Power Off| POF\n    POF --&gt;|Cold boot / Plugin / Reset / Reboot| SB</code></pre>"},{"location":"external_content/power_manager_test/","title":"Unit Testing Suite For Power Manager HAL","text":""},{"location":"external_content/power_manager_test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Reference Documents</li> <li>Notes</li> </ul>"},{"location":"external_content/power_manager_test/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>- Hardware Abstraction Layer</li> <li><code>L1</code> - Functional Tests</li> <li><code>L2</code> - Module functional Testing</li> <li><code>High-Level Test Specification</code> : These specification will provide a broad overview of the system's functionality from the callers' perspective. It focuses on major use cases, system behavior, and overall caller experience.</li> <li><code>Low-Level Test Specification</code> : These specification will delve deeper into the technical details. They will define specific test cases with inputs, expected outputs, and pass/fail criteria for individual functionalities, modules, or APIs.</li> </ul>"},{"location":"external_content/power_manager_test/#description","title":"Description","text":"<p>This repository contains the Unit Test Suites (L1 &amp; L2) for Power Manager <code>HAL</code>.</p>"},{"location":"external_content/power_manager_test/#reference-documents","title":"Reference Documents","text":"SNo Document Name Document Description Document Link 1 <code>HAL</code> Specification Document This document provides specific information on the APIs for which tests are written in this module power-manager_halSpec.md 2 High Level Test Specification High Level Test Specification Documentation this module power-manager_High-Level_TestSpec.md 3 <code>L2</code> Low Level Test Specification <code>L2</code>Low Level Test Specification Documentation this module power-manager_L2_Low-Level_TestSpec.md"},{"location":"external_content/power_manager_test/#notes","title":"Notes","text":"<ul> <li>All APIs need to be implemented in this current version. If any API is not supported, please add stub implementation with return type PWRMGR_OPERATION_NOT_SUPPORTED for the same.</li> <li>Building against the actual library may introduce SOC dependencies. Hence, a template SKELETON library is created without SOC dependencies. On the real platform (target), it can be mounted, copied and bound with the actual library.</li> <li>When executing the binary, ensure to include a platform-specific profile file as an argument for the designated test cases. The following example illustrates this:</li> </ul> <p><code>bash ./hal_test -p sink_powerManager.yaml</code></p> <p>Alternatively, use the run.sh script with the profile file:</p> <p><code>bash ./run.sh -p /absolute/path/to/profile/file</code></p> <p>Profiles file available for sink and source at sink profile yaml file and  source  profile yaml file</p> <ul> <li>Install Python Environment and Activation Scripts please check theHPK Documentation</li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/power_manager_test/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/power_manager_test/CHANGELOG/#140","title":"1.4.0","text":"<ul> <li>gh #30 Setting SetWakeupSrc to false causing issues <code>#31</code></li> <li>gh #32 Update UTCore version to 4.x <code>#33</code></li> <li>gh #28 powerManager: L3 Test case Development <code>#29</code></li> <li>gh #22 powerManager: L3 Test case Development <code>#23</code></li> <li>gh #24 initial l3 layout <code>#25</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#131","title":"1.3.1","text":"<p>13 August 2024</p> <ul> <li>gh #20 Update the run.sh script &amp; README.md <code>#21</code></li> <li>Bumped CHANGELOG.md - 1.3.1 <code>13480f5</code></li> <li>Merge tag '1.3.0' into develop <code>302a2bf</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#130","title":"1.3.0","text":"<p>9 August 2024</p> <ul> <li>gh #18 Feature/gh18 makefile cleanup <code>#19</code></li> <li>gh #15 Code Cleanup in L1 for power_manager <code>#17</code></li> <li>gh #11 Test profile changes for powermanager <code>#16</code></li> <li>gh #12 Power_manager updated interface changes <code>#13</code></li> <li>gh #15 updating codecleanup changes <code>2d4c50f</code></li> <li>gh #11 Addressing review comments for powermanager <code>1a21adc</code></li> <li>gh #12 power_manager updated interface changes <code>fc35036</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#120","title":"1.2.0","text":"<p>26 June 2024</p> <ul> <li>gh #5 power manager test suit spec &amp; L2 code <code>#6</code></li> <li>gh #5 updated yaml file and code modification to read it <code>d378296</code></li> <li>Updated test spec and moved test procedure to <code>de1532b</code></li> <li>gh #5 Updated test spec name &amp; minior changes <code>fea7dd0</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#111","title":"1.1.1","text":"<p>5 June 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.1.1 <code>73761a8</code></li> <li>Updated README.md <code>109688c</code></li> <li>Merge tag '1.1.0' into develop <code>70ee094</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#110","title":"1.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #7 power_manager: Disabling enhanced error code <code>#9</code></li> <li>Enhanced error code moved to kvp\u00a0 profiler <code>1c42890</code></li> <li>powermanager  enhanced error code update <code>6b331f1</code></li> <li>Bumped CHANGELOG.md - 1.1.0 <code>a63b08b</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#104","title":"1.0.4","text":"<p>20 February 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.0.4 <code>3527421</code></li> <li>Updated tag version in README.md <code>99eea2b</code></li> <li>Merge tag '1.0.3' into develop <code>1711046</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#103","title":"1.0.3","text":"<p>29 January 2024</p> <ul> <li>UT Core 2.0 update and cleanup <code>2ad7e46</code></li> <li>removed unnecessary definitions <code>7ca65c6</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>82df645</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#102","title":"1.0.2","text":"<p>12 December 2023</p> <ul> <li>Updated README.md with hal &amp; haltest supported version <code>79edc5c</code></li> <li>Bumped CHANGELOG.md - 1.0.2 <code>425aff0</code></li> <li>Merge tag '1.0.1' into develop <code>892ceed</code></li> </ul>"},{"location":"external_content/power_manager_test/CHANGELOG/#101","title":"1.0.1","text":"<p>7 December 2023</p> <ul> <li>baseline version <code>5786990</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>5a94736</code></li> <li>Initial commit <code>ded9b27</code></li> </ul>"},{"location":"external_content/power_manager_test/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/","title":"Power Manager High Level Test Specification Documentation","text":""},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Testing Scope</li> <li>Set And Get Power States</li> <li>Set and Get Status of Wakeup Sources</li> <li>Testing Wakeup Source</li> <li>Test Reset Functionality</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>API</code> - Application Programming Interface</li> <li><code>L2</code> - Level 2 Testing ()</li> <li><code>L3</code> - Level 3 Testing ()</li> <li><code>IR</code> - Infrared</li> <li><code>CEC</code> - Consumer Electronics Control</li> <li><code>LAN</code> - Local Area Network</li> <li><code>NA</code> - Not Applicable</li> <li><code>Y</code> - Yes</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of High Level testing requirements for the Power Manager module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, control plane emulator requirements and expected deliverables.</p> <p>Interface of the test is available here: Power Manager HAL header</p> <p>The Power manager Hal Spec document: Power Manager HAL Spec</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#testing-scope","title":"Testing Scope","text":"# Test Functionality Description 1 Set And Get Power States Power Manager should set the power state provided by caller and same should be retrieved 2 Set and Get Status of Wakeup Sources Power Manager should set the wakeup source provided by caller and same should be retrieved 3 Testing Wakeup Source Power manager should accept the supported wakeup sources and device should wakeup from standby/sleep modes using wakeup sources set by caller 4 Test Reset Functionality Power manager should reboot the device"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#emulator-requirements","title":"Emulator Requirements","text":"<ul> <li>Boot configuration: Wakeup sources supported by the device. See DeepSleep_WakeupReason_t.</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#set-and-get-power-states","title":"Set And Get Power States","text":"Description HAL APIs L2 L3 Control plane requirements Set various power states and retrieve it for verification based on the platform configuration file. For source devices, check with the \"source_powerManager.yaml\" using the path \"powermanager.PowerStates\" and for sink devices, check with the \"sink_powerManager.yaml\" using the path \"powermanager.PowerStates\" PLAT_API_SetPowerState, PLAT_API_GetPowerState <code>Y</code> <code>NA</code> <code>NA</code>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#test-startup-requirement-set-and-get-power-states","title":"Test Startup Requirement - Set And Get Power States","text":"<p><code>NA</code></p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#emulator-requirements-set-and-get-power-states","title":"Emulator Requirements - Set And Get Power States","text":"<p><code>NA</code></p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#control-plane-requirements-set-and-get-power-states","title":"Control Plane Requirements - Set And Get Power States","text":"<p><code>NA</code></p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#set-and-get-status-of-wakeup-sources","title":"Set and Get Status of Wakeup Sources","text":"Description HAL APIs L2 L3 Control plane requirements Set status of various wakeup sources and retrieves status for verification based on the platform configuration. For source devices, check with the \"source_powerManager.yaml\" using the path \"powermanager.WakeupSources\" and for sink devices, check with the \"sink_powerManager.yaml\" using the path \"powermanager.WakeupSources\" PLAT_API_SetWakeupSrc, PLAT_API_GetWakeupSrc <code>Y</code> <code>NA</code> <code>NA</code>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#test-startup-requirement-set-and-get-status-of-wakeup-sources","title":"Test Startup Requirement - Set and Get Status of Wakeup Sources","text":"<p><code>NA</code></p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#emulator-requirements-set-and-get-status-of-wakeup-sources","title":"Emulator Requirements - Set and Get Status of Wakeup Sources","text":"<p>Emulator Requirements</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#control-plane-requirements-set-and-get-status-of-wakeup-sources","title":"Control Plane Requirements - Set and Get Status of Wakeup Sources","text":"<p><code>NA</code></p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#testing-wakeup-source","title":"Testing Wakeup Source","text":"<p>Testing the wake-up sources is already done within the deep-sleep L3 test specification.</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_High-Level_TestSpec/#test-reset-functionality","title":"Test Reset Functionality","text":"<p>This function is depreciated and we are not testing depreciated functions.</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/","title":"Power Manager L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>Definitions</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#overview","title":"Overview","text":"<p>This document describes the Low Level 2 Test Specification and Procedure for the PLAT POWER module.</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#definitions","title":"Definitions","text":"<ul> <li><code>ut-core</code> - Common Testing Framework https://github.com/rdkcentral/ut-core, which wraps a open-source framework that can be expanded to the requirements for future framework.</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - Power Manager High Level Test Spec</li> <li><code>HAL Interface file</code> - Power Manager HAL header</li> </ul>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_plat_power_SetAndGetPowerState</code> Description Set various power states and retrieve it for verification Test Group 02 Test Case ID 001 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#test-procedure-test-1","title":"Test Procedure - Test 1","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the platform using PLAT_INIT None PWRMGR_SUCCESS Should be successful 02 Set supported power states using PLAT_API_SetPowerState powerState = Read <code>powermanager.PowerStates</code> from the configuration file PWRMGR_SUCCESS Should be successful 03 Get the current power state using PLAT_API_GetPowerState and verify getState = valid buffer PWRMGR_SUCCESS, getState = powerState Should be successful 04 Terminate the platform using PLAT_TERM None PWRMGR_SUCCESS Should be successful <pre><code>graph TB\nA[Call PLAT_INIT] --&gt;|PWRMGR_SUCCESS| B{Call PLAT_API_SetPowerState &lt;br&gt; with supported power states}\nB --&gt;|PWRMGR_SUCCESS| C[Call PLAT_API_GetPowerState]\nC --&gt;D[Verify get and &lt;br&gt; set power states]\nD --&gt;|PWRMGR_SUCCESS| B\nB --&gt;|End of loop|L[Call PLAT_TERM]\nL --&gt;|PWRMGR_SUCCESS| M[Test case success]\nA --&gt;|Failure| N[Test case fail]\nL --&gt;|Failure| T[Test case fail]</code></pre>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_plat_power_SetAndGetWakeupSrc</code> Description Set status of various wakeup sources and retrieves status for verification based on the platform configuration Test Group 02 Test Case ID 002 Priority High <p>Pre-Conditions None</p> <p>Dependencies None</p> <p>User Interaction If user chose to run the test in interactive mode, then the test case has to be selected via console.</p>"},{"location":"external_content/power_manager_test/docs/pages/power-manager_L2_Low-Level_TestSpec/#test-procedure-test-2","title":"Test Procedure - Test 2","text":"Variation / Steps Description Test Data Expected Result Notes 01 Initialize the platform using PLAT_INIT None PWRMGR_SUCCESS Should be successful 02 Set supported wakeup source to true using PLAT_API_SetWakeupSrc for each source type srcType = Read <code>powermanager.WakeupSources</code> from configuration file, enable = true PWRMGR_SUCCESS Should be successful 03 Get supported wakeup source status using PLAT_API_GetWakeupSrc for each source type and verify srcType = Read <code>powermanager.WakeupSources</code> from configuration file PWRMGR_SUCCESS, enable = true Should be successful 04 Set supported wakeup source to false using PLAT_API_SetWakeupSrc for each source type srcType = Read <code>powermanager.WakeupSources</code> from configuration file, enable = false PWRMGR_SUCCESS Should be successful 05 Get supported wakeup source status using PLAT_API_GetWakeupSrc for each source type and verify srcType = Read <code>powermanager.WakeupSources</code> from configuration file PWRMGR_SUCCESS, enable = false Should be successful 06 Terminate the platform using PLAT_TERM None PWRMGR_SUCCESS Should be successful <pre><code>graph TB\nA[Call PLAT_INIT] --&gt;|PWRMGR_SUCCESS| B{For each supported wakeup source type &lt;br&gt; in PWRMGR_WakeupSrcType_t}\nB --&gt; C[Call PLAT_API_SetWakeupSrc &lt;br&gt; and enable set to true]\nC --&gt;|PWRMGR_SUCCESS| D[Call PLAT_API_GetWakeupSrc &lt;br&gt; and verify]\nD --&gt;|PWRMGR_SUCCESS, &lt;br&gt;enable = true| E[Call PLAT_API_SetWakeupSrc &lt;br&gt; and enable set to false]\nE --&gt;|PWRMGR_SUCCESS| F[Call PLAT_API_GetWakeupSrc and verify]\nF --&gt;|PWRMGR_SUCCESS, &lt;br&gt; enable = false| B\nA --&gt;|Failure| G[Test case fail]\nB --&gt; L[Call PLAT_TERM]\nL --&gt;|PWRMGR_SUCCESS| M[Test case success]\nL --&gt;|Failure| N[Test case fail]</code></pre>"},{"location":"external_content/rmf_audio_capture/","title":"RMF Audio Capture HAL Documentation","text":""},{"location":"external_content/rmf_audio_capture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operations<ul> <li>Architecture Diagram</li> </ul> </li> <li>Diagrams<ul> <li>Operational call sequence</li> <li>State machine diagram</li> </ul> </li> </ul>"},{"location":"external_content/rmf_audio_capture/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>    - Application Programming Interface</li> <li><code>HAL</code>    - Hardware Abstraction layer</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>RDK</code>    - Reference Development Kit</li> <li><code>RMF</code>    - RDK Media Framework</li> <li><code>STB</code>    - Set Top Box</li> <li><code>Caller</code> - Any user of the interface</li> </ul>"},{"location":"external_content/rmf_audio_capture/#description","title":"Description","text":"<p>RMF Audio Capture <code>HAL</code> must deliver a constant stream of raw audio data (<code>PCM</code>) to the <code>caller</code>. The purpose of audio capture is to tap the final mix of the decoded audio. The audio data delivered via this interface is required to track as closely as possible, i. e., minimal latency, to the audio that's being rendered by the device at a given point of time. Audio Capture must support capture of primary audio, and may optionally support auxiliary audio (alternate language audio tracks etc.) as well. Where auxiliary audio is supported, <code>HAL</code> must be able to support concurrent capture sessions for both primary and auxiliary audio. However, <code>caller</code> will not seek to open more than one instance of a capture per source at any point of time.</p> <p>Should a situation arise where there is no audio data available to capture (eg: no active video playback), <code>HAL</code> must continue to send buffers to caller that are filled with silence. <code>HAL</code> must maintain the expected data rate for the format while doing so.</p> <p>As far as audio format support is concerned, <code>HAL</code> is not required to support all formats and sampling rates defined in the header file. However, 16-bit stereo PCM format must be supported at a sampling rate of 44.1kHz or higher.</p> <pre><code>flowchart LR\n    subgraph Inputs\n        A1[\"audio 1\"]\n        A2[\"audio 2\"]\n        AN[\"audio N\"]\n    end\n\n    A1 --&gt; Mixer\n    A2 --&gt; Mixer\n    AN --&gt; Mixer\n\n    Mixer --&gt;|mixed audio| AudioCapture\n    AudioCapture --&gt;|to caller| Caller\n\n    Mixer --&gt;|mixed audio| Output\n    Output[\"to speaker, HDMI, SPDIF,\nbluetooth output\"]</code></pre>"},{"location":"external_content/rmf_audio_capture/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>These requirements ensure that the <code>HAL</code> executes correctly within the run-time environment that it will be used in.</p>"},{"location":"external_content/rmf_audio_capture/#initialization-and-startup","title":"Initialization and Startup","text":"<p>Caller is expected to have complete control over the lifecycle of Audio Capture <code>HAL</code> (from open to close).</p>"},{"location":"external_content/rmf_audio_capture/#threading-model","title":"Threading Model","text":"<p>This interface is required to be thread-safe and will be invoked from multiple <code>caller</code> threads. Data callback <code>RMF_AudioCaptureBufferReadyCb()</code> must originate in a thread that's separate from <code>caller</code> context(s). Caller will not make any <code>HAL</code> calls in the context of <code>RMF_AudioCaptureBufferReadyCb()</code> and <code>RMF_AudioCapture_StatusChangeCb()</code>.</p>"},{"location":"external_content/rmf_audio_capture/#process-model","title":"Process Model","text":"<p>Caller will take care of Audio Capture <code>HAL</code> initialization. The interface is expected to support a single instantiation with a single process.</p>"},{"location":"external_content/rmf_audio_capture/#memory-model","title":"Memory Model","text":"<p>Audio Capture <code>HAL</code> is responsible for its own memory management. The buffer used for audio data passed by <code>RMF_AudioCaptureBufferReadyCb()</code> must be managed after the callback returns.</p>"},{"location":"external_content/rmf_audio_capture/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to be involved in any power management funtionality.</p>"},{"location":"external_content/rmf_audio_capture/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>No asynchronous notification is required.</p>"},{"location":"external_content/rmf_audio_capture/#blocking-calls","title":"Blocking calls","text":"<p>The following callbacks may block depending on the <code>caller's</code> internal operations but will endeavour to return as soon as possible.</p> <ol> <li><code>RMF_AudioCaptureBufferReadyCb()</code></li> <li><code>RMF_AudioCapture_StatusChangeCb()</code></li> </ol>"},{"location":"external_content/rmf_audio_capture/#internal-error-handling","title":"Internal Error Handling","text":"<p>All APIs must return errors synchronously as a return argument. The interface is responsible for managing its internal errors.</p>"},{"location":"external_content/rmf_audio_capture/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement to persist any settings information. The necessary parameters will be passed with <code>RMF_AudioCapture_Start()</code> for every audio capture session.</p>"},{"location":"external_content/rmf_audio_capture/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements are required to be supported by this interface:</p>"},{"location":"external_content/rmf_audio_capture/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"external_content/rmf_audio_capture/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to use only minimal memory/CPU resources while in closed/stopped state.</p>"},{"location":"external_content/rmf_audio_capture/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/rmf_audio_capture/#licensing","title":"Licensing","text":"<p>The Audio Capture header file is released under Apache 2.0 license. The implementation may use any license compatible with the aforementioned header file.</p>"},{"location":"external_content/rmf_audio_capture/#build-requirements","title":"Build Requirements","text":"<p>This interface is required to build into shared library. The shared library must be named <code>librmfAudioCapture.so</code>. The building mechanism must be independent of Yocto.</p>"},{"location":"external_content/rmf_audio_capture/#variability-management","title":"Variability Management","text":"<p>Any new <code>API</code> introduced must be implemented by all the 3rd party modules. Currently there is little to no variability expected across various implementations. Any change to the interface must be reviewed and approved by component architects and owners.</p>"},{"location":"external_content/rmf_audio_capture/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The default settings returned via <code>RMF_AudioCapture_GetDefaultSettings()</code> will be configured with parameters that are favourable to the implementation. The <code>caller</code> will typically not change any of these parameters unless strictly necessary.</p>"},{"location":"external_content/rmf_audio_capture/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation is provided via doxygen comments in the header file.</p>"},{"location":"external_content/rmf_audio_capture/#theory-of-operations","title":"Theory of operations","text":"<p><code>Caller</code> will configure Audio Capture interface with the necessary settings and start the capture. <code>HAL</code> will deliver audio and status updates via the registered callbacks in a timely fashion. Calling <code>RMF_AudioCapture_Open()</code> is a necessary precondition for the remaining APIs to work.</p>"},{"location":"external_content/rmf_audio_capture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart\n    D[Caller] --&gt; |control| E[Audio Capture HAL]\n    E --&gt; |audio data| D</code></pre> <p>Following is a typical sequence of operation: 1. Open the interface using <code>RMF_AudioCapture_Open()</code> or <code>RMF_AudioCapture_Open_Type()</code>. 2. Get default settings using <code>RMF_AudioCapture_GetDefaultSettings()</code>. This returns a struct of parameters favourable to the <code>HAL</code>. Application may tweak certain members of this struct and pass it with the start call. 3. Start audio capture using <code>RMF_AudioCapture_Start()</code>. The interface will continuously deliver audio data to <code>caller</code> in real time via callback <code>RMF_AudioCaptureBufferReadyCb()</code>. 4. When the audio stream is no longer needed, stop audio capture using <code>RMF_AudioCapture_Stop()</code>. This will stop the 'HAL' callbacks. 5. Close the interface using <code>RMF_AudioCapture_Close()</code>.</p>"},{"location":"external_content/rmf_audio_capture/#diagrams","title":"Diagrams","text":""},{"location":"external_content/rmf_audio_capture/#operational-call-sequence","title":"Operational call sequence","text":"<pre><code>   sequenceDiagram\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Open()/RMF_AudioCapture_Open_Type()\n    activate HAL\n    HAL--&gt;&gt;caller: handle\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_GetDefaultSettings()\n    activate HAL\n    HAL--&gt;&gt;caller: default settings\n    deactivate HAL\n    caller-&gt;&gt;caller: generate settings from default settings\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Start(handle, settings)\n    activate HAL\n    loop as long as stop is not called\n    HAL-&gt;&gt;caller:RMF_AudioCaptureBufferReadyCb(audio buffer)\n    activate caller\n    caller-&gt;&gt;caller:consume buffer\n    caller--&gt;&gt;HAL: return\n    deactivate caller\n    end\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Stop(handle)\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Close(handle</code></pre>"},{"location":"external_content/rmf_audio_capture/#state-machine-diagram","title":"State machine Diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Open: Open()\n    Open --&gt; Started: Start()\n    Started: Started\\n(pumping data)\n    Started --&gt; Open: Stop()\n    Open --&gt; Closed: Close()\n    Closed --&gt; [*]</code></pre>"},{"location":"external_content/rmf_audio_capture/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/rmf_audio_capture/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/rmf_audio_capture/CHANGELOG/#105","title":"1.0.5","text":"<ul> <li>gh #6 HAL spec updates following review <code>#7</code></li> <li>RDK-51275: HAL spec updates following review <code>26840a6</code></li> <li>Merge tag '1.0.4' into develop <code>92e29fa</code></li> </ul>"},{"location":"external_content/rmf_audio_capture/CHANGELOG/#104","title":"1.0.4","text":"<p>23 November 2023</p> <ul> <li>baseline version <code>a70dca8</code></li> <li>Added CHANGELOG.md - 1.0.4 <code>b51c356</code></li> <li>Initial commit <code>74f0003</code></li> </ul>"},{"location":"external_content/rmf_audio_capture/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/","title":"RMF Audio Capture HAL Documentation","text":""},{"location":"external_content/rmf_audio_capture/docs/pages/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operations<ul> <li>Architecture Diagram</li> </ul> </li> <li>Diagrams<ul> <li>Operational call sequence</li> <li>State machine diagram</li> </ul> </li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>    - Application Programming Interface</li> <li><code>HAL</code>    - Hardware Abstraction layer</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>RDK</code>    - Reference Development Kit</li> <li><code>RMF</code>    - RDK Media Framework</li> <li><code>STB</code>    - Set Top Box</li> <li><code>Caller</code> - Any user of the interface</li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/#description","title":"Description","text":"<p>RMF Audio Capture <code>HAL</code> must deliver a constant stream of raw audio data (<code>PCM</code>) to the <code>caller</code>. The purpose of audio capture is to tap the final mix of the decoded audio. The audio data delivered via this interface is required to track as closely as possible, i. e., minimal latency, to the audio that's being rendered by the device at a given point of time. Audio Capture must support capture of primary audio, and may optionally support auxiliary audio (alternate language audio tracks etc.) as well. Where auxiliary audio is supported, <code>HAL</code> must be able to support concurrent capture sessions for both primary and auxiliary audio. However, <code>caller</code> will not seek to open more than one instance of a capture per source at any point of time.</p> <p>Should a situation arise where there is no audio data available to capture (eg: no active video playback), <code>HAL</code> must continue to send buffers to caller that are filled with silence. <code>HAL</code> must maintain the expected data rate for the format while doing so.</p> <p>As far as audio format support is concerned, <code>HAL</code> is not required to support all formats and sampling rates defined in the header file. However, 16-bit stereo PCM format must be supported at a sampling rate of 44.1kHz or higher.</p> <pre><code>flowchart LR\n    subgraph Inputs\n        A1[\"audio 1\"]\n        A2[\"audio 2\"]\n        AN[\"audio N\"]\n    end\n\n    A1 --&gt; Mixer\n    A2 --&gt; Mixer\n    AN --&gt; Mixer\n\n    Mixer --&gt;|mixed audio| AudioCapture\n    AudioCapture --&gt;|to caller| Caller\n\n    Mixer --&gt;|mixed audio| Output\n    Output[\"to speaker, HDMI, SPDIF,\nbluetooth output\"]</code></pre>"},{"location":"external_content/rmf_audio_capture/docs/pages/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>These requirements ensure that the <code>HAL</code> executes correctly within the run-time environment that it will be used in.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#initialization-and-startup","title":"Initialization and Startup","text":"<p>Caller is expected to have complete control over the lifecycle of Audio Capture <code>HAL</code> (from open to close).</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#threading-model","title":"Threading Model","text":"<p>This interface is required to be thread-safe and will be invoked from multiple <code>caller</code> threads. Data callback <code>RMF_AudioCaptureBufferReadyCb()</code> must originate in a thread that's separate from <code>caller</code> context(s). Caller will not make any <code>HAL</code> calls in the context of <code>RMF_AudioCaptureBufferReadyCb()</code> and <code>RMF_AudioCapture_StatusChangeCb()</code>.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#process-model","title":"Process Model","text":"<p>Caller will take care of Audio Capture <code>HAL</code> initialization. The interface is expected to support a single instantiation with a single process.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#memory-model","title":"Memory Model","text":"<p>Audio Capture <code>HAL</code> is responsible for its own memory management. The buffer used for audio data passed by <code>RMF_AudioCaptureBufferReadyCb()</code> must be managed after the callback returns.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to be involved in any power management funtionality.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>No asynchronous notification is required.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#blocking-calls","title":"Blocking calls","text":"<p>The following callbacks may block depending on the <code>caller's</code> internal operations but will endeavour to return as soon as possible.</p> <ol> <li><code>RMF_AudioCaptureBufferReadyCb()</code></li> <li><code>RMF_AudioCapture_StatusChangeCb()</code></li> </ol>"},{"location":"external_content/rmf_audio_capture/docs/pages/#internal-error-handling","title":"Internal Error Handling","text":"<p>All APIs must return errors synchronously as a return argument. The interface is responsible for managing its internal errors.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement to persist any settings information. The necessary parameters will be passed with <code>RMF_AudioCapture_Start()</code> for every audio capture session.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements are required to be supported by this interface:</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to use only minimal memory/CPU resources while in closed/stopped state.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/#licensing","title":"Licensing","text":"<p>The Audio Capture header file is released under Apache 2.0 license. The implementation may use any license compatible with the aforementioned header file.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#build-requirements","title":"Build Requirements","text":"<p>This interface is required to build into shared library. The shared library must be named <code>librmfAudioCapture.so</code>. The building mechanism must be independent of Yocto.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#variability-management","title":"Variability Management","text":"<p>Any new <code>API</code> introduced must be implemented by all the 3rd party modules. Currently there is little to no variability expected across various implementations. Any change to the interface must be reviewed and approved by component architects and owners.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The default settings returned via <code>RMF_AudioCapture_GetDefaultSettings()</code> will be configured with parameters that are favourable to the implementation. The <code>caller</code> will typically not change any of these parameters unless strictly necessary.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation is provided via doxygen comments in the header file.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#theory-of-operations","title":"Theory of operations","text":"<p><code>Caller</code> will configure Audio Capture interface with the necessary settings and start the capture. <code>HAL</code> will deliver audio and status updates via the registered callbacks in a timely fashion. Calling <code>RMF_AudioCapture_Open()</code> is a necessary precondition for the remaining APIs to work.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart\n    D[Caller] --&gt; |control| E[Audio Capture HAL]\n    E --&gt; |audio data| D</code></pre> <p>Following is a typical sequence of operation: 1. Open the interface using <code>RMF_AudioCapture_Open()</code> or <code>RMF_AudioCapture_Open_Type()</code>. 2. Get default settings using <code>RMF_AudioCapture_GetDefaultSettings()</code>. This returns a struct of parameters favourable to the <code>HAL</code>. Application may tweak certain members of this struct and pass it with the start call. 3. Start audio capture using <code>RMF_AudioCapture_Start()</code>. The interface will continuously deliver audio data to <code>caller</code> in real time via callback <code>RMF_AudioCaptureBufferReadyCb()</code>. 4. When the audio stream is no longer needed, stop audio capture using <code>RMF_AudioCapture_Stop()</code>. This will stop the 'HAL' callbacks. 5. Close the interface using <code>RMF_AudioCapture_Close()</code>.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/#diagrams","title":"Diagrams","text":""},{"location":"external_content/rmf_audio_capture/docs/pages/#operational-call-sequence","title":"Operational call sequence","text":"<pre><code>   sequenceDiagram\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Open()/RMF_AudioCapture_Open_Type()\n    activate HAL\n    HAL--&gt;&gt;caller: handle\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_GetDefaultSettings()\n    activate HAL\n    HAL--&gt;&gt;caller: default settings\n    deactivate HAL\n    caller-&gt;&gt;caller: generate settings from default settings\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Start(handle, settings)\n    activate HAL\n    loop as long as stop is not called\n    HAL-&gt;&gt;caller:RMF_AudioCaptureBufferReadyCb(audio buffer)\n    activate caller\n    caller-&gt;&gt;caller:consume buffer\n    caller--&gt;&gt;HAL: return\n    deactivate caller\n    end\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Stop(handle)\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Close(handle</code></pre>"},{"location":"external_content/rmf_audio_capture/docs/pages/#state-machine-diagram","title":"State machine Diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Open: Open()\n    Open --&gt; Started: Start()\n    Started: Started\\n(pumping data)\n    Started --&gt; Open: Stop()\n    Open --&gt; Closed: Close()\n    Closed --&gt; [*]</code></pre>"},{"location":"external_content/rmf_audio_capture/docs/pages/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/rmf_audio_capture/docs/pages/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/CHANGELOG/#105","title":"1.0.5","text":"<ul> <li>gh #6 HAL spec updates following review <code>#7</code></li> <li>RDK-51275: HAL spec updates following review <code>26840a6</code></li> <li>Merge tag '1.0.4' into develop <code>92e29fa</code></li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/CHANGELOG/#104","title":"1.0.4","text":"<p>23 November 2023</p> <ul> <li>baseline version <code>a70dca8</code></li> <li>Added CHANGELOG.md - 1.0.4 <code>b51c356</code></li> <li>Initial commit <code>74f0003</code></li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/LICENSE/","title":"LICENSE","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/NOTICE/","title":"NOTICE","text":"<p>This component contains software that is Copyright (c) 2023 RDK Management. The component is licensed to you under the Apache License, Version 2.0 (the \"License\"). You may not use the component except in compliance with the License.</p> <p>The component may include material which is licensed under other licenses / copyrights as listed below.  Your use of this material within the component is also subject to the terms and conditions of these licenses.  The LICENSE file contains the text of all the licenses which apply within this component.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/","title":"RMF Audio Capture HAL Documentation","text":""},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operations<ul> <li>Architecture Diagram</li> </ul> </li> <li>Diagrams<ul> <li>Operational call sequence</li> <li>State machine diagram</li> </ul> </li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>    - Application Programming Interface</li> <li><code>HAL</code>    - Hardware Abstraction layer</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>RDK</code>    - Reference Development Kit</li> <li><code>RMF</code>    - RDK Media Framework</li> <li><code>STB</code>    - Set Top Box</li> <li><code>Caller</code> - Any user of the interface</li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#description","title":"Description","text":"<p>RMF Audio Capture <code>HAL</code> must deliver a constant stream of raw audio data (<code>PCM</code>) to the <code>caller</code>. The purpose of audio capture is to tap the final mix of the decoded audio. The audio data delivered via this interface is required to track as closely as possible, i. e., minimal latency, to the audio that's being rendered by the device at a given point of time. Audio Capture must support capture of primary audio, and may optionally support auxiliary audio (alternate language audio tracks etc.) as well. Where auxiliary audio is supported, <code>HAL</code> must be able to support concurrent capture sessions for both primary and auxiliary audio. However, <code>caller</code> will not seek to open more than one instance of a capture per source at any point of time.</p> <p>Should a situation arise where there is no audio data available to capture (eg: no active video playback), <code>HAL</code> must continue to send buffers to caller that are filled with silence. <code>HAL</code> must maintain the expected data rate for the format while doing so.</p> <p>As far as audio format support is concerned, <code>HAL</code> is not required to support all formats and sampling rates defined in the header file. However, 16-bit stereo PCM format must be supported at a sampling rate of 44.1kHz or higher.</p> <pre><code>flowchart LR\n    subgraph Inputs\n        A1[\"audio 1\"]\n        A2[\"audio 2\"]\n        AN[\"audio N\"]\n    end\n\n    A1 --&gt; Mixer\n    A2 --&gt; Mixer\n    AN --&gt; Mixer\n\n    Mixer --&gt;|mixed audio| AudioCapture\n    AudioCapture --&gt;|to caller| Caller\n\n    Mixer --&gt;|mixed audio| Output\n    Output[\"to speaker, HDMI, SPDIF,\nbluetooth output\"]</code></pre>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>These requirements ensure that the <code>HAL</code> executes correctly within the run-time environment that it will be used in.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p>Caller is expected to have complete control over the lifecycle of Audio Capture <code>HAL</code> (from open to close).</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is required to be thread-safe and will be invoked from multiple <code>caller</code> threads. Data callback <code>RMF_AudioCaptureBufferReadyCb()</code> must originate in a thread that's separate from <code>caller</code> context(s). Caller will not make any <code>HAL</code> calls in the context of <code>RMF_AudioCaptureBufferReadyCb()</code> and <code>RMF_AudioCapture_StatusChangeCb()</code>.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#process-model","title":"Process Model","text":"<p>Caller will take care of Audio Capture <code>HAL</code> initialization. The interface is expected to support a single instantiation with a single process.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#memory-model","title":"Memory Model","text":"<p>Audio Capture <code>HAL</code> is responsible for its own memory management. The buffer used for audio data passed by <code>RMF_AudioCaptureBufferReadyCb()</code> must be managed after the callback returns.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to be involved in any power management funtionality.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>No asynchronous notification is required.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>The following callbacks may block depending on the <code>caller's</code> internal operations but will endeavour to return as soon as possible.</p> <ol> <li><code>RMF_AudioCaptureBufferReadyCb()</code></li> <li><code>RMF_AudioCapture_StatusChangeCb()</code></li> </ol>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All APIs must return errors synchronously as a return argument. The interface is responsible for managing its internal errors.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement to persist any settings information. The necessary parameters will be passed with <code>RMF_AudioCapture_Start()</code> for every audio capture session.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements are required to be supported by this interface:</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to use only minimal memory/CPU resources while in closed/stopped state.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#licensing","title":"Licensing","text":"<p>The Audio Capture header file is released under Apache 2.0 license. The implementation may use any license compatible with the aforementioned header file.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#build-requirements","title":"Build Requirements","text":"<p>This interface is required to build into shared library. The shared library must be named <code>librmfAudioCapture.so</code>. The building mechanism must be independent of Yocto.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#variability-management","title":"Variability Management","text":"<p>Any new <code>API</code> introduced must be implemented by all the 3rd party modules. Currently there is little to no variability expected across various implementations. Any change to the interface must be reviewed and approved by component architects and owners.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The default settings returned via <code>RMF_AudioCapture_GetDefaultSettings()</code> will be configured with parameters that are favourable to the implementation. The <code>caller</code> will typically not change any of these parameters unless strictly necessary.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation is provided via doxygen comments in the header file.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#theory-of-operations","title":"Theory of operations","text":"<p><code>Caller</code> will configure Audio Capture interface with the necessary settings and start the capture. <code>HAL</code> will deliver audio and status updates via the registered callbacks in a timely fashion. Calling <code>RMF_AudioCapture_Open()</code> is a necessary precondition for the remaining APIs to work.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart\n    D[Caller] --&gt; |control| E[Audio Capture HAL]\n    E --&gt; |audio data| D</code></pre> <p>Following is a typical sequence of operation: 1. Open the interface using <code>RMF_AudioCapture_Open()</code> or <code>RMF_AudioCapture_Open_Type()</code>. 2. Get default settings using <code>RMF_AudioCapture_GetDefaultSettings()</code>. This returns a struct of parameters favourable to the <code>HAL</code>. Application may tweak certain members of this struct and pass it with the start call. 3. Start audio capture using <code>RMF_AudioCapture_Start()</code>. The interface will continuously deliver audio data to <code>caller</code> in real time via callback <code>RMF_AudioCaptureBufferReadyCb()</code>. 4. When the audio stream is no longer needed, stop audio capture using <code>RMF_AudioCapture_Stop()</code>. This will stop the 'HAL' callbacks. 5. Close the interface using <code>RMF_AudioCapture_Close()</code>.</p>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#operational-call-sequence","title":"Operational call sequence","text":"<pre><code>   sequenceDiagram\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Open()/RMF_AudioCapture_Open_Type()\n    activate HAL\n    HAL--&gt;&gt;caller: handle\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_GetDefaultSettings()\n    activate HAL\n    HAL--&gt;&gt;caller: default settings\n    deactivate HAL\n    caller-&gt;&gt;caller: generate settings from default settings\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Start(handle, settings)\n    activate HAL\n    loop as long as stop is not called\n    HAL-&gt;&gt;caller:RMF_AudioCaptureBufferReadyCb(audio buffer)\n    activate caller\n    caller-&gt;&gt;caller:consume buffer\n    caller--&gt;&gt;HAL: return\n    deactivate caller\n    end\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Stop(handle)\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Close(handle</code></pre>"},{"location":"external_content/rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#state-machine-diagram","title":"State machine Diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Open: Open()\n    Open --&gt; Started: Start()\n    Started: Started\\n(pumping data)\n    Started --&gt; Open: Stop()\n    Open --&gt; Closed: Close()\n    Closed --&gt; [*]</code></pre>"},{"location":"external_content/rmf_audio_capture_test/","title":"Unit Testing Suite For RMF Audio Capture HAL","text":""},{"location":"external_content/rmf_audio_capture_test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Reference Documents</li> <li>Notes</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>L1</code> - Functional Tests</li> <li><code>L2</code> - Module functional Testing</li> <li><code>L3</code> - Module testing with External Stimulus is required to validate and control device</li> <li><code>HAL</code>- Hardware Abstraction Layer</li> <li><code>High-Level Test Specification</code> : These specification will provide a broad overview of the system's functionality from the callers' perspective. It focuses on major use cases, system behavior, and overall caller experience.</li> <li><code>Low-Level Test Specification</code> : These specification will delve deeper into the technical details. They will define specific test cases with inputs, expected outputs, and pass/fail criteria for individual functionalities, modules, or APIs.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/#description","title":"Description","text":"<p>This repository contains the Unit Test Suites(L1 &amp; L2) for RMF Audio Capture <code>HAL</code>.</p>"},{"location":"external_content/rmf_audio_capture_test/#reference-documents","title":"Reference Documents","text":"SNo Document Name Document Description Document Link 1 <code>HAL</code> Specification Document This document provides specific information on the APIs for which tests are written in this module rmf-audio-capture_halSpec.md 2 High Level Test Specification Document High Level Test Specification Documentation this module rmf-audio-capture_High-Level_TestSpec.md 3 <code>L2</code> Low Level Test Specification Document <code>L2</code>Low Level Test Specification Documentation this module rmf-audio-capture_L2-Low-Level_TestSpecification.md 4 <code>L3</code> Low Level Test Specification Document <code>L3</code>Low Level Test Specification Documentation this module rmf-audio-capture_L3_Low-Level_TestSpecification.md 5 <code>L3</code> Low Level Test Procedure Document <code>L3</code>Low Level Test Procedure Documentation this module rmf-audio-capture_L3_TestProcedure.md"},{"location":"external_content/rmf_audio_capture_test/#notes","title":"Notes","text":"<ul> <li>All APIs need to be implemented in this current version. If any API is not supported, please add stub implementation with return type RMF_SUCCESS for the same.</li> <li>Building against the actual library may introduce SOC dependencies. Hence, a template SKELETON library is created without SOC dependencies. On the real platform (target), it can be mounted, copied and bound with the actual library.</li> <li>When executing the binary, ensure to include a platform-specific profile file as an argument for the designated test cases. The following example illustrates this:</li> </ul> <p><code>bash  ./hal_test -p rmfAudioCaptureAuxSupported.yaml</code></p> <p>Alternatively, use the run.sh script with the profile file:</p> <p><code>bash ./run.sh -p /absolute/path/to/profile/file</code></p> <ul> <li>Profile files define the configuration for the platform available here at aux supported and  aux not supported</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/#setting-python-environment-for-running-the-l1-l2-and-l3-automation-test-cases","title":"Setting Python environment for running the <code>L1</code> <code>L2</code> and <code>L3</code> automation test cases","text":"<ul> <li>For running the <code>L1</code> <code>L2</code> and <code>L3</code> test suite, a host PC or server with a Python environment is required.</li> <li>Install Python Environment and Activation Scripts as detailed in the HPK Documentation</li> <li>To run the <code>L1</code> <code>L2</code> test cases follow the rmf-audio-capture_L1_L2_TestProcedure.md</li> <li>To run the <code>L3</code> test cases follow the rmf-audio-capture_L3_TestProcedure.md</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#140","title":"1.4.0","text":"<ul> <li>gh #23 L3 tests python implementation <code>#24</code></li> <li>gh #20 L3 C- tests implementation <code>#21</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#131","title":"1.3.1","text":"<p>13 August 2024</p> <ul> <li>gh #18 Update run.sh script &amp; README.md <code>#19</code></li> <li>Bumped CHANGELOG.md - 1.3.1 <code>7fdfe70</code></li> <li>Merge tag '1.3.0' into develop <code>23980f5</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#130","title":"1.3.0","text":"<p>9 August 2024</p> <ul> <li>gh #16 build error update <code>#17</code></li> <li>gh #14 L1 code clean up <code>#15</code></li> <li>gh# 9 L1 test profile improvement <code>#13</code></li> <li>gh #11 l2 interface update <code>#12</code></li> <li>gh #14 code cleanup <code>0c0f0aa</code></li> <li>gh #108 addressed comments <code>45bfde3</code></li> <li>gh #14 updated changes <code>24a0b07</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#120","title":"1.2.0","text":"<p>17 July 2024</p> <ul> <li>gh #3 High level, Low level Spec &amp; L2 code <code>#4</code></li> <li>gh #3 RDK-51420: Updated L2 test spec and implementation <code>f4b9ae8</code></li> <li>gh #3 Added image and Updated comments <code>467d0ca</code></li> <li>gh #3 removed unnecessary docs &amp; updated readme <code>65fc3c5</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#110","title":"1.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #7 rmf_audio: enhanced error code Macro implementation <code>#8</code></li> <li>gh #7 adress review comment <code>ba738bf</code></li> <li>update for adding the MACRO for enhance code <code>f5b3312</code></li> <li>gh #7 update to fix review comments <code>ddeff81</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#104","title":"1.0.4","text":"<p>20 February 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.0.4 <code>da66ce8</code></li> <li>Updated tag version in README.md <code>9c5bd19</code></li> <li>Merge tag '1.0.3' into develop <code>d13bed1</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#103","title":"1.0.3","text":"<p>29 January 2024</p> <ul> <li>gh #1 updated ut version 2 in build.sh and change UT_ASSERT_EQUAL_NOT_FATAL to UT_ASSERT_EQUAL <code>03bf24b</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>74e3ad4</code></li> <li>Merge tag '1.0.2' into develop <code>7def399</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#102","title":"1.0.2","text":"<p>12 December 2023</p> <ul> <li>Bumped CHANGELOG.md - 1.0.2 <code>4391f0f</code></li> <li>Updated README.md with hal &amp; haltest supported version <code>b0f5bea</code></li> <li>Merge tag '1.0.1' into develop <code>f3d6dc5</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CHANGELOG/#101","title":"1.0.1","text":"<p>29 November 2023</p> <ul> <li>baseline version <code>c263cc7</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>3a473f1</code></li> <li>Removed L2 template documents' references <code>8f0a404</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/","title":"RMF Audio Capture High Level Test Specification Documentation","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Test Scenarios</li> <li>Check primary audio capture</li> <li>Check auxiliary audio capture</li> <li>Check concurrent audio capture</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code> - Unit Test(s)</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>API</code> - Application Programming Interface</li> <li><code>L2</code> - Level2 Testing</li> <li><code>L3</code> - Level3 Testing</li> <li><code>NA</code> - Not Applicable</li> <li><code>Y</code> - Yes</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#introduction","title":"Introduction","text":"<p>This document provides an overview of the testing requirements for the RMF audio capture module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <ul> <li><code>HAL</code> specification is available here: rmf-audio-capture_halSpec.md</li> <li><code>HAL</code> interface is available here: rmfAudioCapture header</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#test-scenarios","title":"Test Scenarios","text":"# Test Functionality Description 1 Check primary audio capture Run a capture of primary audio for a while and verify delivery of data 2 Check auxiliary audio capture Run a capture of auxiliary audio (on supported devices only) for a while and verify delivery of data 3 Check concurrent audio capture Run parallel captures of primary and auxiliary audio (on supported devices only) and verify delivery of data"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#check-primary-audio-capture","title":"Check primary audio capture","text":"Description HAL APIs L2 L3 Control plane requirements Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run primary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#test-startup-requirement-check-primary-audio-capture","title":"Test Startup Requirement - Check primary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 tests.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#emulator-requirements-check-primary-audio-capture","title":"Emulator Requirements - Check primary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#control-plane-requirements-check-primary-audio-capture","title":"Control Plane Requirements - Check primary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#check-auxiliary-audio-capture","title":"Check auxiliary audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run auxiliary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error.Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#test-startup-requirement-check-auxiliary-audio-capture","title":"Test Startup Requirement - Check auxiliary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have auxiliary audio track.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#emulator-requirements-check-auxiliary-audio-capture","title":"Emulator Requirements - Check auxiliary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#control-plane-requirements-check-auxiliary-audio-capture","title":"Control Plane Requirements - Check auxiliary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#check-concurrent-audio-capture","title":"Check concurrent audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples.  Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Open primary and auxiliary capture interfaces, then issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code> Run auxiliary+primary audio capture for 10 seconds with known source material and verify that captured audio clips are faithful to the source within margin of error. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary+primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#test-startup-requirement-check-concurrent-audio-capture","title":"Test Startup Requirement - Check concurrent audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have primary as well as auxiliary audio tracks.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#emulator-requirements-check-concurrent-audio-capture","title":"Emulator Requirements - Check concurrent audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver two distinct 10-second audio clips (from wav or raw PCM file) to each capture interface when triggered by control plane. It must be able to drive primary and auxiliary captures concurrently.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/#control-plane-requirements-check-concurrent-audio-capture","title":"Control Plane Requirements - Check concurrent audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#140","title":"1.4.0","text":"<ul> <li>gh #23 L3 tests python implementation <code>#24</code></li> <li>gh #20 L3 C- tests implementation <code>#21</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#131","title":"1.3.1","text":"<p>13 August 2024</p> <ul> <li>gh #18 Update run.sh script &amp; README.md <code>#19</code></li> <li>Bumped CHANGELOG.md - 1.3.1 <code>7fdfe70</code></li> <li>Merge tag '1.3.0' into develop <code>23980f5</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#130","title":"1.3.0","text":"<p>9 August 2024</p> <ul> <li>gh #16 build error update <code>#17</code></li> <li>gh #14 L1 code clean up <code>#15</code></li> <li>gh# 9 L1 test profile improvement <code>#13</code></li> <li>gh #11 l2 interface update <code>#12</code></li> <li>gh #14 code cleanup <code>0c0f0aa</code></li> <li>gh #108 addressed comments <code>45bfde3</code></li> <li>gh #14 updated changes <code>24a0b07</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#120","title":"1.2.0","text":"<p>17 July 2024</p> <ul> <li>gh #3 High level, Low level Spec &amp; L2 code <code>#4</code></li> <li>gh #3 RDK-51420: Updated L2 test spec and implementation <code>f4b9ae8</code></li> <li>gh #3 Added image and Updated comments <code>467d0ca</code></li> <li>gh #3 removed unnecessary docs &amp; updated readme <code>65fc3c5</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#110","title":"1.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #7 rmf_audio: enhanced error code Macro implementation <code>#8</code></li> <li>gh #7 adress review comment <code>ba738bf</code></li> <li>update for adding the MACRO for enhance code <code>f5b3312</code></li> <li>gh #7 update to fix review comments <code>ddeff81</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#104","title":"1.0.4","text":"<p>20 February 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.0.4 <code>da66ce8</code></li> <li>Updated tag version in README.md <code>9c5bd19</code></li> <li>Merge tag '1.0.3' into develop <code>d13bed1</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#103","title":"1.0.3","text":"<p>29 January 2024</p> <ul> <li>gh #1 updated ut version 2 in build.sh and change UT_ASSERT_EQUAL_NOT_FATAL to UT_ASSERT_EQUAL <code>03bf24b</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>74e3ad4</code></li> <li>Merge tag '1.0.2' into develop <code>7def399</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#102","title":"1.0.2","text":"<p>12 December 2023</p> <ul> <li>Bumped CHANGELOG.md - 1.0.2 <code>4391f0f</code></li> <li>Updated README.md with hal &amp; haltest supported version <code>b0f5bea</code></li> <li>Merge tag '1.0.1' into develop <code>f3d6dc5</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CHANGELOG/#101","title":"1.0.1","text":"<p>29 November 2023</p> <ul> <li>baseline version <code>c263cc7</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>3a473f1</code></li> <li>Removed L2 template documents' references <code>8f0a404</code></li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/LICENSE/","title":"LICENSE","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/NOTICE/","title":"NOTICE","text":"<p>This component contains software that is Copyright (c) 2023 RDK Management.</p> <p>The component is licensed to you under the Apache License, Version 2.0 (the \"License\"). You may not use the component except in compliance with the License.</p> <p>The component may include material which is licensed under other licenses / copyrights as listed below.  Your use of this material within the component is also subject to the terms and conditions of these licenses.  The LICENSE file contains the text of all the licenses which apply within this component.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/","title":"RMF Audio Capture High Level Test Specification Documentation","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Test Scenarios</li> <li>Check primary audio capture</li> <li>Check auxiliary audio capture</li> <li>Check concurrent audio capture</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code> - Unit Test(s)</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>API</code> - Application Programming Interface</li> <li><code>L2</code> - Level2 Testing</li> <li><code>L3</code> - Level3 Testing</li> <li><code>NA</code> - Not Applicable</li> <li><code>Y</code> - Yes</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the testing requirements for the RMF audio capture module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <ul> <li><code>HAL</code> specification is available here: rmf-audio-capture_halSpec.md</li> <li><code>HAL</code> interface is available here: rmfAudioCapture header</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-scenarios","title":"Test Scenarios","text":"# Test Functionality Description 1 Check primary audio capture Run a capture of primary audio for a while and verify delivery of data 2 Check auxiliary audio capture Run a capture of auxiliary audio (on supported devices only) for a while and verify delivery of data 3 Check concurrent audio capture Run parallel captures of primary and auxiliary audio (on supported devices only) and verify delivery of data"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#check-primary-audio-capture","title":"Check primary audio capture","text":"Description HAL APIs L2 L3 Control plane requirements Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run primary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-primary-audio-capture","title":"Test Startup Requirement - Check primary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 tests.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-primary-audio-capture","title":"Emulator Requirements - Check primary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-primary-audio-capture","title":"Control Plane Requirements - Check primary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#check-auxiliary-audio-capture","title":"Check auxiliary audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run auxiliary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error.Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-auxiliary-audio-capture","title":"Test Startup Requirement - Check auxiliary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have auxiliary audio track.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-auxiliary-audio-capture","title":"Emulator Requirements - Check auxiliary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-auxiliary-audio-capture","title":"Control Plane Requirements - Check auxiliary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#check-concurrent-audio-capture","title":"Check concurrent audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples.  Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Open primary and auxiliary capture interfaces, then issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code> Run auxiliary+primary audio capture for 10 seconds with known source material and verify that captured audio clips are faithful to the source within margin of error. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary+primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-concurrent-audio-capture","title":"Test Startup Requirement - Check concurrent audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have primary as well as auxiliary audio tracks.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-concurrent-audio-capture","title":"Emulator Requirements - Check concurrent audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver two distinct 10-second audio clips (from wav or raw PCM file) to each capture interface when triggered by control plane. It must be able to drive primary and auxiliary captures concurrently.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-concurrent-audio-capture","title":"Control Plane Requirements - Check concurrent audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/","title":"RMF AUDIO CAPTURE L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the level 2 testing suite for the RMF AUDIO CAPTURE module.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - rmf-audio-capture_High-Level_TestSpec.md</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_primary_data_check</code> Description Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns Test Group Module : 02 Test Case ID 1 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open()</code> to open interface handle = valid pointer RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings returns RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture settings=default settings from previous step, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, status callback NULL RMF_SUCCESS Should be successful 04 Capture audio for 10 seconds sleep(10) N/A N/A 05 Call <code>RMF_AudioCapture_Stop</code> with handle and set cookie variable to 0 immediately afterwards handle = valid pointer RMF_SUCCESS Should be successful 06 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variable remains 0 N/A cookie=0 Should be successful 07 Call <code>RMF_AudioCapture_Close()</code> to release resources current handle RMF_SUCCESS Should be successful 08 Compare actual total bytes logged by data callback with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_GetDefaultSettings]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|Failure| B1[Test case fail]\n    B --&gt;|RMF_SUCCESS| B2[Call RMF_AudioCapture_Start with settings]\n    B2 --&gt; |Failure| B3[Test case fail]\n    B2 --&gt;|RMF_SUCCESS| C[Wait 10 seconds]\n    C --&gt; D[Call RMF_AudioCapture_Stop, set cookie = 0]\n    D --&gt; DCW{Wait for 1 second. &lt;br&gt; Is cookie = 0?}\n    DCW --&gt; |No| DCF[Test case fail]\n    DCW --&gt; |Yes|E[call RMF_AudioCapture_Close]\n    E --&gt; |Failure| E1[Test case fail]\n    E --&gt;|RMF_SUCCESS| F{Total captured data &lt;br&gt; size comparable to &lt;br&gt; estimated total?}\n    F --&gt;|Yes| G[Test case success]\n    F --&gt;|No| F1[Test case fail]</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_auxiliary_data_check</code> Description Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns Test Group Module : 02 Test Case ID 002 Priority High <p>Pre-Conditions : Device must support auxiliary audio capture.</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer, type=auxiliary RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings returns RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture settings=default settings from previous step, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, status callback NULL RMF_SUCCESS Should be successful 04 Capture audio for 10 seconds sleep(10) N/A N/A 05 Call <code>RMF_AudioCapture_Stop</code> with handle and set cookie variable to 0 immediately afterwards handle = valid pointer RMF_SUCCESS Should be successful 06 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variable remains 0 N/A cookie=0 Should be successful 07 Call <code>RMF_AudioCapture_Close()</code> to release resources current handle RMF_SUCCESS Should be successful 08 Compare actual total bytes logged by data callback with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open_Type] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_GetDefaultSettings]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|Failure| B1[Test case fail]\n    B --&gt;|RMF_SUCCESS| B2[Call RMF_AudioCapture_Start with settings]\n    B2 --&gt; |Failure| B3[Test case fail]\n    B2 --&gt;|RMF_SUCCESS| C[Wait 10 seconds]\n    C --&gt; D[Call RMF_AudioCapture_Stop, set cookie = 0]\n    D --&gt; DCW{Wait for 1 second. &lt;br&gt; Is cookie = 0?}\n    DCW --&gt; |No| DCF[Test case fail]\n    DCW --&gt; |Yes|E[call RMF_AudioCapture_Close]\n    E --&gt; |Failure| E1[Test case fail]\n    E --&gt;|RMF_SUCCESS| F{Total captured data &lt;br&gt; size comparable to &lt;br&gt; estimated total?}\n    F --&gt;|Yes| G[Test case success]\n    F --&gt;|No| F1[Test case fail]</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_combined_data_check</code> Description Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Test Group Module : 02 Test Case ID 003 Priority High <p>Pre-Conditions : Device must support auxiliary audio capture.</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer; type = \"auxiliary\" RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer; type = \"primary\" RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings pointer returns RMF_SUCCESS Should be successful 04 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture handle = primary handle, settings initalized to default settings, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, cbBufferReadyParm = pointer to primary capture context with byte counter and cookie, status callback NULL RMF_SUCCESS Should be successful 05 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture handle = auxiliary handle, settings initalized to default settings, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, cbBufferReadyParm = pointer to auxiliary capture context with byte counter and cookie, status callback NULL RMF_SUCCESS Should be successful 06 Capture audio for 10 seconds sleep(10) N/A Should be successful 07 Call <code>RMF_AudioCapture_Stop</code> with primary handle and set primary context cookie variable to 0 immediately afterwards handle = primary RMF_SUCCESS Should be successful 08 Call <code>RMF_AudioCapture_Stop</code> with auxiliary handle and set auxiliary context cookie variable to 0 immediately afterwards handle = auxiliary RMF_SUCCESS Should be successful 09 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variables for both primary and auxiliary contexts remain 0 N/A primary and auxiliary cookies = 0 Should be successful 10 Call <code>RMF_AudioCapture_Close()</code> to release resources current primary handle RMF_SUCCESS Should be successful 11 Call <code>RMF_AudioCapture_Close()</code> to release resources current auxiliary handle RMF_SUCCESS Should be successful 12 Compare actual total bytes logged by data callbacks for both primary and auxiliary contexts with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open_Type &lt;br&gt; for primary] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_Open_Type &lt;br&gt; for auxillary]\n    A --&gt;|Fail| A_Fail[Test case fail]\n    B --&gt;|RMF_SUCCESS| C[Call RMF_AudioCapture_GetDefaultSettings]\n    B --&gt;|Fail| B_Fail[Test case fail]\n    C --&gt;|RMF_SUCCESS| D[Modify settings,&lt;br&gt; set cbBufferReady and cbBufferReadyParm for &lt;br&gt; both primary and secondary]\n    C --&gt;|Fail| C_Fail[Test case fail]\n    D --&gt; E[Call RMF_AudioCapture_Start &lt;br&gt; with primary handle]\n    E --&gt;|RMF_SUCCESS| F[Call RMF_AudioCapture_Start &lt;br&gt; with auxiliary handle]\n    E --&gt;|Fail| E_Fail[Test case fail]\n    F --&gt;|RMF_SUCCESS| G[Capture audio for 10 seconds]\n    F --&gt;|Fail| F_Fail[Test case fail]\n    G --&gt; I[Call RMF_AudioCapture_Stop &lt;br&gt; for primary handle, &lt;br&gt; set cookie = 0]\n    I --&gt;|RMF_SUCCESS| J[Call RMF_AudioCapture_Stop &lt;br&gt; for auxiliary handle, &lt;br&gt; set cookie = 0]\n    I --&gt;|Fail| I_Fail[Test case fail]\n    J --&gt;|RMF_SUCCESS| K[Wait 1 second, &lt;br&gt; verify that cookies = 0]\n    J --&gt;|Fail| J_Fail[Test case fail]\n    K --&gt; |cookies = 0|L[Call RMF_AudioCapture_Close &lt;br&gt; for primary handle]\n    K --&gt; |cookies = 1| K_FAIL[Test case fail]\n    L --&gt;|RMF_SUCCESS| M[Call RMF_AudioCapture_Close &lt;br&gt; for auxiliary handle]\n    L --&gt;|Fail| L_Fail[Test case fail]\n    M --&gt;|Fail| M_Fail[Test case fail]\n    M --&gt;|RMF_SUCCESS| N{Total captured data\\nsize comparable to\\nestimated total for\\nprimary and auxiliary?}\n    N --&gt;|Yes| N1[Test case success]\n    N --&gt;|No| N2[Test case fail]</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/","title":"RMF Audio Capture L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>References</li> <li>Audio Streams Requirement</li> <li>Level 3 Test Procedure</li> <li>Level 3 Python Test</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>NA</code>     - Not Applicable</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Test Procedure for the RMF Audio Capture module.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li>RMF audio capture HAL Interface - rmfAudioCapture.h</li> <li>High Level Test Specification - rmf-audio-capture_High-Level_TestSpec.md</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#audio-streams-requirement","title":"Audio Streams Requirement","text":"# Stream Name Description 01 Sin_120s_48k_stereo.wav 120 seconds sin wave generated at 48kz, stereo file 02 Triangle_10s_480k_stereo.wav 10 seconds triangle wave generated at 48kz, stereo file"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Below are top test use-case for the RMF audio capture.</p> # Test-case Description HAL APIs Streams Number 1 Primary data capture Play a reference stream, run primary audio capture, verify that captured audio is faithful to the source within margin of error <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 1 2 Primary jitter test Play a reference stream, run primary audio capture, monitor jitter regularly <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 1 3 Independent data check Play reference streams simultaneously for primary and auxiliary captures, issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 1,2 4 Auxiliary data capture Play a reference stream, run auxiliary audio capture, verify that captured audio is faithful to the source within margin of error <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 2 5 Combined data capture Play reference streams simultaneously for primary and auxiliary captures, run primary and auxiliary audio captures, verify that captured audio is faithful to the source within margin of error <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 1,2 6 Auxiliary jitter test Play a reference stream, run auxiliary audio capture, monitor jitter regularly <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 2 7 Combined jitter test Play reference streams simultaneously for primary and auxiliary captures, run primary and auxiliary audio captures, monitor jitter regularly <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> 1,2"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of rmfAudio L3 Python test cases:</p> <pre><code>---\ntitle: rmfAudio - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- rmfAudioHelperClass : inherits\n    rmfAudioHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; rmfAudio : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for rmfAudio \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>rmfAudio</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file rmfAudioCaptureAuxSupported</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file rmfAudio_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file rmfAudio_testConfig.yml</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/","title":"RMF Audio Capture HAL L3 Python Test Procedure","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Streams Required</li> <li>Test Cases<ul> <li>rmfAudio_test01_primaryDataCapture.py</li> <li>rmfAudio_test02_primaryJitterTest.py</li> <li>rmfAudio_test03_independentDataCheck.py</li> <li>rmfAudio_test04_auxiliaryDataCapture.py</li> <li>rmfAudio_test05_combinedDataCapture.py</li> <li>rmfAudio_test06_auxiliaryJitterTest.py</li> <li>rmfAudio_test07_combinedJitterTest.py</li> <li>rmfAudio_L3_Runall.py</li> <li>rmfAudio_L3_Runall_primary.py</li> </ul> </li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_player Plays the stream required for test case ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file: - Set the folder path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Update <code>streams_download_url</code> with the URL from which the streams will be downloaded - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../profiles/rmfAudioCaptureAuxSupported.yaml\"\n            streams_download_url: \"&lt;URL_Path&gt;\" #URL path from which the streams are downloaded to the device\n</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: rmfAudio_L3_testSetup.yml</p> <p>Provide the streams for each test case. This path is appended with <code>streams_download_url</code> entry from Device Configuration File</p> <p>If a test case requires multiple streams or needs to be validated using several streams, ensure that all necessary streams are added sequentially for that specific test case.</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture test setup\"\n  assets:\n    device:\n      test01_primaryDataCapture:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_120s_48k_stereo.wav\"\n        streams:\n          - \"streams/Sin_120s_48k_stereo.wav\"\n      test02_primaryJitterTest:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_120s_48k_stereo.wav\"\n        streams:\n          - \"streams/Sin_120s_48k_stereo.wav\"\n      test03_independentDataCheck:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_10s_48k_stereo.wav\"\n          - \"export INPUT_AUXILIARY=&lt;PATH on Device&gt;/Triangle_10s_480k_stereo.wav\"\n        streams:\n          - \"streams/Sin_10s_48k_stereo.wav\"\n          - \"streams/Triangle_10s_480k_stereo.wav\"\n      test04_auxiliaryDataCapture:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_AUXILIARY=&lt;PATH on Device&gt;/Triangle_10s_480k_stereo.wav\"\n        streams: \n          - \"streams/Triangle_10s_480k_stereo.wav\"\n</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: rmfAudio_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p> <pre><code>rmfaudiocapture:\n    description: \"RMF Audio Capture testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#streams-required","title":"Streams Required","text":"<p>Refer rmf-audio-capture_L3_Low-Level_TestSpecification.md for the stream details</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test01_primarydatacapturepy","title":"rmfAudio_test01_primaryDataCapture.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Play Stream #1 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test plays a reference stream, captures audio data on primary capture interface and verifies that the captured data matches with reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on primary capture interface and written to a wav output file.</li> <li>Captured audio should match with played reference stream.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test01_primaryDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary capture interface data Verification:</p> <p>The test will play the designated audio stream and start audio capture on primary capture interface.</p> </li> <li> <p>The test will validate captured audio data with reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data through primary capture interface, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test02_primaryjittertestpy","title":"rmfAudio_test02_primaryJitterTest.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<p>Play Stream #1 and confirm that there is no jitter detected on primary capture interface.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test plays a reference stream, checks bytes of audio data received on primary capture interface and verifies there is no jitter detected on primary capture interface.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test02_primaryJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary capture jitter Verification:</p> <p>The test will play the designated audio stream and start monitoring bytes received on primary capture interface.</p> </li> <li> <p>The test will monitor bytes received on primary audio capture continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on primary data interface, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test03_independentdatacheckpy","title":"rmfAudio_test03_independentDataCheck.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Play Stream #1 and Stream #2 and verify that primary and auxiliary data captures work independent of each other.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test03","title":"Expected Results - test03","text":"<p>The test plays a reference stream each on primary and auxiliary interfaces, then issues a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test03_independentDataCheck.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Independent data check Verification:</p> <p>The test will play the designated audio stream on both primary and auxiliary interfaces and start monitoring bytes received before and after each start and stop call.</p> </li> <li> <p>The test will check bytes received on primary and auxiliary audio capture during series of start and stop calls in a mixed sequence. </p> </li> <li>If bytes captured shows that the captures are independent of each other, the step is marked as PASS.</li> <li> <p>If bytes captured shows that the captures are dependent on each other, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream each on primary and auxiliary interfaces, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured shows that the captures are independent of each other</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test04_auxiliarydatacapturepy","title":"rmfAudio_test04_auxiliaryDataCapture.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>Play Stream #2 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>The test plays a reference stream, captures audio data on auxiliary capture interface and verifies that the captured data matches with reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on auxiliary capture interface and written to a wav output file.</li> <li>Captured audio should match with played reference stream.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test04_auxiliaryDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Auxiliary capture interface data Verification:</p> <p>The test will play the designated audio stream and start audio capture on auxiliary capture interface.</p> </li> <li> <p>The test will validate captured audio data with reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data through auxiliary capture interface, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test05_combineddatacapturepy","title":"rmfAudio_test05_combinedDataCapture.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test05","title":"User Input Required - test05","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<p>Play Stream #1 and Stream #2 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test05","title":"Expected Results - test05","text":"<p>The test plays a reference stream, captures audio data on both primary and auxiliary capture interfaces and verifies that the captured data matches with corresponding reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on primary and auxiliary capture interfaces simulataneously and written to a wav output file.</li> <li>Captured audio should match with corresponding played reference stream.</li> </ul>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test05_combinedDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Combined audio capture data Verification:</p> <p>The test will play the designated audio streams and start audio capture simulataneously on primary and auxiliary capture interfaces.</p> </li> <li> <p>The test will validate captured audio data with corresponding reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data simultaneously through primary and auxiliary capture interfaces, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test06_auxiliaryjittertestpy","title":"rmfAudio_test06_auxiliaryJitterTest.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test06","title":"User Input Required - test06","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test06","title":"Acceptance Criteria - test06","text":"<p>Play Stream #2 and confirm that there is no jitter detected on auxiliary capture interface.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test06","title":"Expected Results - test06","text":"<p>The test plays a reference stream, checks bytes of audio data received on auxiliary capture interface and verifies there is no jitter detected on auxiliary capture interface.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test06","title":"Test Steps - test06","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test06_auxiliaryJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Auxiliary capture jitter Verification:</p> <p>The test will play the designated audio stream and start monitoring bytes received on auxiliary capture interface.</p> </li> <li> <p>The test will monitor bytes received on auxiliary capture continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on auxiliary capture interface, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test07_combinedjittertestpy","title":"rmfAudio_test07_combinedJitterTest.py","text":""},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test07","title":"User Input Required - test07","text":"<p>No</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test07","title":"Acceptance Criteria - test07","text":"<p>Play Stream #1 and Stream #2 and confirm that there is no jitter detected on primary and auxiliary capture interfaces.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test07","title":"Expected Results - test07","text":"<p>The test plays a reference stream, checks bytes of audio data received simulataneously on primary and auxiliary capture interface and verifies there is no jitter detected on both audio capture interfaces.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test07","title":"Test Steps - test07","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test07_combinedJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary and auxiliary combined capture jitter Verification:</p> <p>The test will play the designated audio streams and start monitoring bytes received on primary and auxiliary capture interfaces.</p> </li> <li> <p>The test will monitor bytes received on primary and auxiliary audio captures continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on primary and auxiliary capture interfaces, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_l3_runallpy","title":"rmfAudio_L3_Runall.py","text":"<p>This python file runs all the tests</p> <pre><code>python rmfAudio_L3_Runall.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_l3_runall_primarypy","title":"rmfAudio_L3_Runall_primary.py","text":"<p>This python file runs all the tests for primary audio capture</p> <pre><code>python rmfAudio_L3_Runall_primary.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"external_content/tvsettings/","title":"TV Settings HAL Documentation","text":""},{"location":"external_content/tvsettings/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup<ul> <li>Table Format </li> </ul> </li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/tvsettings/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>CPU</code> - Central Processing Unit</li> <li><code>HAL</code> - Hardware Abstraction layer</li> <li><code>PQ</code>  - Picture Quality</li> <li><code>SOC</code> - System on chip</li> <li><code>OEM</code> - Original Equipment Manufacturer</li> <li><code>ALS</code> - Auto Light Sensor</li> <li><code>API</code> - Application Programming Interface</li> <li><code>DV</code>  - Dolby Vision</li> <li><code>CMS</code> - Colorspace Management System</li> <li><code>TMAX</code>- Temperature MAX</li> <li><code>SRD</code> - Standard Dynamic Range</li> <li><code>HDR</code> - High Dynamic Range</li> <li><code>HLG</code> - Hybrid Log Gamma</li> <li><code>UHD</code> - Ultra High Definition</li> <li><code>LDIM</code>- Local Dimming</li> </ul>"},{"location":"external_content/tvsettings/#description","title":"Description","text":"<p>TV Settings <code>HAL</code> is an interface which provides <code>APIs</code> to modify/control the picture quality parameters, dimming modes and auto backlight modes.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\nCaller &lt;--&gt; x[TV Setting HAL] \nx[TV Setting HAL] &lt;--&gt; y[Video/Picture Quality Driver]\nstyle Caller fill:#99CCFF,stroke:#333,stroke-width:0.3px\nstyle y fill:#fc9,stroke:#333,stroke-width:0.3px\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px</code></pre>"},{"location":"external_content/tvsettings/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":""},{"location":"external_content/tvsettings/#initialization-and-startup","title":"Initialization and Startup","text":"<p>The caller must initialize the <code>APIs</code> with picture quality modes for specific platforms and initiates communication with picture quality drivers. The standard/default values shall be maintained in default Picture profile database and any modified values for these parameters using TV Settings HAL APIs will be maintained in override Picture profile database. HAL shall be responsible to store these Picture profile data into the database. Picture profile database will have 5 types of tables: 1. Picture property table to maintain all picture properties for a given picture mode, video format and video source 2. Picture mode association table maintain the association of a given video source and video format to a picture mode 3. If input source, picture mode, and video format are not already set or specified, they will default to \"IP source,\" \"Entertainment,\" and \"SDR,\" respectively. However, if the caller attempts to change parameters that rely on these values, they will be acted upon default values accordingly. 4. White balance table for every color temperature and video source to maintain WB calibrated values 5. Gamma table for every color temperature to maintain the gamma calibrated values. 6. TMAX table for every local dimming level to maintain the TMAX value</p> <ul> <li>The capabilities of a specific platform with respect to TV picture configuration will be defined in a config file (pq_capabilities.ini which decides supported formats, picture modes, dimming modes, dvModes, resolution etc.</li> <li>Caller must initialize by calling <code>tvInit()</code> which must initialize the parameters in default picture property database. These parameters are decided by Soc vendor  based on platform capability.</li> <li>On every bootup the default picture profile database will be copied to override picture profile database.</li> </ul>"},{"location":"external_content/tvsettings/#table-format","title":"Table Format","text":""},{"location":"external_content/tvsettings/#picture-property-table","title":"Picture Property Table","text":"Video Source Video Format Picture Mode Picture Property HDMI1 SDR Standard/Entertainment Brightness Contrast Sharpness Saturation Hue Backlight Dolbymode AspectRatio Colortemperature Dimming Mode Local Dimming Low Latency CMS State CMS Saturation RED CMS Saturation BLUE CMS Saturation GREEN CMS Saturation YELLOW CMS Saturation CYAN CMS Saturation MAGENTA CMS Hue RED CMS Hue BLUE CMS Hue GREEN CMS Hue YELLOW CMS Hue CYAN CMS Hue MAGENTA CMS Luma RED CMS Luma BLUE CMS Luma GREEN CMS Luma YELLOW CMS Luma CYAN CMS Luma MAGENTA Theater/Movie Repeat as standard FilmMaker Repeat as standard Sports Repeat as standard Game Repeat as standard Custom/Expert Repeat as standard EnergySaving Repeat as standard Vivid Repeat as standard Graphics Repeat as standard HDR10 Repeat as SDR HLG Repeat as SDR DV Repeat as SDR HDMI2 Repeat as HDMI1 HDMI3 Repeat as HDMI1 Tunner Repeat as HDMI1 IP Repeat as HDMI1 Composite Repeat as HDMI1 <p>Note: Currently Dolby mode is treated as a picture property and not a picture mode. In future Dolby mode might be treated as picture mode. Values of index in pq_capabilites.ini are mapped to enum values in tvTypes.h</p>"},{"location":"external_content/tvsettings/#picture-association-table","title":"Picture Association Table","text":"Video Source Video Format Picture Mode HDMI1 SDR Standard/Entertainment Theater/Movie FilmMaker Sports Game Custom/Expert EnergySaving Vivid Graphics HDR10 Repeat as SDR HLG Repeat as SDR DV Repeat as SDR HDMI2 Repeat as HDMI1 HDMI3 Repeat as HDMI1 Tunner Repeat as HDMI1 IP Repeat as HDMI1 Composite Repeat as HDMI1"},{"location":"external_content/tvsettings/#wb-table","title":"WB Table","text":"Video Source White Balance Property Value Range HDMI1 Cold White Balance Table Red Gain 0-2047 Green Gain 0-2047 Blue Gain 0-2047 Red offset (-1024) to (+1023) Green offset (-1024) to (+1023) Blue offset (-1024) to (+1023) Warm White Balance Table Repeat as Cold White Balance Table Normal White Balance Table Repeat as Cold White Balance Table User White Balance Table Repeat as Cold White Balance Table Boost cold White Balance Table Repeat as Cold White Balance Table Bost warm White Balance Table Repeat as Cold White Balance Table Boost normal White Balance Table Repeat as Cold White Balance Table Boost user White Balance Table Repeat as Cold White Balance Table HDMI2 Repeat as HDMI1 HDMI3 Repeat as HDMI1 Tunner Repeat as HDMI1 IP Repeat as HDMI1 Composite Repeat as HDMI1"},{"location":"external_content/tvsettings/#gamma-table","title":"Gamma Table","text":"Gamma Index Property Value Range Cold Gamma Table 0 Red Gain 0-1023 Green Gain 0-1023 Blue Gain 0-1023 1 Repeat as 0 2 Repeat as 0 . 254 Repeat as 0 255 Repeat as 0 Warm Gamma Table Repeat as Cold Gamma Table Normal Gamma Table Repeat as Cold Gamma Table User Gamma Table Repeat as Cold Gamma Table Boorst cold Gamma Table Repeat as Cold Gamma Table Boost warm Gamma Table Repeat as Cold Gamma Table Boost normal Gamma Table Repeat as Cold Gamma Table Boost user Gamma Table Repeat as Cold Gamma Table"},{"location":"external_content/tvsettings/#tmax-table","title":"TMAX Table","text":"TMAX Value Range Non Boost 0 to 10000 Boost 0 to 10000 Burst 0 to 10000"},{"location":"external_content/tvsettings/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe.  There are no constraints on thread creation or signal handling. </p>"},{"location":"external_content/tvsettings/#process-model","title":"Process Model","text":"<p>This interface is expected to support a single instantiation with a single process.</p>"},{"location":"external_content/tvsettings/#memory-model","title":"Memory Model","text":"<p>The caller is responsible for allocating and cleaning up any memory used.</p>"},{"location":"external_content/tvsettings/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to participate in power management.</p>"},{"location":"external_content/tvsettings/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface requires callback notification registration for VideoFormatChange, VideoResolutionChange, VideoFrameRateChange, VideoContentChange. The caller must return the callback context as fast as possible and will not block.</p>"},{"location":"external_content/tvsettings/#blocking-calls","title":"Blocking calls","text":"<p>This interface is required to have no blocking calls.</p>"},{"location":"external_content/tvsettings/#internal-error-handling","title":"Internal Error Handling","text":"<p>All <code>APIs</code> must return error synchronously as return argument.</p>"},{"location":"external_content/tvsettings/#persistence-model","title":"Persistence Model","text":"<p>Each vendor needs to define their own config file which is expected to be stored in rootfs and this must be a readonly. Config file must contain the supported formats, picture modes, dimming modes, dvModes, resolution etc.</p>"},{"location":"external_content/tvsettings/#non-functional-requirements","title":"Non-functional requirements","text":"<p>Following non-functional requirement must be supported by the TV Settings <code>HAL</code> component:</p>"},{"location":"external_content/tvsettings/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"external_content/tvsettings/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required  to not cause excessive memory and <code>CPU</code> utilization.</p>"},{"location":"external_content/tvsettings/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings must be treated as errors.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Copyright validation is required to be performed, e.g.: <code>Black duck</code>, <code>FossID</code>.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/tvsettings/#licensing","title":"Licensing","text":"<p>This interface is expected to get released under the Apache License 2.0.</p>"},{"location":"external_content/tvsettings/#build-requirements","title":"Build Requirements","text":"<p>TV Settings <code>HAL</code> source code must build into a shared library and must be named as <code>libtvsettings-hal.so</code>.</p>"},{"location":"external_content/tvsettings/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by component architects.</p>"},{"location":"external_content/tvsettings/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>Product or platform specification requirements will be handled in vendor specific config file.</p>"},{"location":"external_content/tvsettings/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file(s).</p>"},{"location":"external_content/tvsettings/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>This interface handles various functionalities/requests related to Picture Quality settings :</p> <ul> <li>Brightness</li> <li>Contrast</li> <li>Hue</li> <li>Saturation</li> <li>White Balance</li> <li>Sharpness</li> <li>Color Temperature</li> <li>Backlight </li> <li>Aspect Ratio</li> <li>Dimming Modes</li> <li>Local Dimming Level</li> <li>Low Latency state</li> <li>Notify Video Format Change</li> <li>Notify Video Resolution Change</li> <li>Notify Video FrameRate Change</li> <li>Notify Video Content Change</li> </ul> <p>There are other platform specific Picture Quality settings that can be managed by this interface :</p> <ul> <li>CMS</li> <li>Dolby Vision</li> </ul>"},{"location":"external_content/tvsettings/#diagrams","title":"Diagrams","text":""},{"location":"external_content/tvsettings/#operational-call-diagram","title":"Operational Call Diagram","text":""},{"location":"external_content/tvsettings/#init-and-callback-sequence","title":"Init and Callback Sequence","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller-&gt;&gt;HAL:tvInit()\n    Note over HAL: Initialize the TV Setting HAL APIs\n    HAL-&gt;&gt;Driver: Allocates resources\n    Driver--&gt;&gt;HAL:return\n    HAL-&gt;&gt;DPPDB: tvSettings_GetDefaultPQParams() Read default picture profile properites\n    DPPDB--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Copy default picture profile properites\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL: SetTVPictureMode()\n    Note over HAL: Set the default picture mode entertainment\n    HAL-&gt;&gt;OPPDB: tvSettings_GetPQParams() Read associated picture properties\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload gamma and white balance if there is a colour temperature value change.\n    HAL-&gt;&gt;OPPDB: Read associated Gamma and White balance\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload TMAX if there is a LDIM level change\n    HAL-&gt;&gt;OPPDB: Read associated TMAX value\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Apply the new picture properties, gamma, TMAX and white balance if they have changed.\n    HAL-&gt;&gt;Driver: Apply new picture properties\n    Driver--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Update the Picture mode association table\n    Note over HAL: Associate new picture mode to current video format and current video source\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: RegisterCallBack\n    Note over HAL:RegisterCallBack for Format/Resolution/FrameRate/VideoContent Change\n    HAL--&gt;&gt;Caller:return\n\n    Driver--&gt;&gt;HAL:Notify on video format/framerate/resolution/videocontent/videosource change\n    Note over HAL: Reload associated Picture mode and all associated picture properties if there is video format and video source change.\n    Note over HAL: However video source change will not be notified to caller\n    HAL-&gt;&gt;OPPDB: Read associated picture mode\n    OPPDB--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Read associated picture properties\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload gamma and white balance if there is a colour temperature value change.\n    HAL-&gt;&gt;OPPDB: Read associated Gamma and White balance\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload TMAX if there is a LDIM level change\n    HAL-&gt;&gt;OPPDB: Read associated TMAX value\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Apply the new picture properties, gamma and white balance if they have changed.\n    HAL-&gt;&gt;Driver: Apply new picture properties\n    Driver--&gt;&gt;HAL: return\n    HAL--&gt;&gt;Caller:Notify on video format/framerate/resolution/content change</code></pre>"},{"location":"external_content/tvsettings/#setgetsave-picture-quality-parameter-sequence","title":"Set/Get/Save Picture Quality Parameter Sequence LEGEND: tvSettings_SetMethods:tvSettings_GetMethods:tvSettings_SaveMethods :RegisterCallback :","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods\n    Note over HAL: APIs to set the Picture Quality Parameters\n    HAL-&gt;&gt;Driver:Sets the PQ Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Saves the new PQ Parameter\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_GetMethods\n    Note over HAL: APIs to get the PQ Parameters\n    HAL-&gt;&gt;Driver:Gets the PQ Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_SaveMethods\n    Note over HAL: APIs to save the Picture Quality Parameters\n    HAL-&gt;&gt;OPPDB:Save the PQ Parameters\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_GetPQParam\n    Note over HAL: APIs to get PQ param from override Picture Profile Database\n    HAL-&gt;&gt;OPPDB:Get the PQ Parameters\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_GetDefaultPQParam\n    Note over HAL: APIs to get Default PQ param from default Picture Profile Database\n    HAL-&gt;&gt;DPPDB:Get the PQ Parameters\n    DPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre> <p>SetBrightness(), SetContrast(), SetSaturation(), SetHue(),SetSharpness(), SetColorTemperature(),SetBacklight(), etc..</p> <p>GetBrightness(), GetContrast(), GetSaturation(), GetHue(),GetSharpness(), GetColorTemperature(),GetBacklight(), GetPQParams(), GetDefaultPQParams() etc..</p> <p>SaveBrightness(), SaveContrast(), SaveSaturation(), SaveHue(),SaveSharpness(), SaveColorTemperature(),SaveBacklight(), etc..</p> <p>RegisterVideoFormatChangeCB(),RegisterVideoContentChangeCB(),RegisterVideoResolutionChangeCB(), RegisterVideoFrameRateChangeCB()</p>"},{"location":"external_content/tvsettings/#set-with-saveonly-flag-sequence","title":"Set With SaveOnly Flag Sequence LEGEND: tvSettings_SetMethods:","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    alt is when saveonly flag is 0\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods\n    Note over HAL: APIs to set the values for color temperature\n    HAL-&gt;&gt;Driver:Sets the values\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    else is when saveonly flag is 1\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods\n    Note over HAL: APIs to set the values for color temperature\n    HAL-&gt;&gt;OPPDB: Saves the new values\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    end</code></pre> <p>SetColorTemp_Rgain_onSource(), SetColorTemp_Ggain_onSource(), SetColorTemp_Bgain_onSource(), SetColorTemp_R_post_offset_onSource(), SetColorTemp_G_post_offset_onSource(), SetColorTemp_B_post_offset_onSource()</p>"},{"location":"external_content/tvsettings/#gammatmax-sequenceset-and-save","title":"Gamma/TMax sequence(set and save) LEGEND: tvSettings_SetMethods:tvSettings_SaveMethods :","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods_GammaTable\n    Note over HAL: APIs to set the values for color temperature\n    HAL-&gt;&gt;Driver:Sets the values\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_SaveMethods_GammaTable\n    Note over HAL: APIs to save the values for color temperature\n    HAL-&gt;&gt;OPPDB: Saves the new values\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre> <p>SetGammaTable(), SetDvTmaxValue()</p> <p>SaveGammaTable(), SaveDvTmaxValue()</p>"},{"location":"external_content/tvsettings/#terminate-sequence","title":"Terminate Sequence","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller -&gt;&gt;HAL:tvTerm()\n    HAL -&gt;&gt; Driver: Releases all the resources allocated during tvInit()\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/tvsettings/#functional-diagram","title":"Functional Diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; ClosedState\n    ClosedState --&gt; OpenState: tvInit()-Initialize Picture Quality params\n    OpenState --&gt; ControlState: Set/Get PQ params\n    ControlState --&gt; Validate: Recieve success/failure response from driver\n    Validate --&gt; OpenState\n    OpenState --&gt; MonitorState: Watch for events\n    MonitorState --&gt; NotifyState: Notify events\n    NotifyState --&gt; MonitorState</code></pre>"},{"location":"external_content/tvsettings/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"external_content/tvsettings/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"external_content/tvsettings/CHANGELOG/#210","title":"2.1.0","text":"<ul> <li>gh #46 Remove ODM specific apis - phase1 <code>#47</code></li> <li>Merge tag '2.0.0' into develop <code>3389b5d</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#200","title":"2.0.0","text":"<p>8 November 2024</p> <ul> <li>gh #34 tvsettings-interface-to-get-number-of-dimming-zones-supported <code>#35</code></li> <li>gh #21 tv settings interface to find ldim short dev <code>#26</code></li> <li>gh #25 updated pq_capabilities.ini <code>d37668d</code></li> <li>gh #25 updated pq capabilities <code>d5ef30e</code></li> <li>Update tvSettings.h <code>3c4175e</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#140","title":"1.4.0","text":"<p>27 August 2024</p> <ul> <li>gh #27 Add DolbyMode Game Support <code>#31</code></li> <li>Bumped CHANGELOG.md - 1.4.0 <code>0d5d3ef</code></li> <li>Merge tag '1.3.0' into develop <code>cc56e5c</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#130","title":"1.3.0","text":"<p>12 July 2024</p> <ul> <li>gh #23 HAL Interface update for default values <code>#24</code></li> <li>gh #19 PQ capabilites_ini_changes <code>#15</code></li> <li>gh #17 Post Requirement changes for the TV setting interface. <code>#18</code></li> <li>gh #19 Added index for different capabilities <code>36b298f</code></li> <li>Bumped CHANGELOG.md - 1.3.0 <code>25743a5</code></li> <li>gh #19 Updated hal spec document for composite input <code>86cc71b</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#120","title":"1.2.0","text":"<p>7 March 2024</p> <ul> <li>gh #12 Add supercool wb support <code>#13</code></li> <li>bumped change log <code>b90c8b7</code></li> <li>gh #12 addressed review comment <code>0e6e503</code></li> <li>gh #12 change enum sequnce for backward compatibility <code>5504305</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#117","title":"1.1.7","text":"<p>20 February 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.1.7 <code>4765623</code></li> <li>Updated generate_docs.sh &amp; removed version info from spec <code>f0c3b32</code></li> <li>Merge tag '1.1.6' into develop <code>18473bc</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#116","title":"1.1.6","text":"<p>15 February 2024</p> <ul> <li>gh #6 Remove const for get and correct in params <code>#9</code></li> <li>gh #5 add correct tvsettings hal specs <code>785dbf3</code></li> <li>gh #5 add correct tvsettings hal specs <code>fcfb87b</code></li> <li>gh #10 return tvError in callbacks <code>45427f7</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#115","title":"1.1.5","text":"<p>23 January 2024</p> <ul> <li>Feature/issue1 clean unnecessary APs <code>#4</code></li> <li>baseline version <code>#2</code></li> <li>Clean_unnecessary_APIs <code>18a363a</code></li> <li>Bumped CHANGELOG.md - 0.1.1 <code>828de6a</code></li> <li>Bumped CHANGELOG.md - 1.1.5 <code>511c34d</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#020","title":"0.2.0","text":"<p>3 May 2024</p> <ul> <li>baseline version <code>3ff7ac3</code></li> <li>Bumped CHANGELOG.md - 0.2.0 <code>02afd4f</code></li> <li>Initial commit <code>b1ecbb3</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#011","title":"0.1.1","text":"<p>29 December 2023</p> <ul> <li>Bumped CHANGELOG.md - 0.1.1 <code>828de6a</code></li> <li>Update the tvSettings.h &amp; README.md with sha <code>6a8e377</code></li> <li>Merge tag '0.1.0' into develop <code>dfdff28</code></li> </ul>"},{"location":"external_content/tvsettings/CHANGELOG/#010","title":"0.1.0","text":"<p>20 December 2023</p> <ul> <li>baseline version <code>#2</code></li> <li>Added CHANGELOG.md - 0.1.0 <code>18d5cd8</code></li> <li>Updated the NOTICE with sky uk copy right <code>f1245f1</code></li> <li>Readme update <code>9ac80d4</code></li> </ul>"},{"location":"external_content/tvsettings/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/tvsettings/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/","title":"TV Settings HAL Documentation","text":""},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup<ul> <li>Table Format </li> </ul> </li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operation and key concepts</li> <li>Diagrams</li> </ul>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>CPU</code> - Central Processing Unit</li> <li><code>HAL</code> - Hardware Abstraction layer</li> <li><code>PQ</code>  - Picture Quality</li> <li><code>SOC</code> - System on chip</li> <li><code>OEM</code> - Original Equipment Manufacturer</li> <li><code>ALS</code> - Auto Light Sensor</li> <li><code>API</code> - Application Programming Interface</li> <li><code>DV</code>  - Dolby Vision</li> <li><code>CMS</code> - Colorspace Management System</li> <li><code>TMAX</code>- Temperature MAX</li> <li><code>SRD</code> - Standard Dynamic Range</li> <li><code>HDR</code> - High Dynamic Range</li> <li><code>HLG</code> - Hybrid Log Gamma</li> <li><code>UHD</code> - Ultra High Definition</li> <li><code>LDIM</code>- Local Dimming</li> </ul>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#description","title":"Description","text":"<p>TV Settings <code>HAL</code> is an interface which provides <code>APIs</code> to modify/control the picture quality parameters, dimming modes and auto backlight modes.</p> <pre><code>%%{ init : { \"theme\" : \"forest\", \"flowchart\" : { \"curve\" : \"linear\" }}}%%\nflowchart TD\nCaller &lt;--&gt; x[TV Setting HAL] \nx[TV Setting HAL] &lt;--&gt; y[Video/Picture Quality Driver]\nstyle Caller fill:#99CCFF,stroke:#333,stroke-width:0.3px\nstyle y fill:#fc9,stroke:#333,stroke-width:0.3px\nstyle x fill:#9f9,stroke:#333,stroke-width:0.3px</code></pre>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":""},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p>The caller must initialize the <code>APIs</code> with picture quality modes for specific platforms and initiates communication with picture quality drivers. The standard/default values shall be maintained in default Picture profile database and any modified values for these parameters using TV Settings HAL APIs will be maintained in override Picture profile database. HAL shall be responsible to store these Picture profile data into the database. Picture profile database will have 5 types of tables: 1. Picture property table to maintain all picture properties for a given picture mode, video format and video source 2. Picture mode association table maintain the association of a given video source and video format to a picture mode 3. If input source, picture mode, and video format are not already set or specified, they will default to \"IP source,\" \"Entertainment,\" and \"SDR,\" respectively. However, if the caller attempts to change parameters that rely on these values, they will be acted upon default values accordingly. 4. White balance table for every color temperature and video source to maintain WB calibrated values 5. Gamma table for every color temperature to maintain the gamma calibrated values. 6. TMAX table for every local dimming level to maintain the TMAX value</p> <ul> <li>The capabilities of a specific platform with respect to TV picture configuration will be defined in a config file (pq_capabilities.ini which decides supported formats, picture modes, dimming modes, dvModes, resolution etc.</li> <li>Caller must initialize by calling <code>tvInit()</code> which must initialize the parameters in default picture property database. These parameters are decided by Soc vendor  based on platform capability.</li> <li>On every bootup the default picture profile database will be copied to override picture profile database.</li> </ul>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#table-format","title":"Table Format","text":""},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#picture-property-table","title":"Picture Property Table","text":"Video Source Video Format Picture Mode Picture Property HDMI1 SDR Standard/Entertainment Brightness Contrast Sharpness Saturation Hue Backlight Dolbymode AspectRatio Colortemperature Dimming Mode Local Dimming Low Latency CMS State CMS Saturation RED CMS Saturation BLUE CMS Saturation GREEN CMS Saturation YELLOW CMS Saturation CYAN CMS Saturation MAGENTA CMS Hue RED CMS Hue BLUE CMS Hue GREEN CMS Hue YELLOW CMS Hue CYAN CMS Hue MAGENTA CMS Luma RED CMS Luma BLUE CMS Luma GREEN CMS Luma YELLOW CMS Luma CYAN CMS Luma MAGENTA Theater/Movie Repeat as standard FilmMaker Repeat as standard Sports Repeat as standard Game Repeat as standard Custom/Expert Repeat as standard EnergySaving Repeat as standard Vivid Repeat as standard Graphics Repeat as standard HDR10 Repeat as SDR HLG Repeat as SDR DV Repeat as SDR HDMI2 Repeat as HDMI1 HDMI3 Repeat as HDMI1 Tunner Repeat as HDMI1 IP Repeat as HDMI1 Composite Repeat as HDMI1 <p>Note: Currently Dolby mode is treated as a picture property and not a picture mode. In future Dolby mode might be treated as picture mode. Values of index in pq_capabilites.ini are mapped to enum values in tvTypes.h</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#picture-association-table","title":"Picture Association Table","text":"Video Source Video Format Picture Mode HDMI1 SDR Standard/Entertainment Theater/Movie FilmMaker Sports Game Custom/Expert EnergySaving Vivid Graphics HDR10 Repeat as SDR HLG Repeat as SDR DV Repeat as SDR HDMI2 Repeat as HDMI1 HDMI3 Repeat as HDMI1 Tunner Repeat as HDMI1 IP Repeat as HDMI1 Composite Repeat as HDMI1"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#wb-table","title":"WB Table","text":"Video Source White Balance Property Value Range HDMI1 Cold White Balance Table Red Gain 0-2047 Green Gain 0-2047 Blue Gain 0-2047 Red offset (-1024) to (+1023) Green offset (-1024) to (+1023) Blue offset (-1024) to (+1023) Warm White Balance Table Repeat as Cold White Balance Table Normal White Balance Table Repeat as Cold White Balance Table User White Balance Table Repeat as Cold White Balance Table Boost cold White Balance Table Repeat as Cold White Balance Table Bost warm White Balance Table Repeat as Cold White Balance Table Boost normal White Balance Table Repeat as Cold White Balance Table Boost user White Balance Table Repeat as Cold White Balance Table HDMI2 Repeat as HDMI1 HDMI3 Repeat as HDMI1 Tunner Repeat as HDMI1 IP Repeat as HDMI1 Composite Repeat as HDMI1"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#gamma-table","title":"Gamma Table","text":"Gamma Index Property Value Range Cold Gamma Table 0 Red Gain 0-1023 Green Gain 0-1023 Blue Gain 0-1023 1 Repeat as 0 2 Repeat as 0 . 254 Repeat as 0 255 Repeat as 0 Warm Gamma Table Repeat as Cold Gamma Table Normal Gamma Table Repeat as Cold Gamma Table User Gamma Table Repeat as Cold Gamma Table Boorst cold Gamma Table Repeat as Cold Gamma Table Boost warm Gamma Table Repeat as Cold Gamma Table Boost normal Gamma Table Repeat as Cold Gamma Table Boost user Gamma Table Repeat as Cold Gamma Table"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#tmax-table","title":"TMAX Table","text":"TMAX Value Range Non Boost 0 to 10000 Boost 0 to 10000 Burst 0 to 10000"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is not required to be thread safe.  There are no constraints on thread creation or signal handling. </p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#process-model","title":"Process Model","text":"<p>This interface is expected to support a single instantiation with a single process.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#memory-model","title":"Memory Model","text":"<p>The caller is responsible for allocating and cleaning up any memory used.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to participate in power management.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>This interface requires callback notification registration for VideoFormatChange, VideoResolutionChange, VideoFrameRateChange, VideoContentChange. The caller must return the callback context as fast as possible and will not block.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>This interface is required to have no blocking calls.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All <code>APIs</code> must return error synchronously as return argument.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#persistence-model","title":"Persistence Model","text":"<p>Each vendor needs to define their own config file which is expected to be stored in rootfs and this must be a readonly. Config file must contain the supported formats, picture modes, dimming modes, dvModes, resolution etc.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>Following non-functional requirement must be supported by the TV Settings <code>HAL</code> component:</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required  to not cause excessive memory and <code>CPU</code> utilization.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings must be treated as errors.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Copyright validation is required to be performed, e.g.: <code>Black duck</code>, <code>FossID</code>.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#licensing","title":"Licensing","text":"<p>This interface is expected to get released under the Apache License 2.0.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#build-requirements","title":"Build Requirements","text":"<p>TV Settings <code>HAL</code> source code must build into a shared library and must be named as <code>libtvsettings-hal.so</code>.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#variability-management","title":"Variability Management","text":"<p>Any changes in the <code>APIs</code> must be reviewed and approved by component architects.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>Product or platform specification requirements will be handled in vendor specific config file.</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation will be provided by Doxygen which will be generated from the header file(s).</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#theory-of-operation-and-key-concepts","title":"Theory of operation and key concepts","text":"<p>This interface handles various functionalities/requests related to Picture Quality settings :</p> <ul> <li>Brightness</li> <li>Contrast</li> <li>Hue</li> <li>Saturation</li> <li>White Balance</li> <li>Sharpness</li> <li>Color Temperature</li> <li>Backlight </li> <li>Aspect Ratio</li> <li>Dimming Modes</li> <li>Local Dimming Level</li> <li>Low Latency state</li> <li>Notify Video Format Change</li> <li>Notify Video Resolution Change</li> <li>Notify Video FrameRate Change</li> <li>Notify Video Content Change</li> </ul> <p>There are other platform specific Picture Quality settings that can be managed by this interface :</p> <ul> <li>CMS</li> <li>Dolby Vision</li> </ul>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#diagrams","title":"Diagrams","text":""},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#operational-call-diagram","title":"Operational Call Diagram","text":""},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#init-and-callback-sequence","title":"Init and Callback Sequence","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller-&gt;&gt;HAL:tvInit()\n    Note over HAL: Initialize the TV Setting HAL APIs\n    HAL-&gt;&gt;Driver: Allocates resources\n    Driver--&gt;&gt;HAL:return\n    HAL-&gt;&gt;DPPDB: tvSettings_GetDefaultPQParams() Read default picture profile properites\n    DPPDB--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Copy default picture profile properites\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    Caller-&gt;&gt;HAL: SetTVPictureMode()\n    Note over HAL: Set the default picture mode entertainment\n    HAL-&gt;&gt;OPPDB: tvSettings_GetPQParams() Read associated picture properties\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload gamma and white balance if there is a colour temperature value change.\n    HAL-&gt;&gt;OPPDB: Read associated Gamma and White balance\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload TMAX if there is a LDIM level change\n    HAL-&gt;&gt;OPPDB: Read associated TMAX value\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Apply the new picture properties, gamma, TMAX and white balance if they have changed.\n    HAL-&gt;&gt;Driver: Apply new picture properties\n    Driver--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Update the Picture mode association table\n    Note over HAL: Associate new picture mode to current video format and current video source\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: RegisterCallBack\n    Note over HAL:RegisterCallBack for Format/Resolution/FrameRate/VideoContent Change\n    HAL--&gt;&gt;Caller:return\n\n    Driver--&gt;&gt;HAL:Notify on video format/framerate/resolution/videocontent/videosource change\n    Note over HAL: Reload associated Picture mode and all associated picture properties if there is video format and video source change.\n    Note over HAL: However video source change will not be notified to caller\n    HAL-&gt;&gt;OPPDB: Read associated picture mode\n    OPPDB--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Read associated picture properties\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload gamma and white balance if there is a colour temperature value change.\n    HAL-&gt;&gt;OPPDB: Read associated Gamma and White balance\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Reload TMAX if there is a LDIM level change\n    HAL-&gt;&gt;OPPDB: Read associated TMAX value\n    OPPDB--&gt;&gt;HAL:return\n    Note over HAL: Apply the new picture properties, gamma and white balance if they have changed.\n    HAL-&gt;&gt;Driver: Apply new picture properties\n    Driver--&gt;&gt;HAL: return\n    HAL--&gt;&gt;Caller:Notify on video format/framerate/resolution/content change</code></pre>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#setgetsave-picture-quality-parameter-sequence","title":"Set/Get/Save Picture Quality Parameter Sequence LEGEND: tvSettings_SetMethods:tvSettings_GetMethods:tvSettings_SaveMethods :RegisterCallback :","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods\n    Note over HAL: APIs to set the Picture Quality Parameters\n    HAL-&gt;&gt;Driver:Sets the PQ Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL-&gt;&gt;OPPDB: Saves the new PQ Parameter\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_GetMethods\n    Note over HAL: APIs to get the PQ Parameters\n    HAL-&gt;&gt;Driver:Gets the PQ Parameters\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_SaveMethods\n    Note over HAL: APIs to save the Picture Quality Parameters\n    HAL-&gt;&gt;OPPDB:Save the PQ Parameters\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_GetPQParam\n    Note over HAL: APIs to get PQ param from override Picture Profile Database\n    HAL-&gt;&gt;OPPDB:Get the PQ Parameters\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_GetDefaultPQParam\n    Note over HAL: APIs to get Default PQ param from default Picture Profile Database\n    HAL-&gt;&gt;DPPDB:Get the PQ Parameters\n    DPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre> <p>SetBrightness(), SetContrast(), SetSaturation(), SetHue(),SetSharpness(), SetColorTemperature(),SetBacklight(), etc..</p> <p>GetBrightness(), GetContrast(), GetSaturation(), GetHue(),GetSharpness(), GetColorTemperature(),GetBacklight(), GetPQParams(), GetDefaultPQParams() etc..</p> <p>SaveBrightness(), SaveContrast(), SaveSaturation(), SaveHue(),SaveSharpness(), SaveColorTemperature(),SaveBacklight(), etc..</p> <p>RegisterVideoFormatChangeCB(),RegisterVideoContentChangeCB(),RegisterVideoResolutionChangeCB(), RegisterVideoFrameRateChangeCB()</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#set-with-saveonly-flag-sequence","title":"Set With SaveOnly Flag Sequence LEGEND: tvSettings_SetMethods:","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    alt is when saveonly flag is 0\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods\n    Note over HAL: APIs to set the values for color temperature\n    HAL-&gt;&gt;Driver:Sets the values\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    else is when saveonly flag is 1\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods\n    Note over HAL: APIs to set the values for color temperature\n    HAL-&gt;&gt;OPPDB: Saves the new values\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n    end</code></pre> <p>SetColorTemp_Rgain_onSource(), SetColorTemp_Ggain_onSource(), SetColorTemp_Bgain_onSource(), SetColorTemp_R_post_offset_onSource(), SetColorTemp_G_post_offset_onSource(), SetColorTemp_B_post_offset_onSource()</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#gammatmax-sequenceset-and-save","title":"Gamma/TMax sequence(set and save) LEGEND: tvSettings_SetMethods:tvSettings_SaveMethods :","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller-&gt;&gt;HAL: tvSettings_SetMethods_GammaTable\n    Note over HAL: APIs to set the values for color temperature\n    HAL-&gt;&gt;Driver:Sets the values\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return\n\n    Caller-&gt;&gt;HAL: tvSettings_SaveMethods_GammaTable\n    Note over HAL: APIs to save the values for color temperature\n    HAL-&gt;&gt;OPPDB: Saves the new values\n    OPPDB--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre> <p>SetGammaTable(), SetDvTmaxValue()</p> <p>SaveGammaTable(), SaveDvTmaxValue()</p>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#terminate-sequence","title":"Terminate Sequence","text":"<pre><code>sequenceDiagram\nparticipant Caller as Caller\n    participant HAL as TV Settings HAL\n    participant OPPDB as Override Picture Profile DB\n    participant DPPDB as Default Picture Profile DB\n    participant Driver as SoC\n\n    Caller -&gt;&gt;HAL:tvTerm()\n    HAL -&gt;&gt; Driver: Releases all the resources allocated during tvInit()\n    Driver--&gt;&gt;HAL:return\n    HAL--&gt;&gt;Caller:return</code></pre>"},{"location":"external_content/tvsettings/docs/pages/tv-settings_halSpec/#functional-diagram","title":"Functional Diagram","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; ClosedState\n    ClosedState --&gt; OpenState: tvInit()-Initialize Picture Quality params\n    OpenState --&gt; ControlState: Set/Get PQ params\n    ControlState --&gt; Validate: Recieve success/failure response from driver\n    Validate --&gt; OpenState\n    OpenState --&gt; MonitorState: Watch for events\n    MonitorState --&gt; NotifyState: Notify events\n    NotifyState --&gt; MonitorState</code></pre>"},{"location":"python_venv/lib/python3.10/site-packages/Markdown-3.7.dist-info/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"python_venv/lib/python3.10/site-packages/idna-3.10.dist-info/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"python_venv/lib/python3.10/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"python_venv/lib/python3.10/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2024 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"python_venv/lib/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"},{"location":"python_venv/lib64/python3.10/site-packages/Markdown-3.7.dist-info/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"python_venv/lib64/python3.10/site-packages/idna-3.10.dist-info/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2013-2024, Kim Davies and contributors. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"python_venv/lib64/python3.10/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"python_venv/lib64/python3.10/site-packages/mkdocs_material_extensions-1.3.1.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2021 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/","title":"License","text":""},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#pymdown-extensions","title":"PyMdown Extensions","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2014 - 2024 Isaac Muse</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#superfences","title":"SuperFences","text":"<p><code>superfences.py</code> is derived from Python Markdown's fenced_code extension.</p> <pre><code>Fenced Code Extension for Python Markdown\n =========================================\nThis extension adds Fenced Code Blocks to Python-Markdown.\nSee &lt;https://python-markdown.github.io/extensions/fenced_code_blocks/&gt;\nfor documentation.\nOriginal code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#highlight","title":"Highlight","text":"<p><code>highlight.py</code> is derived from Python Markdown's CodeHilite extension.</p> <pre><code>CodeHilite Extension for Python-Markdown\n ========================================\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\nSee &lt;https://python-markdown.github.io/extensions/code_hilite/&gt;\nfor documentation.\nOriginal code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\nAll changes Copyright 2008-2014 The Python Markdown Project\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#fancylists","title":"FancyLists","text":"<p><code>fancylists.py</code> is derived from Python Markdown's list handler.</p> <pre><code>Started by Manfred Stienstra (http://www.dwerg.net/).\nMaintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\nCurrently maintained by Waylan Limberg (https://github.com/waylan),\nDmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\nCopyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\nCopyright 2004 Manfred Stienstra (the original version)\n\nLicense: [BSD](http://www.opensource.org/licenses/bsd-license.php)\n</code></pre>"},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#gemoji-index","title":"Gemoji Index","text":"<p><code>gemoji_db.py</code> is generated from Gemoji's source code: @github/gemoji.</p> <pre><code>Copyright (c) 2013 GitHub, Inc.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"python_venv/lib64/python3.10/site-packages/pymdown_extensions-10.14.3.dist-info/licenses/LICENSE/#emojione-index","title":"EmojiOne Index","text":"<p><code>emoji1_db.py</code> is generated from EmojiOne's source code: @Ranks/emojione</p> <pre><code>EmojiOne Non-Artwork\n\nApplies to the JavaScript, JSON, PHP, CSS, HTML files, and everything else not covered under the artwork license above.\nLicense: MIT\nComplete Legal Terms: http://opensource.org/licenses/MIT\n</code></pre>"}]}