{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"rmf-audio-capture_High-Level_TestSpec/","title":"RMF Audio Capture High Level Test Specification Documentation","text":""},{"location":"rmf-audio-capture_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Test Scenarios</li> <li>Check primary audio capture</li> <li>Check auxiliary audio capture</li> <li>Check concurrent audio capture</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code> - Unit Test(s)</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>API</code> - Application Programming Interface</li> <li><code>L2</code> - Level2 Testing</li> <li><code>L3</code> - Level3 Testing</li> <li><code>NA</code> - Not Applicable</li> <li><code>Y</code> - Yes</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the testing requirements for the RMF audio capture module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <ul> <li><code>HAL</code> specification is available here: rmf-audio-capture_halSpec.md</li> <li><code>HAL</code> interface is available here: rmfAudioCapture header</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#test-scenarios","title":"Test Scenarios","text":"# Test Functionality Description 1 Check primary audio capture Run a capture of primary audio for a while and verify delivery of data 2 Check auxiliary audio capture Run a capture of auxiliary audio (on supported devices only) for a while and verify delivery of data 3 Check concurrent audio capture Run parallel captures of primary and auxiliary audio (on supported devices only) and verify delivery of data"},{"location":"rmf-audio-capture_High-Level_TestSpec/#check-primary-audio-capture","title":"Check primary audio capture","text":"Description HAL APIs L2 L3 Control plane requirements Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run primary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-primary-audio-capture","title":"Test Startup Requirement - Check primary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 tests.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-primary-audio-capture","title":"Emulator Requirements - Check primary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-primary-audio-capture","title":"Control Plane Requirements - Check primary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#check-auxiliary-audio-capture","title":"Check auxiliary audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run auxiliary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error.Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-auxiliary-audio-capture","title":"Test Startup Requirement - Check auxiliary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have auxiliary audio track.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-auxiliary-audio-capture","title":"Emulator Requirements - Check auxiliary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-auxiliary-audio-capture","title":"Control Plane Requirements - Check auxiliary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#check-concurrent-audio-capture","title":"Check concurrent audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples.  Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Open primary and auxiliary capture interfaces, then issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code> Run auxiliary+primary audio capture for 10 seconds with known source material and verify that captured audio clips are faithful to the source within margin of error. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary+primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-concurrent-audio-capture","title":"Test Startup Requirement - Check concurrent audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have primary as well as auxiliary audio tracks.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-concurrent-audio-capture","title":"Emulator Requirements - Check concurrent audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver two distinct 10-second audio clips (from wav or raw PCM file) to each capture interface when triggered by control plane. It must be able to drive primary and auxiliary captures concurrently.</li> </ul>"},{"location":"rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-concurrent-audio-capture","title":"Control Plane Requirements - Check concurrent audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/","title":"RMF Audio Capture HAL L1 and L2 Test Procedure","text":""},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Run L1 and L2 Test directly (without python)</li> <li>Run L1 and L2 using python</li> <li>Setting Up Test Environment</li> <li>Update Configuration Files</li> <li>Run Test Cases</li> </ul>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L1</code>     - Level 1 Testing</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#run-l1-and-l2-test-directly-without-python","title":"Run L1 and L2 Test directly (without python)","text":"<p>Refer Running L1 and L2 Test suites</p>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#run-l1-and-l2-using-python","title":"Run L1 and L2 using python","text":""},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L1</code> and <code>L2</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Used by raft ssh_hal_test To run the <code>HAL</code> binary <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"http://localhost:8000/\"    # download location for the CPE device\n        httpProxy:   # Local Proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml For more details refer RAFT and example_device_config.yml Update below fields in the device configuration file: - Set the path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../profiles/rmfAudioCaptureAuxSupported.yaml\"\n</code></pre>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: rmfAudio_L1_L2_testSetup.yml</p> <p>This <code>yaml</code> contains the list of test_suites and test_cases to run</p> <p>To execute each test_case individually, update the YAML file as shown in the example below:</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture L1 and L2 test setup\"\n  test_suites: # List of L1 and L2 test suites\n    - name: \"L1 rmfAudioCapture\"\n      test_cases:\n        - RMF_Open_Type_primary_L1_pos\n    - name: \"L1 rmfAudioCapture\"\n      test_cases:\n        - RMF_Open_Type_primary_L1_neg\n    - name: \"L1 rmfAudioCapture\"\n      test_cases:\n        - RMF_Open_L1_pos\n</code></pre> <p>To execute all test_cases within a test_suite, update the YAML file as shown in the example below:</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture L1 and L2 test setup\"\n  test_suites: # List of L1 and L2 test suites\n    - name: \"L1 rmfAudioCapture\" # Name of the test suit to run\n      test_cases: # List of test cases to execute, to run all test cases in test suite with R option use `all`\n        - all\n</code></pre> <p>To execute multiple test_suites, update the YAML file as shown in the example below:</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture L1 and L2 test setup\"\n  test_suites: # List of L1 and L2 test suites\n    - name: \"L1 rmfAudioCapture\" # Name of the test suit to run\n      test_cases: # List of test cases to execute, to run all test cases in test suite with R option use `all`\n        - all\n    - name: \"L1 rmfAudioCapture\" # Name of the test suit to run\n      test_cases: \n        - \"RMF_Open_Type_primary_L1_pos\"\n        - \"RMF_Open_Type_primary_L1_neg\"\n        - \"RMF_Open_L1_pos\"\n        - \"RMF_Open_L1_neg\"\n    - name: \"L2 rmfAudioCapture\"\n      test_cases:\n        - \"l2_rmf_primary_data_check\"\n        - \"l2_rmf_auxiliary_data_check\"\n        - \"l2_rmf_combined_data_check\"\n</code></pre>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: rmfAudio_testConfig.yml Execute command to run the HAL binary was provided in this file. <pre><code>rmfaudiocapture:\n    description: \"RMF Audio Capture testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre></p>"},{"location":"rmf-audio-capture_L1_L2_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command <pre><code>python rmfAudio_L1_L2_tests.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre></p>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/","title":"RMF AUDIO CAPTURE L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the level 2 testing suite for the RMF AUDIO CAPTURE module.</p>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - rmf-audio-capture_High-Level_TestSpec.md</li> </ul>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_primary_data_check</code> Description Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns Test Group Module : 02 Test Case ID 1 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open()</code> to open interface handle = valid pointer RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings returns RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture settings=default settings from previous step, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, status callback NULL RMF_SUCCESS Should be successful 04 Capture audio for 10 seconds sleep(10) N/A N/A 05 Call <code>RMF_AudioCapture_Stop</code> with handle and set cookie variable to 0 immediately afterwards handle = valid pointer RMF_SUCCESS Should be successful 06 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variable remains 0 N/A cookie=0 Should be successful 07 Call <code>RMF_AudioCapture_Close()</code> to release resources current handle RMF_SUCCESS Should be successful 08 Compare actual total bytes logged by data callback with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_GetDefaultSettings]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|Failure| B1[Test case fail]\n    B --&gt;|RMF_SUCCESS| B2[Call RMF_AudioCapture_Start with settings]\n    B2 --&gt; |Failure| B3[Test case fail]\n    B2 --&gt;|RMF_SUCCESS| C[Wait 10 seconds]\n    C --&gt; D[Call RMF_AudioCapture_Stop, set cookie = 0]\n    D --&gt; DCW{Wait for 1 second. &lt;br&gt; Is cookie = 0?}\n    DCW --&gt; |No| DCF[Test case fail]\n    DCW --&gt; |Yes|E[call RMF_AudioCapture_Close]\n    E --&gt; |Failure| E1[Test case fail]\n    E --&gt;|RMF_SUCCESS| F{Total captured data &lt;br&gt; size comparable to &lt;br&gt; estimated total?}\n    F --&gt;|Yes| G[Test case success]\n    F --&gt;|No| F1[Test case fail]</code></pre>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_auxiliary_data_check</code> Description Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns Test Group Module : 02 Test Case ID 002 Priority High <p>Pre-Conditions : Device must support auxiliary audio capture.</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer, type=auxiliary RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings returns RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture settings=default settings from previous step, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, status callback NULL RMF_SUCCESS Should be successful 04 Capture audio for 10 seconds sleep(10) N/A N/A 05 Call <code>RMF_AudioCapture_Stop</code> with handle and set cookie variable to 0 immediately afterwards handle = valid pointer RMF_SUCCESS Should be successful 06 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variable remains 0 N/A cookie=0 Should be successful 07 Call <code>RMF_AudioCapture_Close()</code> to release resources current handle RMF_SUCCESS Should be successful 08 Compare actual total bytes logged by data callback with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open_Type] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_GetDefaultSettings]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|Failure| B1[Test case fail]\n    B --&gt;|RMF_SUCCESS| B2[Call RMF_AudioCapture_Start with settings]\n    B2 --&gt; |Failure| B3[Test case fail]\n    B2 --&gt;|RMF_SUCCESS| C[Wait 10 seconds]\n    C --&gt; D[Call RMF_AudioCapture_Stop, set cookie = 0]\n    D --&gt; DCW{Wait for 1 second. &lt;br&gt; Is cookie = 0?}\n    DCW --&gt; |No| DCF[Test case fail]\n    DCW --&gt; |Yes|E[call RMF_AudioCapture_Close]\n    E --&gt; |Failure| E1[Test case fail]\n    E --&gt;|RMF_SUCCESS| F{Total captured data &lt;br&gt; size comparable to &lt;br&gt; estimated total?}\n    F --&gt;|Yes| G[Test case success]\n    F --&gt;|No| F1[Test case fail]</code></pre>"},{"location":"rmf-audio-capture_L2-Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_combined_data_check</code> Description Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Test Group Module : 02 Test Case ID 003 Priority High <p>Pre-Conditions : Device must support auxiliary audio capture.</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer; type = \"auxiliary\" RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer; type = \"primary\" RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings pointer returns RMF_SUCCESS Should be successful 04 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture handle = primary handle, settings initalized to default settings, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, cbBufferReadyParm = pointer to primary capture context with byte counter and cookie, status callback NULL RMF_SUCCESS Should be successful 05 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture handle = auxiliary handle, settings initalized to default settings, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, cbBufferReadyParm = pointer to auxiliary capture context with byte counter and cookie, status callback NULL RMF_SUCCESS Should be successful 06 Capture audio for 10 seconds sleep(10) N/A Should be successful 07 Call <code>RMF_AudioCapture_Stop</code> with primary handle and set primary context cookie variable to 0 immediately afterwards handle = primary RMF_SUCCESS Should be successful 08 Call <code>RMF_AudioCapture_Stop</code> with auxiliary handle and set auxiliary context cookie variable to 0 immediately afterwards handle = auxiliary RMF_SUCCESS Should be successful 09 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variables for both primary and auxiliary contexts remain 0 N/A primary and auxiliary cookies = 0 Should be successful 10 Call <code>RMF_AudioCapture_Close()</code> to release resources current primary handle RMF_SUCCESS Should be successful 11 Call <code>RMF_AudioCapture_Close()</code> to release resources current auxiliary handle RMF_SUCCESS Should be successful 12 Compare actual total bytes logged by data callbacks for both primary and auxiliary contexts with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open_Type &lt;br&gt; for primary] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_Open_Type &lt;br&gt; for auxillary]\n    A --&gt;|Fail| A_Fail[Test case fail]\n    B --&gt;|RMF_SUCCESS| C[Call RMF_AudioCapture_GetDefaultSettings]\n    B --&gt;|Fail| B_Fail[Test case fail]\n    C --&gt;|RMF_SUCCESS| D[Modify settings,&lt;br&gt; set cbBufferReady and cbBufferReadyParm for &lt;br&gt; both primary and secondary]\n    C --&gt;|Fail| C_Fail[Test case fail]\n    D --&gt; E[Call RMF_AudioCapture_Start &lt;br&gt; with primary handle]\n    E --&gt;|RMF_SUCCESS| F[Call RMF_AudioCapture_Start &lt;br&gt; with auxiliary handle]\n    E --&gt;|Fail| E_Fail[Test case fail]\n    F --&gt;|RMF_SUCCESS| G[Capture audio for 10 seconds]\n    F --&gt;|Fail| F_Fail[Test case fail]\n    G --&gt; I[Call RMF_AudioCapture_Stop &lt;br&gt; for primary handle, &lt;br&gt; set cookie = 0]\n    I --&gt;|RMF_SUCCESS| J[Call RMF_AudioCapture_Stop &lt;br&gt; for auxiliary handle, &lt;br&gt; set cookie = 0]\n    I --&gt;|Fail| I_Fail[Test case fail]\n    J --&gt;|RMF_SUCCESS| K[Wait 1 second, &lt;br&gt; verify that cookies = 0]\n    J --&gt;|Fail| J_Fail[Test case fail]\n    K --&gt; |cookies = 0|L[Call RMF_AudioCapture_Close &lt;br&gt; for primary handle]\n    K --&gt; |cookies = 1| K_FAIL[Test case fail]\n    L --&gt;|RMF_SUCCESS| M[Call RMF_AudioCapture_Close &lt;br&gt; for auxiliary handle]\n    L --&gt;|Fail| L_Fail[Test case fail]\n    M --&gt;|Fail| M_Fail[Test case fail]\n    M --&gt;|RMF_SUCCESS| N{Total captured data\\nsize comparable to\\nestimated total for\\nprimary and auxiliary?}\n    N --&gt;|Yes| N1[Test case success]\n    N --&gt;|No| N2[Test case fail]</code></pre>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/","title":"RMF Audio Capture L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>References</li> <li>Audio Streams Requirement</li> <li>Level 3 Test Procedure</li> <li>Level 3 Python Test</li> </ul>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>NA</code>     - Not Applicable</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> </ul>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Test Procedure for the RMF Audio Capture module.</p>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li>RMF audio capture HAL Interface - rmfAudioCapture.h</li> <li>High Level Test Specification - rmf-audio-capture_High-Level_TestSpec.md</li> </ul>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#audio-streams-requirement","title":"Audio Streams Requirement","text":"# Stream Name Description 01 Sin_120s_48k_stereo.wav 120 seconds sin wave generated at 48kz, stereo file 02 Triangle_10s_480k_stereo.wav 10 seconds triangle wave generated at 48kz, stereo file"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Below are top test use-case for the RMF audio capture. | #   | Test-case              | Description                                                                                                                                                                                                                    | HAL APIs                                                                                                                                 | Streams Number | | --- | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- | -------------- | | 1   | Primary data capture   | Play a reference stream, run primary audio capture, verify that captured audio is faithful to the source within margin of error                                                                                                | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1              | | 2   | Primary jitter test    | Play a reference stream, run primary audio capture, monitor jitter regularly                                                                                                                                                   | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1              | | 3   | Independent data check | Play reference streams simultaneously for primary and auxiliary captures, issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1,2            | | 4   | Auxiliary data capture | Play a reference stream, run auxiliary audio capture, verify that captured audio is faithful to the source within margin of error                                                                                              | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 2              | | 5   | Combined data capture  | Play reference streams simultaneously for primary and auxiliary captures, run primary and auxiliary audio captures, verify that captured audio is faithful to the source within margin of error                                | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1,2            | | 6   | Auxiliary jitter test  | Play a reference stream, run auxiliary audio capture, monitor jitter regularly                                                                                                                                                 | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 2              | | 7   | Combined jitter test   | Play reference streams simultaneously for primary and auxiliary captures, run primary and auxiliary audio captures, monitor jitter regularly                                                                                   | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1,2            |</p>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of rmfAudio L3 Python test cases:</p> <pre><code>---\ntitle: rmfAudio - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- rmfAudioHelperClass : inherits\n    rmfAudioHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; rmfAudio : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for rmfAudio \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>rmfAudio</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"rmf-audio-capture_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file rmfAudioCaptureAuxSupported</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file rmfAudio_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file rmfAudio_testConfig.yml</li> </ul>"},{"location":"rmf-audio-capture_L3_TestProcedure/","title":"RMF Audio Capture HAL L3 Python Test Procedure","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Streams Required</li> <li>Test Cases<ul> <li>rmfAudio_test01_primaryDataCapture.py</li> <li>rmfAudio_test02_primaryJitterTest.py</li> <li>rmfAudio_test03_independentDataCheck.py</li> <li>rmfAudio_test04_auxiliaryDataCapture.py</li> <li>rmfAudio_test05_combinedDataCapture.py</li> <li>rmfAudio_test06_auxiliaryJitterTest.py</li> <li>rmfAudio_test07_combinedJitterTest.py</li> <li>rmfAudio_L3_Runall.py</li> <li>rmfAudio_L3_Runall_primary.py</li> </ul> </li> </ul>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"rmf-audio-capture_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_player Plays the stream required for test case ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"rmf-audio-capture_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file: - Set the folder path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Update <code>streams_download_url</code> with the URL from which the streams will be downloaded - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../profiles/rmfAudioCaptureAuxSupported.yaml\"\n            streams_download_url: \"&lt;URL_Path&gt;\" #URL path from which the streams are downloaded to the device\n</code></pre>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: rmfAudio_L3_testSetup.yml</p> <p>Provide the streams for each test case. This path is appended with <code>streams_download_url</code> entry from Device Configuration File</p> <p>If a test case requires multiple streams or needs to be validated using several streams, ensure that all necessary streams are added sequentially for that specific test case.</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture test setup\"\n  assets:\n    device:\n      test01_primaryDataCapture:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_120s_48k_stereo.wav\"\n        streams:\n          - \"streams/Sin_120s_48k_stereo.wav\"\n      test02_primaryJitterTest:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_120s_48k_stereo.wav\"\n        streams:\n          - \"streams/Sin_120s_48k_stereo.wav\"\n      test03_independentDataCheck:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_10s_48k_stereo.wav\"\n          - \"export INPUT_AUXILIARY=&lt;PATH on Device&gt;/Triangle_10s_480k_stereo.wav\"\n        streams:\n          - \"streams/Sin_10s_48k_stereo.wav\"\n          - \"streams/Triangle_10s_480k_stereo.wav\"\n      test04_auxiliaryDataCapture:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_AUXILIARY=&lt;PATH on Device&gt;/Triangle_10s_480k_stereo.wav\"\n        streams: \n          - \"streams/Triangle_10s_480k_stereo.wav\"\n</code></pre>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: rmfAudio_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p> <pre><code>rmfaudiocapture:\n    description: \"RMF Audio Capture testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre>"},{"location":"rmf-audio-capture_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"rmf-audio-capture_L3_TestProcedure/#streams-required","title":"Streams Required","text":"<p>Refer rmf-audio-capture_L3_Low-Level_TestSpecification.md for the stream details</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test01_primarydatacapturepy","title":"rmfAudio_test01_primaryDataCapture.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Play Stream #1 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test plays a reference stream, captures audio data on primary capture interface and verifies that the captured data matches with reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on primary capture interface and written to a wav output file.</li> <li>Captured audio should match with played reference stream.</li> </ul>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test01_primaryDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary capture interface data Verification:</p> <p>The test will play the designated audio stream and start audio capture on primary capture interface.</p> </li> <li> <p>The test will validate captured audio data with reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data through primary capture interface, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test02_primaryjittertestpy","title":"rmfAudio_test02_primaryJitterTest.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<p>Play Stream #1 and confirm that there is no jitter detected on primary capture interface.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test plays a reference stream, checks bytes of audio data received on primary capture interface and verifies there is no jitter detected on primary capture interface.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test02_primaryJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary capture jitter Verification:</p> <p>The test will play the designated audio stream and start monitoring bytes received on primary capture interface.</p> </li> <li> <p>The test will monitor bytes received on primary audio capture continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on primary data interface, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test03_independentdatacheckpy","title":"rmfAudio_test03_independentDataCheck.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Play Stream #1 and Stream #2 and verify that primary and auxiliary data captures work independent of each other.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test03","title":"Expected Results - test03","text":"<p>The test plays a reference stream each on primary and auxiliary interfaces, then issues a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test03_independentDataCheck.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Independent data check Verification:</p> <p>The test will play the designated audio stream on both primary and auxiliary interfaces and start monitoring bytes received before and after each start and stop call.</p> </li> <li> <p>The test will check bytes received on primary and auxiliary audio capture during series of start and stop calls in a mixed sequence. </p> </li> <li>If bytes captured shows that the captures are independent of each other, the step is marked as PASS.</li> <li> <p>If bytes captured shows that the captures are dependent on each other, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream each on primary and auxiliary interfaces, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured shows that the captures are independent of each other</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test04_auxiliarydatacapturepy","title":"rmfAudio_test04_auxiliaryDataCapture.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>Play Stream #2 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>The test plays a reference stream, captures audio data on auxiliary capture interface and verifies that the captured data matches with reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on auxiliary capture interface and written to a wav output file.</li> <li>Captured audio should match with played reference stream.</li> </ul>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test04_auxiliaryDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Auxiliary capture interface data Verification:</p> <p>The test will play the designated audio stream and start audio capture on auxiliary capture interface.</p> </li> <li> <p>The test will validate captured audio data with reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data through auxiliary capture interface, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test05_combineddatacapturepy","title":"rmfAudio_test05_combinedDataCapture.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test05","title":"User Input Required - test05","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<p>Play Stream #1 and Stream #2 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test05","title":"Expected Results - test05","text":"<p>The test plays a reference stream, captures audio data on both primary and auxiliary capture interfaces and verifies that the captured data matches with corresponding reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on primary and auxiliary capture interfaces simulataneously and written to a wav output file.</li> <li>Captured audio should match with corresponding played reference stream.</li> </ul>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test05_combinedDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Combined audio capture data Verification:</p> <p>The test will play the designated audio streams and start audio capture simulataneously on primary and auxiliary capture interfaces.</p> </li> <li> <p>The test will validate captured audio data with corresponding reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data simultaneously through primary and auxiliary capture interfaces, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test06_auxiliaryjittertestpy","title":"rmfAudio_test06_auxiliaryJitterTest.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test06","title":"User Input Required - test06","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test06","title":"Acceptance Criteria - test06","text":"<p>Play Stream #2 and confirm that there is no jitter detected on auxiliary capture interface.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test06","title":"Expected Results - test06","text":"<p>The test plays a reference stream, checks bytes of audio data received on auxiliary capture interface and verifies there is no jitter detected on auxiliary capture interface.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test06","title":"Test Steps - test06","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test06_auxiliaryJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Auxiliary capture jitter Verification:</p> <p>The test will play the designated audio stream and start monitoring bytes received on auxiliary capture interface.</p> </li> <li> <p>The test will monitor bytes received on auxiliary capture continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on auxiliary capture interface, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_test07_combinedjittertestpy","title":"rmfAudio_test07_combinedJitterTest.py","text":""},{"location":"rmf-audio-capture_L3_TestProcedure/#user-input-required-test07","title":"User Input Required - test07","text":"<p>No</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test07","title":"Acceptance Criteria - test07","text":"<p>Play Stream #1 and Stream #2 and confirm that there is no jitter detected on primary and auxiliary capture interfaces.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#expected-results-test07","title":"Expected Results - test07","text":"<p>The test plays a reference stream, checks bytes of audio data received simulataneously on primary and auxiliary capture interface and verifies there is no jitter detected on both audio capture interfaces.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#test-steps-test07","title":"Test Steps - test07","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test07_combinedJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary and auxiliary combined capture jitter Verification:</p> <p>The test will play the designated audio streams and start monitoring bytes received on primary and auxiliary capture interfaces.</p> </li> <li> <p>The test will monitor bytes received on primary and auxiliary audio captures continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on primary and auxiliary capture interfaces, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_l3_runallpy","title":"rmfAudio_L3_Runall.py","text":"<p>This python file runs all the tests</p> <pre><code>python rmfAudio_L3_Runall.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"rmf-audio-capture_L3_TestProcedure/#rmfaudio_l3_runall_primarypy","title":"rmfAudio_L3_Runall_primary.py","text":"<p>This python file runs all the tests for primary audio capture</p> <pre><code>python rmfAudio_L3_Runall_primary.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"rmf-audio-capture_halSpec/","title":"RMF Audio Capture HAL Documentation","text":""},{"location":"rmf-audio-capture_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operations<ul> <li>Architecture Diagram</li> </ul> </li> <li>Diagrams<ul> <li>Operational call sequence</li> <li>State machine diagram</li> </ul> </li> </ul>"},{"location":"rmf-audio-capture_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>    - Application Programming Interface</li> <li><code>HAL</code>    - Hardware Abstraction layer</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>RDK</code>    - Reference Development Kit</li> <li><code>RMF</code>    - RDK Media Framework</li> <li><code>STB</code>    - Set Top Box</li> <li><code>Caller</code> - Any user of the interface</li> </ul>"},{"location":"rmf-audio-capture_halSpec/#description","title":"Description","text":"<p>RMF Audio Capture <code>HAL</code> must deliver a constant stream of raw audio data (<code>PCM</code>) to the <code>caller</code>. The purpose of audio capture is to tap the final mix of the decoded audio. The audio data delivered via this interface is required to track as closely as possible, i. e., minimal latency, to the audio that's being rendered by the device at a given point of time. Audio Capture must support capture of primary audio, and may optionally support auxiliary audio (alternate language audio tracks etc.) as well. Where auxiliary audio is supported, <code>HAL</code> must be able to support concurrent capture sessions for both primary and auxiliary audio. However, <code>caller</code> will not seek to open more than one instance of a capture per source at any point of time.</p> <p>Should a situation arise where there is no audio data available to capture (eg: no active video playback), <code>HAL</code> must continue to send buffers to caller that are filled with silence. <code>HAL</code> must maintain the expected data rate for the format while doing so.</p> <p>As far as audio format support is concerned, <code>HAL</code> is not required to support all formats and sampling rates defined in the header file. However, 16-bit stereo PCM format must be supported at a sampling rate of 44.1kHz or higher.</p> <p></p>"},{"location":"rmf-audio-capture_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>These requirements ensure that the <code>HAL</code> executes correctly within the run-time environment that it will be used in.</p>"},{"location":"rmf-audio-capture_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p>Caller is expected to have complete control over the lifecycle of Audio Capture <code>HAL</code> (from open to close).</p>"},{"location":"rmf-audio-capture_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is required to be thread-safe and will be invoked from multiple <code>caller</code> threads. Data callback <code>RMF_AudioCaptureBufferReadyCb()</code> must originate in a thread that's separate from <code>caller</code> context(s). Caller will not make any <code>HAL</code> calls in the context of <code>RMF_AudioCaptureBufferReadyCb()</code> and <code>RMF_AudioCapture_StatusChangeCb()</code>.</p>"},{"location":"rmf-audio-capture_halSpec/#process-model","title":"Process Model","text":"<p>Caller will take care of Audio Capture <code>HAL</code> initialization. The interface is expected to support a single instantiation with a single process.</p>"},{"location":"rmf-audio-capture_halSpec/#memory-model","title":"Memory Model","text":"<p>Audio Capture <code>HAL</code> is responsible for its own memory management. The buffer used for audio data passed by <code>RMF_AudioCaptureBufferReadyCb()</code> must be managed after the callback returns.</p>"},{"location":"rmf-audio-capture_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to be involved in any power management funtionality.</p>"},{"location":"rmf-audio-capture_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>No asynchronous notification is required.</p>"},{"location":"rmf-audio-capture_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>The following callbacks may block depending on the <code>caller's</code> internal operations but will endeavour to return as soon as possible.</p> <ol> <li><code>RMF_AudioCaptureBufferReadyCb()</code></li> <li><code>RMF_AudioCapture_StatusChangeCb()</code></li> </ol>"},{"location":"rmf-audio-capture_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All APIs must return errors synchronously as a return argument. The interface is responsible for managing its internal errors.</p>"},{"location":"rmf-audio-capture_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement to persist any settings information. The necessary parameters will be passed with <code>RMF_AudioCapture_Start()</code> for every audio capture session.</p>"},{"location":"rmf-audio-capture_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements are required to be supported by this interface:</p>"},{"location":"rmf-audio-capture_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"rmf-audio-capture_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to use only minimal memory/CPU resources while in closed/stopped state.</p>"},{"location":"rmf-audio-capture_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"rmf-audio-capture_halSpec/#licensing","title":"Licensing","text":"<p>The Audio Capture header file is released under Apache 2.0 license. The implementation may use any license compatible with the aforementioned header file.</p>"},{"location":"rmf-audio-capture_halSpec/#build-requirements","title":"Build Requirements","text":"<p>This interface is required to build into shared library. The shared library must be named <code>librmfAudioCapture.so</code>. The building mechanism must be independent of Yocto.</p>"},{"location":"rmf-audio-capture_halSpec/#variability-management","title":"Variability Management","text":"<p>Any new <code>API</code> introduced must be implemented by all the 3rd party modules. Currently there is little to no variability expected across various implementations. Any change to the interface must be reviewed and approved by component architects and owners.</p>"},{"location":"rmf-audio-capture_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The default settings returned via <code>RMF_AudioCapture_GetDefaultSettings()</code> will be configured with parameters that are favourable to the implementation. The <code>caller</code> will typically not change any of these parameters unless strictly necessary.</p>"},{"location":"rmf-audio-capture_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation is provided via doxygen comments in the header file.</p>"},{"location":"rmf-audio-capture_halSpec/#theory-of-operations","title":"Theory of operations","text":"<p><code>Caller</code> will configure Audio Capture interface with the necessary settings and start the capture. <code>HAL</code> will deliver audio and status updates via the registered callbacks in a timely fashion. Calling <code>RMF_AudioCapture_Open()</code> is a necessary precondition for the remaining APIs to work.</p>"},{"location":"rmf-audio-capture_halSpec/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart\n    D[Caller] --&gt; |control| E[Audio Capture HAL]\n    E --&gt; |audio data| D\n ```\n\nFollowing is a typical sequence of operation:\n1. Open the interface using `RMF_AudioCapture_Open()` or `RMF_AudioCapture_Open_Type()`.\n2. Get default settings using `RMF_AudioCapture_GetDefaultSettings()`. This returns a struct of parameters favourable to the `HAL`. Application may tweak certain members of this struct and pass it with the start call.\n3. Start audio capture using `RMF_AudioCapture_Start()`. The interface will continuously deliver audio data to `caller` in real time via callback `RMF_AudioCaptureBufferReadyCb()`.\n4. When the audio stream is no longer needed, stop audio capture using `RMF_AudioCapture_Stop()`. This will stop the 'HAL' callbacks.\n5. Close the interface using `RMF_AudioCapture_Close()`.\n\n### Diagrams\n\n#### Operational call sequence\n\n\n```mermaid\n   sequenceDiagram\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Open()/RMF_AudioCapture_Open_Type()\n    activate HAL\n    HAL--&gt;&gt;caller: handle\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_GetDefaultSettings()\n    activate HAL\n    HAL--&gt;&gt;caller: default settings\n    deactivate HAL\n    caller-&gt;&gt;caller: generate settings from default settings\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Start(handle, settings)\n    activate HAL\n    loop as long as stop is not called\n    HAL-&gt;&gt;caller:RMF_AudioCaptureBufferReadyCb(audio buffer)\n    activate caller\n    caller-&gt;&gt;caller:consume buffer\n    caller--&gt;&gt;HAL: return\n    deactivate caller\n    end\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Stop(handle)\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Close(handle\n ```\n\n#### State machine Diagram\n\n\n```mermaid\nstateDiagram-v2\n    [*] --&gt; Open: Open()\n    Open --&gt; Started: Start()\n    Started: Started\\n(pumping data)\n    Started --&gt; Open: Stop()\n    Open --&gt; Closed: Close()\n    Closed --&gt; [*]</code></pre>"},{"location":"rmf_audio_capture/","title":"RMF Audio Capture HAL Documentation","text":""},{"location":"rmf_audio_capture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operations<ul> <li>Architecture Diagram</li> </ul> </li> <li>Diagrams<ul> <li>Operational call sequence</li> <li>State machine diagram</li> </ul> </li> </ul>"},{"location":"rmf_audio_capture/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>    - Application Programming Interface</li> <li><code>HAL</code>    - Hardware Abstraction layer</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>RDK</code>    - Reference Development Kit</li> <li><code>RMF</code>    - RDK Media Framework</li> <li><code>STB</code>    - Set Top Box</li> <li><code>Caller</code> - Any user of the interface</li> </ul>"},{"location":"rmf_audio_capture/#description","title":"Description","text":"<p>RMF Audio Capture <code>HAL</code> must deliver a constant stream of raw audio data (<code>PCM</code>) to the <code>caller</code>. The purpose of audio capture is to tap the final mix of the decoded audio. The audio data delivered via this interface is required to track as closely as possible, i. e., minimal latency, to the audio that's being rendered by the device at a given point of time. Audio Capture must support capture of primary audio, and may optionally support auxiliary audio (alternate language audio tracks etc.) as well. Where auxiliary audio is supported, <code>HAL</code> must be able to support concurrent capture sessions for both primary and auxiliary audio. However, <code>caller</code> will not seek to open more than one instance of a capture per source at any point of time.</p> <p>Should a situation arise where there is no audio data available to capture (eg: no active video playback), <code>HAL</code> must continue to send buffers to caller that are filled with silence. <code>HAL</code> must maintain the expected data rate for the format while doing so.</p> <p>As far as audio format support is concerned, <code>HAL</code> is not required to support all formats and sampling rates defined in the header file. However, 16-bit stereo PCM format must be supported at a sampling rate of 44.1kHz or higher.</p> <p></p>"},{"location":"rmf_audio_capture/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>These requirements ensure that the <code>HAL</code> executes correctly within the run-time environment that it will be used in.</p>"},{"location":"rmf_audio_capture/#initialization-and-startup","title":"Initialization and Startup","text":"<p>Caller is expected to have complete control over the lifecycle of Audio Capture <code>HAL</code> (from open to close).</p>"},{"location":"rmf_audio_capture/#threading-model","title":"Threading Model","text":"<p>This interface is required to be thread-safe and will be invoked from multiple <code>caller</code> threads. Data callback <code>RMF_AudioCaptureBufferReadyCb()</code> must originate in a thread that's separate from <code>caller</code> context(s). Caller will not make any <code>HAL</code> calls in the context of <code>RMF_AudioCaptureBufferReadyCb()</code> and <code>RMF_AudioCapture_StatusChangeCb()</code>.</p>"},{"location":"rmf_audio_capture/#process-model","title":"Process Model","text":"<p>Caller will take care of Audio Capture <code>HAL</code> initialization. The interface is expected to support a single instantiation with a single process.</p>"},{"location":"rmf_audio_capture/#memory-model","title":"Memory Model","text":"<p>Audio Capture <code>HAL</code> is responsible for its own memory management. The buffer used for audio data passed by <code>RMF_AudioCaptureBufferReadyCb()</code> must be managed after the callback returns.</p>"},{"location":"rmf_audio_capture/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to be involved in any power management funtionality.</p>"},{"location":"rmf_audio_capture/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>No asynchronous notification is required.</p>"},{"location":"rmf_audio_capture/#blocking-calls","title":"Blocking calls","text":"<p>The following callbacks may block depending on the <code>caller's</code> internal operations but will endeavour to return as soon as possible.</p> <ol> <li><code>RMF_AudioCaptureBufferReadyCb()</code></li> <li><code>RMF_AudioCapture_StatusChangeCb()</code></li> </ol>"},{"location":"rmf_audio_capture/#internal-error-handling","title":"Internal Error Handling","text":"<p>All APIs must return errors synchronously as a return argument. The interface is responsible for managing its internal errors.</p>"},{"location":"rmf_audio_capture/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement to persist any settings information. The necessary parameters will be passed with <code>RMF_AudioCapture_Start()</code> for every audio capture session.</p>"},{"location":"rmf_audio_capture/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements are required to be supported by this interface:</p>"},{"location":"rmf_audio_capture/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"rmf_audio_capture/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to use only minimal memory/CPU resources while in closed/stopped state.</p>"},{"location":"rmf_audio_capture/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"rmf_audio_capture/#licensing","title":"Licensing","text":"<p>The Audio Capture header file is released under Apache 2.0 license. The implementation may use any license compatible with the aforementioned header file.</p>"},{"location":"rmf_audio_capture/#build-requirements","title":"Build Requirements","text":"<p>This interface is required to build into shared library. The shared library must be named <code>librmfAudioCapture.so</code>. The building mechanism must be independent of Yocto.</p>"},{"location":"rmf_audio_capture/#variability-management","title":"Variability Management","text":"<p>Any new <code>API</code> introduced must be implemented by all the 3rd party modules. Currently there is little to no variability expected across various implementations. Any change to the interface must be reviewed and approved by component architects and owners.</p>"},{"location":"rmf_audio_capture/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The default settings returned via <code>RMF_AudioCapture_GetDefaultSettings()</code> will be configured with parameters that are favourable to the implementation. The <code>caller</code> will typically not change any of these parameters unless strictly necessary.</p>"},{"location":"rmf_audio_capture/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation is provided via doxygen comments in the header file.</p>"},{"location":"rmf_audio_capture/#theory-of-operations","title":"Theory of operations","text":"<p><code>Caller</code> will configure Audio Capture interface with the necessary settings and start the capture. <code>HAL</code> will deliver audio and status updates via the registered callbacks in a timely fashion. Calling <code>RMF_AudioCapture_Open()</code> is a necessary precondition for the remaining APIs to work.</p>"},{"location":"rmf_audio_capture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart\n    D[Caller] --&gt; |control| E[Audio Capture HAL]\n    E --&gt; |audio data| D\n ```\n\nFollowing is a typical sequence of operation:\n1. Open the interface using `RMF_AudioCapture_Open()` or `RMF_AudioCapture_Open_Type()`.\n2. Get default settings using `RMF_AudioCapture_GetDefaultSettings()`. This returns a struct of parameters favourable to the `HAL`. Application may tweak certain members of this struct and pass it with the start call.\n3. Start audio capture using `RMF_AudioCapture_Start()`. The interface will continuously deliver audio data to `caller` in real time via callback `RMF_AudioCaptureBufferReadyCb()`.\n4. When the audio stream is no longer needed, stop audio capture using `RMF_AudioCapture_Stop()`. This will stop the 'HAL' callbacks.\n5. Close the interface using `RMF_AudioCapture_Close()`.\n\n### Diagrams\n\n#### Operational call sequence\n\n\n```mermaid\n   sequenceDiagram\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Open()/RMF_AudioCapture_Open_Type()\n    activate HAL\n    HAL--&gt;&gt;caller: handle\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_GetDefaultSettings()\n    activate HAL\n    HAL--&gt;&gt;caller: default settings\n    deactivate HAL\n    caller-&gt;&gt;caller: generate settings from default settings\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Start(handle, settings)\n    activate HAL\n    loop as long as stop is not called\n    HAL-&gt;&gt;caller:RMF_AudioCaptureBufferReadyCb(audio buffer)\n    activate caller\n    caller-&gt;&gt;caller:consume buffer\n    caller--&gt;&gt;HAL: return\n    deactivate caller\n    end\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Stop(handle)\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Close(handle\n ```\n\n#### State machine Diagram\n\n\n```mermaid\nstateDiagram-v2\n    [*] --&gt; Open: Open()\n    Open --&gt; Started: Start()\n    Started: Started\\n(pumping data)\n    Started --&gt; Open: Stop()\n    Open --&gt; Closed: Close()\n    Closed --&gt; [*]</code></pre>"},{"location":"rmf_audio_capture/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"rmf_audio_capture/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"rmf_audio_capture/CHANGELOG/#105","title":"1.0.5","text":"<ul> <li>gh #6 HAL spec updates following review <code>#7</code></li> <li>RDK-51275: HAL spec updates following review <code>26840a6</code></li> <li>Merge tag '1.0.4' into develop <code>92e29fa</code></li> </ul>"},{"location":"rmf_audio_capture/CHANGELOG/#104","title":"1.0.4","text":"<p>23 November 2023</p> <ul> <li>baseline version <code>a70dca8</code></li> <li>Added CHANGELOG.md - 1.0.4 <code>b51c356</code></li> <li>Initial commit <code>74f0003</code></li> </ul>"},{"location":"rmf_audio_capture/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"rmf_audio_capture/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"rmf_audio_capture/docs/pages/LICENSE/","title":"LICENSE","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"rmf_audio_capture/docs/pages/NOTICE/","title":"NOTICE","text":"<p>This component contains software that is Copyright (c) 2023 RDK Management. The component is licensed to you under the Apache License, Version 2.0 (the \"License\"). You may not use the component except in compliance with the License.</p> <p>The component may include material which is licensed under other licenses / copyrights as listed below.  Your use of this material within the component is also subject to the terms and conditions of these licenses.  The LICENSE file contains the text of all the licenses which apply within this component.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/","title":"RMF Audio Capture HAL Documentation","text":""},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Component Runtime Execution Requirements</li> <li>Initialization and Startup</li> <li>Threading Model</li> <li>Process Model</li> <li>Memory Model</li> <li>Power Management Requirements</li> <li>Asynchronous Notification Model</li> <li>Blocking calls</li> <li>Internal Error Handling</li> <li>Persistence Model</li> <li>Non-functional requirements</li> <li>Logging and debugging requirements</li> <li>Memory and performance requirements</li> <li>Quality Control</li> <li>Licensing</li> <li>Build Requirements</li> <li>Variability Management</li> <li>Platform or Product Customization</li> <li>Interface API Documentation</li> <li>Theory of operations<ul> <li>Architecture Diagram</li> </ul> </li> <li>Diagrams<ul> <li>Operational call sequence</li> <li>State machine diagram</li> </ul> </li> </ul>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>API</code>    - Application Programming Interface</li> <li><code>HAL</code>    - Hardware Abstraction layer</li> <li><code>PCM</code>    - Pulse Code Modulation</li> <li><code>RDK</code>    - Reference Development Kit</li> <li><code>RMF</code>    - RDK Media Framework</li> <li><code>STB</code>    - Set Top Box</li> <li><code>Caller</code> - Any user of the interface</li> </ul>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#description","title":"Description","text":"<p>RMF Audio Capture <code>HAL</code> must deliver a constant stream of raw audio data (<code>PCM</code>) to the <code>caller</code>. The purpose of audio capture is to tap the final mix of the decoded audio. The audio data delivered via this interface is required to track as closely as possible, i. e., minimal latency, to the audio that's being rendered by the device at a given point of time. Audio Capture must support capture of primary audio, and may optionally support auxiliary audio (alternate language audio tracks etc.) as well. Where auxiliary audio is supported, <code>HAL</code> must be able to support concurrent capture sessions for both primary and auxiliary audio. However, <code>caller</code> will not seek to open more than one instance of a capture per source at any point of time.</p> <p>Should a situation arise where there is no audio data available to capture (eg: no active video playback), <code>HAL</code> must continue to send buffers to caller that are filled with silence. <code>HAL</code> must maintain the expected data rate for the format while doing so.</p> <p>As far as audio format support is concerned, <code>HAL</code> is not required to support all formats and sampling rates defined in the header file. However, 16-bit stereo PCM format must be supported at a sampling rate of 44.1kHz or higher.</p> <p></p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#component-runtime-execution-requirements","title":"Component Runtime Execution Requirements","text":"<p>These requirements ensure that the <code>HAL</code> executes correctly within the run-time environment that it will be used in.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#initialization-and-startup","title":"Initialization and Startup","text":"<p>Caller is expected to have complete control over the lifecycle of Audio Capture <code>HAL</code> (from open to close).</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#threading-model","title":"Threading Model","text":"<p>This interface is required to be thread-safe and will be invoked from multiple <code>caller</code> threads. Data callback <code>RMF_AudioCaptureBufferReadyCb()</code> must originate in a thread that's separate from <code>caller</code> context(s). Caller will not make any <code>HAL</code> calls in the context of <code>RMF_AudioCaptureBufferReadyCb()</code> and <code>RMF_AudioCapture_StatusChangeCb()</code>.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#process-model","title":"Process Model","text":"<p>Caller will take care of Audio Capture <code>HAL</code> initialization. The interface is expected to support a single instantiation with a single process.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#memory-model","title":"Memory Model","text":"<p>Audio Capture <code>HAL</code> is responsible for its own memory management. The buffer used for audio data passed by <code>RMF_AudioCaptureBufferReadyCb()</code> must be managed after the callback returns.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#power-management-requirements","title":"Power Management Requirements","text":"<p>This interface is not required to be involved in any power management funtionality.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#asynchronous-notification-model","title":"Asynchronous Notification Model","text":"<p>No asynchronous notification is required.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#blocking-calls","title":"Blocking calls","text":"<p>The following callbacks may block depending on the <code>caller's</code> internal operations but will endeavour to return as soon as possible.</p> <ol> <li><code>RMF_AudioCaptureBufferReadyCb()</code></li> <li><code>RMF_AudioCapture_StatusChangeCb()</code></li> </ol>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#internal-error-handling","title":"Internal Error Handling","text":"<p>All APIs must return errors synchronously as a return argument. The interface is responsible for managing its internal errors.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#persistence-model","title":"Persistence Model","text":"<p>There is no requirement to persist any settings information. The necessary parameters will be passed with <code>RMF_AudioCapture_Start()</code> for every audio capture session.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#non-functional-requirements","title":"Non-functional requirements","text":"<p>The following non-functional requirements are required to be supported by this interface:</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#logging-and-debugging-requirements","title":"Logging and debugging requirements","text":"<p>This interface is required to support DEBUG, INFO and ERROR messages. DEBUG is required to be disabled by default and enabled when needed.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#memory-and-performance-requirements","title":"Memory and performance requirements","text":"<p>This interface is required to use only minimal memory/CPU resources while in closed/stopped state.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#quality-control","title":"Quality Control","text":"<ul> <li>This interface is required to perform static analysis, our preferred tool is Coverity.</li> <li>Have a zero-warning policy with regards to compiling. All warnings are required to be treated as errors.</li> <li>Copyright validation is required to be performed e.g.: Black duck, FossID.</li> <li>Use of memory analysis tools like Valgrind are encouraged to identify leaks/corruptions.</li> <li><code>HAL</code> Tests will endeavour to create worst case scenarios to assist investigations.</li> <li>Improvements by any party to the testing suite are required to be fed back.</li> </ul>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#licensing","title":"Licensing","text":"<p>The Audio Capture header file is released under Apache 2.0 license. The implementation may use any license compatible with the aforementioned header file.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#build-requirements","title":"Build Requirements","text":"<p>This interface is required to build into shared library. The shared library must be named <code>librmfAudioCapture.so</code>. The building mechanism must be independent of Yocto.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#variability-management","title":"Variability Management","text":"<p>Any new <code>API</code> introduced must be implemented by all the 3rd party modules. Currently there is little to no variability expected across various implementations. Any change to the interface must be reviewed and approved by component architects and owners.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#platform-or-product-customization","title":"Platform or Product Customization","text":"<p>The default settings returned via <code>RMF_AudioCapture_GetDefaultSettings()</code> will be configured with parameters that are favourable to the implementation. The <code>caller</code> will typically not change any of these parameters unless strictly necessary.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#interface-api-documentation","title":"Interface API Documentation","text":"<p><code>API</code> documentation is provided via doxygen comments in the header file.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#theory-of-operations","title":"Theory of operations","text":"<p><code>Caller</code> will configure Audio Capture interface with the necessary settings and start the capture. <code>HAL</code> will deliver audio and status updates via the registered callbacks in a timely fashion. Calling <code>RMF_AudioCapture_Open()</code> is a necessary precondition for the remaining APIs to work.</p>"},{"location":"rmf_audio_capture/docs/pages/rmf-audio-capture_halSpec/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart\n    D[Caller] --&gt; |control| E[Audio Capture HAL]\n    E --&gt; |audio data| D\n ```\n\nFollowing is a typical sequence of operation:\n1. Open the interface using `RMF_AudioCapture_Open()` or `RMF_AudioCapture_Open_Type()`.\n2. Get default settings using `RMF_AudioCapture_GetDefaultSettings()`. This returns a struct of parameters favourable to the `HAL`. Application may tweak certain members of this struct and pass it with the start call.\n3. Start audio capture using `RMF_AudioCapture_Start()`. The interface will continuously deliver audio data to `caller` in real time via callback `RMF_AudioCaptureBufferReadyCb()`.\n4. When the audio stream is no longer needed, stop audio capture using `RMF_AudioCapture_Stop()`. This will stop the 'HAL' callbacks.\n5. Close the interface using `RMF_AudioCapture_Close()`.\n\n### Diagrams\n\n#### Operational call sequence\n\n\n```mermaid\n   sequenceDiagram\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Open()/RMF_AudioCapture_Open_Type()\n    activate HAL\n    HAL--&gt;&gt;caller: handle\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_GetDefaultSettings()\n    activate HAL\n    HAL--&gt;&gt;caller: default settings\n    deactivate HAL\n    caller-&gt;&gt;caller: generate settings from default settings\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Start(handle, settings)\n    activate HAL\n    loop as long as stop is not called\n    HAL-&gt;&gt;caller:RMF_AudioCaptureBufferReadyCb(audio buffer)\n    activate caller\n    caller-&gt;&gt;caller:consume buffer\n    caller--&gt;&gt;HAL: return\n    deactivate caller\n    end\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Stop(handle)\n    deactivate HAL\n    caller-&gt;&gt;HAL: RMF_AudioCapture_Close(handle\n ```\n\n#### State machine Diagram\n\n\n```mermaid\nstateDiagram-v2\n    [*] --&gt; Open: Open()\n    Open --&gt; Started: Start()\n    Started: Started\\n(pumping data)\n    Started --&gt; Open: Stop()\n    Open --&gt; Closed: Close()\n    Closed --&gt; [*]</code></pre>"},{"location":"rmf_audio_capture_test/","title":"Unit Testing Suite For RMF Audio Capture HAL","text":""},{"location":"rmf_audio_capture_test/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Description</li> <li>Reference Documents</li> <li>How to build the test suite</li> <li>Notes</li> <li>Manual way of running the L1 and L2 test cases</li> <li>Setting Python environment for running the L1 L2 and L3 automation test cases</li> </ul>"},{"location":"rmf_audio_capture_test/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>L1</code> - Functional Tests</li> <li><code>L2</code> - Module functional Testing</li> <li><code>L3</code> - Module testing with External Stimulus is required to validate and control device</li> <li><code>HAL</code>- Hardware Abstraction Layer</li> <li><code>High-Level Test Specification</code> : These specification will provide a broad overview of the system's functionality from the callers' perspective. It focuses on major use cases, system behavior, and overall caller experience.</li> <li><code>Low-Level Test Specification</code> : These specification will deeper into the technical details. They will define specific test cases with inputs, expected outputs, and pass/fail criteria for individual functionalities, modules, or APIs.</li> </ul>"},{"location":"rmf_audio_capture_test/#description","title":"Description","text":"<p>This repository contains the Unit Test Suites(<code>L1</code> , <code>L2</code> and <code>L3</code>) for RMF Audio Capture <code>HAL</code>.</p>"},{"location":"rmf_audio_capture_test/#reference-documents","title":"Reference Documents","text":"SNo Document Name Document Description Document Link 1 <code>HAL</code> Specification Document This document provides specific information on the APIs for which tests are written in this module rmf-audio-capture_halSpec.md 2 High Level Test Specification Document High Level Test Specification Documentation this module rmf-audio-capture_High-Level_TestSpec.md 3 <code>L2</code> Low Level Test Specification Document <code>L2</code>Low Level Test Specification Documentation this module rmf-audio-capture_L2-Low-Level_TestSpecification.md 4 <code>L1</code> and <code>L2</code> Test Procedure Document <code>L1</code> and <code>L2</code> Test Procedure Document rmf-audio-capture_L1_L2_TestProcedure.md 5 <code>L3</code> Low Level Test Specification Document <code>L3</code>Low Level Test Specification Documentation this module rmf-audio-capture_L3_Low-Level_TestSpecification.md 6 <code>L3</code> Low Level Test Procedure Document <code>L3</code>Low Level Test Procedure Documentation this module rmf-audio-capture_L3_TestProcedure.md"},{"location":"rmf_audio_capture_test/#notes","title":"Notes","text":"<ul> <li>All APIs need to be implemented in this current version. If any API is not supported, please add stub implementation with return type RMF_SUCCESS for the same.</li> <li>Building against the actual library may introduce SOC dependencies. Hence, a template SKELETON library is created without SOC dependencies. On the real platform (target), it can be mounted, copied and bound with the actual library.</li> <li>When executing the binary, ensure to include a platform-specific profile file as an argument for the designated test cases. The following example illustrates this:</li> </ul>"},{"location":"rmf_audio_capture_test/#how-to-build-the-test-suite","title":"How to build the test suite","text":"<p>In order to build the test suits, there is a requirement to supply the toolchain, either as a vendor independent toolchain, an SDK, or an RDK Docker Toolchain .</p> <p>For more information about RDK Docker Toolchain, please check RDK Docker Toolchain</p> <ul> <li>Export the Toolchain Path:</li> </ul> <pre><code>export TOOLCHAIN_PATH=/opt/toolchains/rdk-glibc-x86_64/sysroots/armv7at2hf-neon-rdk-linux-gnueabi\nexport CC=\"arm-rdk-linux-gnueabi-gcc  -march=armv7-a -mthumb -mfpu=neon -mfloat-abi=hard --sysroot=$TOOLCHAIN_PATH\"\n</code></pre> <ul> <li>Clone the <code>HAL</code> Repository:</li> </ul> <pre><code>git clone git@github.com:rdkcentral/rdk-halif-rmf_audio_capture.git\n</code></pre> <ul> <li>Set Project Version:</li> </ul> <p>If you want to build the test repository with a specific tag or branch, set the UT_PROJECT_VERSION variable accordingly. If not set, the default main branch will be used.</p> <pre><code>export UT_PROJECT_VERSION=1.0.1  # Build using a specific tag\n</code></pre> <p>or</p> <pre><code>export UT_PROJECT_VERSION=develop  # Build using a specific branch\n</code></pre> <ul> <li>Build Targets:</li> </ul> <p>There are two targets for the platform</p> <ol> <li>linux - (default)</li> <li>arm - TARGET=arm</li> </ol> <pre><code>build_ut.sh TARGET=arm\n</code></pre> <ul> <li><code>build_ut.sh</code> script will clone the hal-test repo, ut-core and generate a <code>hal_test_rmfAudioCapture</code> binary in <code>ut/bin/</code> upon successful completion.</li> </ul>"},{"location":"rmf_audio_capture_test/#manual-way-of-running-the-l1-and-l2-test-cases","title":"Manual way of running the <code>L1</code> and <code>L2</code> test cases","text":"<p><code>bash  ./hal_test_rmfAudioCapture -p rmfAudioCaptureAuxSupported.yaml</code></p> <p>Alternatively, use the run.sh script with the profile file:</p> <p><code>bash ./run.sh -p /absolute/path/to/profile/file</code></p> <ul> <li>Profile files define the configuration for the platform available here at aux supported and  aux not supported</li> </ul>"},{"location":"rmf_audio_capture_test/#setting-python-environment-for-running-the-l1-l2-and-l3-automation-test-cases","title":"Setting Python environment for running the <code>L1</code> <code>L2</code> and <code>L3</code> automation test cases","text":"<ul> <li>For running the <code>L1</code> <code>L2</code> and <code>L3</code> test suite, a host PC or server with a Python environment is required.</li> <li>Install Python Environment and Activation Scripts as detailed in the HPK Documentation</li> <li>To run the <code>L1</code> <code>L2</code> test cases follow the rmf-audio-capture_L1_L2_TestProcedure.md</li> <li>To run the <code>L3</code> test cases follow the rmf-audio-capture_L3_TestProcedure.md</li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"rmf_audio_capture_test/CHANGELOG/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. Dates are displayed in UTC.</p> <p>Generated by <code>auto-changelog</code>.</p>"},{"location":"rmf_audio_capture_test/CHANGELOG/#154","title":"1.5.4","text":"<ul> <li>Document: gh #55 update doc issues <code>#56</code></li> <li>Main to Develop <code>#52</code></li> <li>gh #55 Update README.md <code>04dd697</code></li> <li>gh #55 updated as per sugession <code>0f6e032</code></li> <li>gh #55 minor changes <code>dc00e4b</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#153","title":"1.5.3","text":"<p>14 May 2025</p> <ul> <li>Release/1.5.3 <code>#51</code></li> <li> </li> <li>Bumped CHANGELOG.md - 1.5.3 <code>965f8f2</code></li> <li>gh #49 increase the timeout value <code>f661f65</code></li> <li>Merge tag '1.5.2' into develop <code>ea2753a</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#49-l2-fail-through-python-run-50","title":"49 l2 fail through python run <code>#50</code>","text":""},{"location":"rmf_audio_capture_test/CHANGELOG/#152","title":"1.5.2","text":"<p>7 April 2025</p> <ul> <li>issue #47 utcore version mismatch <code>#48</code></li> <li>Bumped CHANGELOG.md - 1.5.2 <code>27953fb</code></li> <li>gh #47 Update build.sh <code>6721901</code></li> <li>Merge tag '1.5.1' into develop <code>fc0382c</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#151","title":"1.5.1","text":"<p>4 April 2025</p> <ul> <li>gh #45 uncomment cases testsetupfile <code>#46</code></li> <li>gh #45 uncommented L1 L2 cases <code>d789feb</code></li> <li>Bumped CHANGELOG.md - 1.5.1 <code>acd8cff</code></li> <li>Merge tag '1.5.0' into develop <code>cb512a9</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#150","title":"1.5.0","text":"<p>1 April 2025</p> <ul> <li>gh #40 update utraft, python raft and read me version <code>#43</code></li> <li>gh #41: support for step result dump <code>#42</code></li> <li>gh #35 l1 l2 null handle check <code>#37</code></li> <li>gh #38 added changes for automation of L1 and L2 <code>#39</code></li> <li>gh #34 Tag Version Banner Print <code>#36</code></li> <li>gh #29 Update hal_test_binary <code>#30</code></li> <li>gh #31 update in read line for case mismatch <code>#32</code></li> <li>gh #27 Update make file with remove skeletons bin export TARGET_EXEC <code>#28</code></li> <li>issue #25 missing read line for extendedEnumsSupported <code>#26</code></li> <li>gh #38 test procedure file <code>f8dcfbd</code></li> <li>gh #38 addressed review comments <code>f6151a5</code></li> <li>gh #35 L1 for null handle check <code>59bc649</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#140","title":"1.4.0","text":"<p>27 November 2024</p> <ul> <li>gh #23 L3 tests python implementation <code>#24</code></li> <li>gh #20 L3 C- tests implementation <code>#21</code></li> <li>Add .gitattributes for line ending normalization <code>58f1510</code></li> <li>Adding python tests for L3 <code>fff4607</code></li> <li>Updated menu to list individual APIs as per review comments <code>98ab359</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#131","title":"1.3.1","text":"<p>13 August 2024</p> <ul> <li>gh #18 Update run.sh script &amp; README.md <code>#19</code></li> <li>Bumped CHANGELOG.md - 1.3.1 <code>7fdfe70</code></li> <li>Merge tag '1.3.0' into develop <code>23980f5</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#130","title":"1.3.0","text":"<p>9 August 2024</p> <ul> <li>gh #16 build error update <code>#17</code></li> <li>gh #14 L1 code clean up <code>#15</code></li> <li>gh# 9 L1 test profile improvement <code>#13</code></li> <li>gh #11 l2 interface update <code>#12</code></li> <li>gh #14 code cleanup <code>0c0f0aa</code></li> <li>gh #108 addressed comments <code>45bfde3</code></li> <li>gh #14 updated changes <code>24a0b07</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#120","title":"1.2.0","text":"<p>17 July 2024</p> <ul> <li>gh #3 High level, Low level Spec &amp; L2 code <code>#4</code></li> <li>gh #3 RDK-51420: Updated L2 test spec and implementation <code>f4b9ae8</code></li> <li>gh #3 Added image and Updated comments <code>467d0ca</code></li> <li>gh #3 removed unnecessary docs &amp; updated readme <code>65fc3c5</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#110","title":"1.1.0","text":"<p>5 June 2024</p> <ul> <li>gh #7 rmf_audio: enhanced error code Macro implementation <code>#8</code></li> <li>gh #7 adress review comment <code>ba738bf</code></li> <li>update for adding the MACRO for enhance code <code>f5b3312</code></li> <li>gh #7 update to fix review comments <code>ddeff81</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#104","title":"1.0.4","text":"<p>20 February 2024</p> <ul> <li>Bumped CHANGELOG.md - 1.0.4 <code>da66ce8</code></li> <li>Updated tag version in README.md <code>9c5bd19</code></li> <li>Merge tag '1.0.3' into develop <code>d13bed1</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#103","title":"1.0.3","text":"<p>29 January 2024</p> <ul> <li>gh #1 updated ut version 2 in build.sh and change UT_ASSERT_EQUAL_NOT_FATAL to UT_ASSERT_EQUAL <code>03bf24b</code></li> <li>Bumped CHANGELOG.md - 1.0.3 <code>74e3ad4</code></li> <li>Merge tag '1.0.2' into develop <code>7def399</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#102","title":"1.0.2","text":"<p>12 December 2023</p> <ul> <li>Bumped CHANGELOG.md - 1.0.2 <code>4391f0f</code></li> <li>Updated README.md with hal &amp; haltest supported version <code>b0f5bea</code></li> <li>Merge tag '1.0.1' into develop <code>f3d6dc5</code></li> </ul>"},{"location":"rmf_audio_capture_test/CHANGELOG/#101","title":"1.0.1","text":"<p>29 November 2023</p> <ul> <li>baseline version <code>c263cc7</code></li> <li>Added CHANGELOG.md - 1.0.1 <code>3a473f1</code></li> <li>Removed L2 template documents' references <code>8f0a404</code></li> </ul>"},{"location":"rmf_audio_capture_test/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/CONTRIBUTING/","title":"Contributing","text":"<ul> <li>If you wish to make code contributions to this project, the source is hosted at github.com/rdkcentral.</li> </ul> <p>You can submit your changes for review via that site, by raising an issue in github, (https://github.com/rdkcentral/xxxx/issues), and following the sequence below.</p> <ul> <li>create a branch with a name follow the guidelines gh(x)_(synopsis)</li> <li>where x is the ticket number</li> <li>where synopsis is a short synopsis for the reason for the branch.</li> <li>create a pull request (https://github.com/rdkcentral/xxxx/compare) when the code changes are ready for review.</li> <li> <p>The team will review, and if accepted your changes will be merged to the mainline.</p> </li> <li> <p>In order to contribute code, first-time users are requested to agree to the license.</p> </li> <li> <p>where <code>xxxx</code> is your module name</p> </li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/","title":"RMF Audio Capture High Level Test Specification Documentation","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Introduction</li> <li>Test Scenarios</li> <li>Check primary audio capture</li> <li>Check auxiliary audio capture</li> <li>Check concurrent audio capture</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code> - Unit Test(s)</li> <li><code>SoC</code> - System on a Chip</li> <li><code>HAL</code> - Hardware Abstraction Layer</li> <li><code>API</code> - Application Programming Interface</li> <li><code>L2</code> - Level2 Testing</li> <li><code>L3</code> - Level3 Testing</li> <li><code>NA</code> - Not Applicable</li> <li><code>Y</code> - Yes</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#introduction","title":"Introduction","text":"<p>This document provides an overview of the testing requirements for the RMF audio capture module. It outlines the scope of testing, objectives, testing levels and approaches, specific test requirements, and expected deliverables.</p> <ul> <li><code>HAL</code> specification is available here: rmf-audio-capture_halSpec.md</li> <li><code>HAL</code> interface is available here: rmfAudioCapture header</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-scenarios","title":"Test Scenarios","text":"# Test Functionality Description 1 Check primary audio capture Run a capture of primary audio for a while and verify delivery of data 2 Check auxiliary audio capture Run a capture of auxiliary audio (on supported devices only) for a while and verify delivery of data 3 Check concurrent audio capture Run parallel captures of primary and auxiliary audio (on supported devices only) and verify delivery of data"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#check-primary-audio-capture","title":"Check primary audio capture","text":"Description HAL APIs L2 L3 Control plane requirements Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run primary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-primary-audio-capture","title":"Test Startup Requirement - Check primary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 tests.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-primary-audio-capture","title":"Emulator Requirements - Check primary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-primary-audio-capture","title":"Control Plane Requirements - Check primary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#check-auxiliary-audio-capture","title":"Check auxiliary audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Run auxiliary audio capture for 10 seconds with known source material and verify that captured audio is faithful to the source within margin of error.Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-auxiliary-audio-capture","title":"Test Startup Requirement - Check auxiliary audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have auxiliary audio track.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-auxiliary-audio-capture","title":"Emulator Requirements - Check auxiliary audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver a known 10-second audio clip (from wav or raw PCM file) when triggered by control plane.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-auxiliary-audio-capture","title":"Control Plane Requirements - Check auxiliary audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#check-concurrent-audio-capture","title":"Check concurrent audio capture","text":"<p>Applicable only on devices that support auxiliary capture.</p> Description HAL APIs L2 L3 Control plane requirements Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples.  Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>Y</code> <code>NA</code> <code>NA</code> Open primary and auxiliary capture interfaces, then issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code> Run auxiliary+primary audio capture for 10 seconds with known source material and verify that captured audio clips are faithful to the source within margin of error. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>Y</code> Run auxiliary+primary audio capture for 2 minutes and verify that a commensurate amount of audio data is delivered. Also verify that jitter low enough to avoid underruns with an application buffer that's half the FIFO size. Note:  read aux support from profile file <code>rmfaudiocapture\\features\\auxsupport</code> RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_GetCurrentSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close <code>NA</code> <code>Y</code> <code>N</code>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#test-startup-requirement-check-concurrent-audio-capture","title":"Test Startup Requirement - Check concurrent audio capture","text":"<ul> <li>Ensure audio is playing in the background before starting L3 test. Test content must have primary as well as auxiliary audio tracks.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#emulator-requirements-check-concurrent-audio-capture","title":"Emulator Requirements - Check concurrent audio capture","text":"<ul> <li>Emulator to implement RMF_AudioCapture HAL that is able to deliver two distinct 10-second audio clips (from wav or raw PCM file) to each capture interface when triggered by control plane. It must be able to drive primary and auxiliary captures concurrently.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_High-Level_TestSpec/#control-plane-requirements-check-concurrent-audio-capture","title":"Control Plane Requirements - Check concurrent audio capture","text":"<ul> <li>Control plane must be able to trigger emulator HAL to deliver a known 10-second audio clip.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/","title":"RMF Audio Capture HAL L1 and L2 Test Procedure","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Run L1 and L2 Test directly (without python)</li> <li>Run L1 and L2 using python</li> <li>Setting Up Test Environment</li> <li>Update Configuration Files</li> <li>Run Test Cases</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L1</code>     - Level 1 Testing</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#run-l1-and-l2-test-directly-without-python","title":"Run L1 and L2 Test directly (without python)","text":"<p>Refer Running L1 and L2 Test suites</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#run-l1-and-l2-using-python","title":"Run L1 and L2 using python","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L1</code> and <code>L2</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Used by raft ssh_hal_test To run the <code>HAL</code> binary <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"http://localhost:8000/\"    # download location for the CPE device\n        httpProxy:   # Local Proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml For more details refer RAFT and example_device_config.yml Update below fields in the device configuration file: - Set the path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../profiles/rmfAudioCaptureAuxSupported.yaml\"\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: rmfAudio_L1_L2_testSetup.yml</p> <p>This <code>yaml</code> contains the list of test_suites and test_cases to run</p> <p>To execute each test_case individually, update the YAML file as shown in the example below:</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture L1 and L2 test setup\"\n  test_suites: # List of L1 and L2 test suites\n    - name: \"L1 rmfAudioCapture\"\n      test_cases:\n        - RMF_Open_Type_primary_L1_pos\n    - name: \"L1 rmfAudioCapture\"\n      test_cases:\n        - RMF_Open_Type_primary_L1_neg\n    - name: \"L1 rmfAudioCapture\"\n      test_cases:\n        - RMF_Open_L1_pos\n</code></pre> <p>To execute all test_cases within a test_suite, update the YAML file as shown in the example below:</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture L1 and L2 test setup\"\n  test_suites: # List of L1 and L2 test suites\n    - name: \"L1 rmfAudioCapture\" # Name of the test suit to run\n      test_cases: # List of test cases to execute, to run all test cases in test suite with R option use `all`\n        - all\n</code></pre> <p>To execute multiple test_suites, update the YAML file as shown in the example below:</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture L1 and L2 test setup\"\n  test_suites: # List of L1 and L2 test suites\n    - name: \"L1 rmfAudioCapture\" # Name of the test suit to run\n      test_cases: # List of test cases to execute, to run all test cases in test suite with R option use `all`\n        - all\n    - name: \"L1 rmfAudioCapture\" # Name of the test suit to run\n      test_cases: \n        - \"RMF_Open_Type_primary_L1_pos\"\n        - \"RMF_Open_Type_primary_L1_neg\"\n        - \"RMF_Open_L1_pos\"\n        - \"RMF_Open_L1_neg\"\n    - name: \"L2 rmfAudioCapture\"\n      test_cases:\n        - \"l2_rmf_primary_data_check\"\n        - \"l2_rmf_auxiliary_data_check\"\n        - \"l2_rmf_combined_data_check\"\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: rmfAudio_testConfig.yml Execute command to run the HAL binary was provided in this file. <pre><code>rmfaudiocapture:\n    description: \"RMF Audio Capture testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre></p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L1_L2_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command <pre><code>python rmfAudio_L1_L2_tests.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre></p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/","title":"RMF AUDIO CAPTURE L2 Low Level Test Specification and Procedure Documentation","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Acronyms, Terms and Abbreviations</li> <li>References</li> <li>Level 2 Test Procedure</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the level 2 testing suite for the RMF AUDIO CAPTURE module.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code> - Hardware Abstraction Layer, may include some common components</li> <li><code>UT</code>  - Unit Test(s)</li> <li><code>OEM</code>  - Original Equipment Manufacture</li> <li><code>SoC</code>  - System on a Chip</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li><code>High Level Test Specification</code> - rmf-audio-capture_High-Level_TestSpec.md</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#level-2-test-procedure","title":"Level 2 Test Procedure","text":"<p>The following functions are expecting to test the module operates correctly.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#test-1","title":"Test 1","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_primary_data_check</code> Description Run primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns Test Group Module : 02 Test Case ID 1 Priority High <p>Pre-Conditions : None</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open()</code> to open interface handle = valid pointer RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings returns RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture settings=default settings from previous step, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, status callback NULL RMF_SUCCESS Should be successful 04 Capture audio for 10 seconds sleep(10) N/A N/A 05 Call <code>RMF_AudioCapture_Stop</code> with handle and set cookie variable to 0 immediately afterwards handle = valid pointer RMF_SUCCESS Should be successful 06 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variable remains 0 N/A cookie=0 Should be successful 07 Call <code>RMF_AudioCapture_Close()</code> to release resources current handle RMF_SUCCESS Should be successful 08 Compare actual total bytes logged by data callback with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_GetDefaultSettings]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|Failure| B1[Test case fail]\n    B --&gt;|RMF_SUCCESS| B2[Call RMF_AudioCapture_Start with settings]\n    B2 --&gt; |Failure| B3[Test case fail]\n    B2 --&gt;|RMF_SUCCESS| C[Wait 10 seconds]\n    C --&gt; D[Call RMF_AudioCapture_Stop, set cookie = 0]\n    D --&gt; DCW{Wait for 1 second. &lt;br&gt; Is cookie = 0?}\n    DCW --&gt; |No| DCF[Test case fail]\n    DCW --&gt; |Yes|E[call RMF_AudioCapture_Close]\n    E --&gt; |Failure| E1[Test case fail]\n    E --&gt;|RMF_SUCCESS| F{Total captured data &lt;br&gt; size comparable to &lt;br&gt; estimated total?}\n    F --&gt;|Yes| G[Test case success]\n    F --&gt;|No| F1[Test case fail]</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#test-2","title":"Test 2","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_auxiliary_data_check</code> Description Run auxiliary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns Test Group Module : 02 Test Case ID 002 Priority High <p>Pre-Conditions : Device must support auxiliary audio capture.</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer, type=auxiliary RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings returns RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture settings=default settings from previous step, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, status callback NULL RMF_SUCCESS Should be successful 04 Capture audio for 10 seconds sleep(10) N/A N/A 05 Call <code>RMF_AudioCapture_Stop</code> with handle and set cookie variable to 0 immediately afterwards handle = valid pointer RMF_SUCCESS Should be successful 06 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variable remains 0 N/A cookie=0 Should be successful 07 Call <code>RMF_AudioCapture_Close()</code> to release resources current handle RMF_SUCCESS Should be successful 08 Compare actual total bytes logged by data callback with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open_Type] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_GetDefaultSettings]\n    A --&gt;|Failure| A1[Test case fail]\n    B --&gt;|Failure| B1[Test case fail]\n    B --&gt;|RMF_SUCCESS| B2[Call RMF_AudioCapture_Start with settings]\n    B2 --&gt; |Failure| B3[Test case fail]\n    B2 --&gt;|RMF_SUCCESS| C[Wait 10 seconds]\n    C --&gt; D[Call RMF_AudioCapture_Stop, set cookie = 0]\n    D --&gt; DCW{Wait for 1 second. &lt;br&gt; Is cookie = 0?}\n    DCW --&gt; |No| DCF[Test case fail]\n    DCW --&gt; |Yes|E[call RMF_AudioCapture_Close]\n    E --&gt; |Failure| E1[Test case fail]\n    E --&gt;|RMF_SUCCESS| F{Total captured data &lt;br&gt; size comparable to &lt;br&gt; estimated total?}\n    F --&gt;|Yes| G[Test case success]\n    F --&gt;|No| F1[Test case fail]</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L2-Low-Level_TestSpecification/#test-3","title":"Test 3","text":"Title Details Function Name <code>test_l2_rmfAudioCapture_combined_data_check</code> Description Run auxiliary+primary audio capture for 10 seconds and verify receipt of commensurate amount of audio samples. Verify that there are no more data ready callbacks issued after the RMF_AudioCapture_Stop returns. Test Group Module : 02 Test Case ID 003 Priority High <p>Pre-Conditions : Device must support auxiliary audio capture.</p> <p>Dependencies : None</p> <p>User Interaction : If user chose to run the test in interactive mode, then the test case has to be selected via console.</p> <p>Test Procedure :</p> Variation / Steps Description Test Data Expected Result Notes 01 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer; type = \"auxiliary\" RMF_SUCCESS Should be successful 02 Call <code>RMF_AudioCapture_Open_Type()</code> to open interface handle = valid pointer; type = \"primary\" RMF_SUCCESS Should be successful 03 Call <code>RMF_AudioCapture_GetDefaultSettings()</code> to get default settings valid settings pointer returns RMF_SUCCESS Should be successful 04 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture handle = primary handle, settings initalized to default settings, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, cbBufferReadyParm = pointer to primary capture context with byte counter and cookie, status callback NULL RMF_SUCCESS Should be successful 05 Call <code>RMF_AudioCapture_Start()</code> with settings obtained above to start audio capture handle = auxiliary handle, settings initalized to default settings, data callback will increment a static byte counter every time it runs. Data callback will also set an atomic int cookie variable to 1 every time it runs, cbBufferReadyParm = pointer to auxiliary capture context with byte counter and cookie, status callback NULL RMF_SUCCESS Should be successful 06 Capture audio for 10 seconds sleep(10) N/A Should be successful 07 Call <code>RMF_AudioCapture_Stop</code> with primary handle and set primary context cookie variable to 0 immediately afterwards handle = primary RMF_SUCCESS Should be successful 08 Call <code>RMF_AudioCapture_Stop</code> with auxiliary handle and set auxiliary context cookie variable to 0 immediately afterwards handle = auxiliary RMF_SUCCESS Should be successful 09 Sleep for 1 second and verify that no more callbacks have arrived by verifying that cookie variables for both primary and auxiliary contexts remain 0 N/A primary and auxiliary cookies = 0 Should be successful 10 Call <code>RMF_AudioCapture_Close()</code> to release resources current primary handle RMF_SUCCESS Should be successful 11 Call <code>RMF_AudioCapture_Close()</code> to release resources current auxiliary handle RMF_SUCCESS Should be successful 12 Compare actual total bytes logged by data callbacks for both primary and auxiliary contexts with expected total. Expected total = 10 * byte-rate computed from audio parameters in default settings byte rate = num. channels * bytes per channel * sampling frequency Actual bytes received must be within 10% margin of error of expected Should be successful <pre><code>flowchart TD\n    A[Call RMF_AudioCapture_Open_Type &lt;br&gt; for primary] --&gt;|RMF_SUCCESS| B[Call RMF_AudioCapture_Open_Type &lt;br&gt; for auxillary]\n    A --&gt;|Fail| A_Fail[Test case fail]\n    B --&gt;|RMF_SUCCESS| C[Call RMF_AudioCapture_GetDefaultSettings]\n    B --&gt;|Fail| B_Fail[Test case fail]\n    C --&gt;|RMF_SUCCESS| D[Modify settings,&lt;br&gt; set cbBufferReady and cbBufferReadyParm for &lt;br&gt; both primary and secondary]\n    C --&gt;|Fail| C_Fail[Test case fail]\n    D --&gt; E[Call RMF_AudioCapture_Start &lt;br&gt; with primary handle]\n    E --&gt;|RMF_SUCCESS| F[Call RMF_AudioCapture_Start &lt;br&gt; with auxiliary handle]\n    E --&gt;|Fail| E_Fail[Test case fail]\n    F --&gt;|RMF_SUCCESS| G[Capture audio for 10 seconds]\n    F --&gt;|Fail| F_Fail[Test case fail]\n    G --&gt; I[Call RMF_AudioCapture_Stop &lt;br&gt; for primary handle, &lt;br&gt; set cookie = 0]\n    I --&gt;|RMF_SUCCESS| J[Call RMF_AudioCapture_Stop &lt;br&gt; for auxiliary handle, &lt;br&gt; set cookie = 0]\n    I --&gt;|Fail| I_Fail[Test case fail]\n    J --&gt;|RMF_SUCCESS| K[Wait 1 second, &lt;br&gt; verify that cookies = 0]\n    J --&gt;|Fail| J_Fail[Test case fail]\n    K --&gt; |cookies = 0|L[Call RMF_AudioCapture_Close &lt;br&gt; for primary handle]\n    K --&gt; |cookies = 1| K_FAIL[Test case fail]\n    L --&gt;|RMF_SUCCESS| M[Call RMF_AudioCapture_Close &lt;br&gt; for auxiliary handle]\n    L --&gt;|Fail| L_Fail[Test case fail]\n    M --&gt;|Fail| M_Fail[Test case fail]\n    M --&gt;|RMF_SUCCESS| N{Total captured data\\nsize comparable to\\nestimated total for\\nprimary and auxiliary?}\n    N --&gt;|Yes| N1[Test case success]\n    N --&gt;|No| N2[Test case fail]</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/","title":"RMF Audio Capture L3 Low Level Test Specification and Procedure Documentation","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Overview</li> <li>References</li> <li>Audio Streams Requirement</li> <li>Level 3 Test Procedure</li> <li>Level 3 Python Test</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>API</code>    - Application Programming Interface</li> <li><code>L2</code>     - Level 2 Testing</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>NA</code>     - Not Applicable</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#overview","title":"Overview","text":"<p>This document describes the L3 Test Procedure for the RMF Audio Capture module.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#references","title":"References","text":"<ul> <li>RMF audio capture HAL Interface - rmfAudioCapture.h</li> <li>High Level Test Specification - rmf-audio-capture_High-Level_TestSpec.md</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#audio-streams-requirement","title":"Audio Streams Requirement","text":"# Stream Name Description 01 Sin_120s_48k_stereo.wav 120 seconds sin wave generated at 48kz, stereo file 02 Triangle_10s_480k_stereo.wav 10 seconds triangle wave generated at 48kz, stereo file"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#level-3-test-cases-high-level-overview","title":"Level 3 Test Cases High Level Overview","text":"<p>Below are top test use-case for the RMF audio capture. | #   | Test-case              | Description                                                                                                                                                                                                                    | HAL APIs                                                                                                                                 | Streams Number | | --- | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- | -------------- | | 1   | Primary data capture   | Play a reference stream, run primary audio capture, verify that captured audio is faithful to the source within margin of error                                                                                                | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1              | | 2   | Primary jitter test    | Play a reference stream, run primary audio capture, monitor jitter regularly                                                                                                                                                   | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1              | | 3   | Independent data check | Play reference streams simultaneously for primary and auxiliary captures, issue a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1,2            | | 4   | Auxiliary data capture | Play a reference stream, run auxiliary audio capture, verify that captured audio is faithful to the source within margin of error                                                                                              | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 2              | | 5   | Combined data capture  | Play reference streams simultaneously for primary and auxiliary captures, run primary and auxiliary audio captures, verify that captured audio is faithful to the source within margin of error                                | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1,2            | | 6   | Auxiliary jitter test  | Play a reference stream, run auxiliary audio capture, monitor jitter regularly                                                                                                                                                 | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 2              | | 7   | Combined jitter test   | Play reference streams simultaneously for primary and auxiliary captures, run primary and auxiliary audio captures, monitor jitter regularly                                                                                   | <code>RMF_AudioCapture_Open_Type, RMF_AudioCapture_GetDefaultSettings, RMF_AudioCapture_Start, RMF_AudioCapture_Stop, RMF_AudioCapture_Close</code> | 1,2            |</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#level-3-python-test-cases-high-level-overview","title":"Level 3 Python Test Cases High Level Overview","text":"<p>The class diagram below illustrates the flow of rmfAudio L3 Python test cases:</p> <pre><code>---\ntitle: rmfAudio - Python Class Flow\n---\nclassDiagram\n    testControl &lt;|-- ut_raft : inherits\n    class ut_raft{\n    }\n    ut_raft &lt;|-- rmfAudioHelperClass : inherits\n    rmfAudioHelperClass &lt;|-- L3_TestClasses : inherits\n    L3_TestClasses ..&gt; rmfAudio : uses\n    note for testControl \"uses rackConfig.yaml and deviceConfig.yaml\"\n    note for rmfAudio \"uses platformProfile.yaml\"\n    note for L3_TestClasses \"uses testSetupConfig.yaml\"\n    note for ut_raft \"suite Navigator uses testSuite.yaml\"</code></pre> <ul> <li>testControl</li> <li>Test Control Module for running rack Testing. This module configures the <code>DUT</code> based on the rack configuration file provided to the test.</li> <li>This class is defined in <code>RAFT</code> framework. For more details refer RAFT</li> <li>ut_raft</li> <li>Python based testing framework for writing engineering tests.</li> <li>It provides common functionalities like menu navigation, configuration reader, reading user response etc.</li> <li>For more details ut-raft.</li> <li>rmfAudio</li> <li>This is test helper class which communicates with the <code>L3</code> C/C++ test running on the <code>DUT</code> through menu</li> <li>L3_TestClasses</li> <li>These are the L3 test case classes</li> <li>Each class covers the each test use-case defined in L3 Test use-cases table</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_Low-Level_TestSpecification/#yaml-file-inputs","title":"YAML File Inputs","text":"<ul> <li>rackConfig.yaml</li> <li>Identifies the rack configuration and platform used</li> <li>References platform-specific config from <code>deviceConfig.yaml</code></li> <li> <p>For more details refer RAFT and example_rack_config.yml</p> </li> <li> <p>deviceConfig.yaml</p> </li> <li>Specifies overall configuration for the platform</li> <li>Can be overridden by:<ul> <li>Changing locally .yaml file directory</li> <li>Using --deviceConfig command line switch</li> </ul> </li> <li> <p>For more details refer RAFT and example_device_config.yml</p> </li> <li> <p>componentProfile.yaml/platformProfile.yaml</p> </li> <li>Contains component-specific configurations</li> <li>Contains platform wide configuration broken down into separate components</li> <li> <p>Example configuration file rmfAudioCaptureAuxSupported</p> </li> <li> <p>testSetupConfig.yaml</p> </li> <li>This configuration file contains the list of requirements for tests to execute. Eg: Copying the streams, setting environment variables etc.</li> <li> <p>Example configuration file rmfAudio_L3_testSetup.yml</p> </li> <li> <p>testConfig.yaml</p> </li> <li>This configuration file contains the list of menu items for C/C++ L3 test running on <code>DUT</code></li> <li>Example configuration file rmfAudio_testConfig.yml</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/","title":"RMF Audio Capture HAL L3 Python Test Procedure","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Acronyms, Terms and Abbreviations</li> <li>Setting Up Test Environment</li> <li>Streams Required</li> <li>Test Cases<ul> <li>rmfAudio_test01_primaryDataCapture.py</li> <li>rmfAudio_test02_primaryJitterTest.py</li> <li>rmfAudio_test03_independentDataCheck.py</li> <li>rmfAudio_test04_auxiliaryDataCapture.py</li> <li>rmfAudio_test05_combinedDataCapture.py</li> <li>rmfAudio_test06_auxiliaryJitterTest.py</li> <li>rmfAudio_test07_combinedJitterTest.py</li> <li>rmfAudio_L3_Runall.py</li> <li>rmfAudio_L3_Runall_primary.py</li> </ul> </li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acronyms-terms-and-abbreviations","title":"Acronyms, Terms and Abbreviations","text":"<ul> <li><code>HAL</code>    - Hardware Abstraction Layer</li> <li><code>L3</code>     - Level 3 Testing</li> <li><code>DUT</code>    - Device Under Test</li> <li><code>RAFT</code>   - Rapid Automation Framework for Testing</li> <li><code>YAML</code>   - YAML Ain't Markup Language</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#setting-up-test-environment","title":"Setting Up Test Environment","text":"<p>To execute <code>HAL</code> <code>L3</code> Python test cases, need a Python environment. Follow these steps mentioned in HPK Public Documentation</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#update-configuration-files","title":"Update Configuration Files","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rack-configuration-file","title":"Rack Configuration File","text":"<p>Example Rack configuration File: example_rack_config.yml</p> <p>For more details refer RAFT and example_rack_config.yml</p> <p>In this file, update the configuration to define the console sessions for the <code>DUT</code> and the outbound settings:</p> Console Session Description default Downloads the streams required for test cases ssh_player Plays the stream required for test case ssh_hal_test Executes the <code>HAL</code> binary for the test case <pre><code>rackConfig:\n  - dut:\n      ip: \"XXX.XXX.XXX.XXX\"  # IP Address of the device\n      description: \"stb device under test\"\n      platform: \"stb\"\n      consoles:\n        - default:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_player:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n        - ssh_hal_test:\n            type: \"ssh\"\n            port: 10022\n            username: \"root\"\n            ip: \"XXX.XXX.XXX\" # IP address of the device\n            password: ' '\n      outbound:\n        download_url: \"tftp://tftp-server.com/rack1/slot1/\"    # Download location for the CPE device\n        upload_url: \"sftp://server-address/home/workspace/tftp/rack1/slot1/\" # Upload location\n        upload_url_base_dir: \"sftp://server-address/home/workspace/tftp/rack1/slot1\"\n        httpProxy:   # Local proxy if required\n        workspaceDirectory: './logs/workspace'   # Local working directory\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#device-configuration-file","title":"Device Configuration File","text":"<p>Example Device configuration File: deviceConfig.yml</p> <p>For more details refer RAFT and example_device_config.yml</p> <p>Update below fileds in the device configuration file: - Set the folder path for <code>target_directory</code> where <code>HAL</code> binaries will be copied onto the device. - Specify the device profile path in <code>test/profile</code> - Update <code>streams_download_url</code> with the URL from which the streams will be downloaded - Ensure the <code>platform</code> should match with the <code>DUT</code> <code>platform</code> in Rack Configuration</p> <pre><code>deviceConfig:\n    cpe1:\n        platform: \"linux\"\n        model: \"uk\"\n        soc_vendor: \"intel\"\n        target_directory: \"/tmp/\"  # Target Directory on device\n        prompt: \"\" # Prompt string on console\n        test:\n            profile: \"../../../profiles/rmfAudioCaptureAuxSupported.yaml\"\n            streams_download_url: \"&lt;URL_Path&gt;\" #URL path from which the streams are downloaded to the device\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-setup-configuration-file","title":"Test Setup Configuration File","text":"<p>Example Test Setup configuration File: rmfAudio_L3_testSetup.yml</p> <p>Provide the streams for each test case. This path is appended with <code>streams_download_url</code> entry from Device Configuration File</p> <p>If a test case requires multiple streams or needs to be validated using several streams, ensure that all necessary streams are added sequentially for that specific test case.</p> <pre><code>rmfaudiocapture:\n  description: \"RMF Audio Capture test setup\"\n  assets:\n    device:\n      test01_primaryDataCapture:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_120s_48k_stereo.wav\"\n        streams:\n          - \"streams/Sin_120s_48k_stereo.wav\"\n      test02_primaryJitterTest:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_120s_48k_stereo.wav\"\n        streams:\n          - \"streams/Sin_120s_48k_stereo.wav\"\n      test03_independentDataCheck:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_PRIMARY=&lt;PATH on Device&gt;/Sin_10s_48k_stereo.wav\"\n          - \"export INPUT_AUXILIARY=&lt;PATH on Device&gt;/Triangle_10s_480k_stereo.wav\"\n        streams:\n          - \"streams/Sin_10s_48k_stereo.wav\"\n          - \"streams/Triangle_10s_480k_stereo.wav\"\n      test04_auxiliaryDataCapture:\n        postcmd:  #Setting this env. variable is required to run with mock implementation\n          - \"export INPUT_AUXILIARY=&lt;PATH on Device&gt;/Triangle_10s_480k_stereo.wav\"\n        streams: \n          - \"streams/Triangle_10s_480k_stereo.wav\"\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-configuration","title":"Test Configuration","text":"<p>Example Test Setup configuration File: rmfAudio_testConfig.yml</p> <p>Update the execute command according to the device path where <code>HAL</code> binaries are copied.</p> <pre><code>rmfaudiocapture:\n    description: \"RMF Audio Capture testing profile / menu system for UT\"\n    test:\n        artifacts:\n        #List of artifacts folders, test class copies the content of folder to the target device workspace\n          - \"../../../bin/\"\n        # exectute command, this will appended with the target device workspace path\n        execute: \"run.sh\"\n        type: UT-C # C (UT-C Cunit) / C++ (UT-G (g++ ut-core gtest backend))\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#run-test-cases","title":"Run Test Cases","text":"<p>Once the environment is set up, you can execute the test cases with the following command</p> <pre><code>python &lt;TestCaseName.py&gt; --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#streams-required","title":"Streams Required","text":"<p>Refer rmf-audio-capture_L3_Low-Level_TestSpecification.md for the stream details</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-cases","title":"Test Cases","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test01_primarydatacapturepy","title":"rmfAudio_test01_primaryDataCapture.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test01","title":"User Input Required - test01","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test01","title":"Acceptance Criteria - test01","text":"<p>Play Stream #1 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test01","title":"Expected Results - test01","text":"<p>The test plays a reference stream, captures audio data on primary capture interface and verifies that the captured data matches with reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on primary capture interface and written to a wav output file.</li> <li>Captured audio should match with played reference stream.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test01","title":"Test Steps - test01","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test01_primaryDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary capture interface data Verification:</p> <p>The test will play the designated audio stream and start audio capture on primary capture interface.</p> </li> <li> <p>The test will validate captured audio data with reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data through primary capture interface, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test02_primaryjittertestpy","title":"rmfAudio_test02_primaryJitterTest.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test02","title":"User Input Required - test02","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test02","title":"Acceptance Criteria - test02","text":"<p>Play Stream #1 and confirm that there is no jitter detected on primary capture interface.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test02","title":"Expected Results - test02","text":"<p>The test plays a reference stream, checks bytes of audio data received on primary capture interface and verifies there is no jitter detected on primary capture interface.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test02","title":"Test Steps - test02","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test02_primaryJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary capture jitter Verification:</p> <p>The test will play the designated audio stream and start monitoring bytes received on primary capture interface.</p> </li> <li> <p>The test will monitor bytes received on primary audio capture continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on primary data interface, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test03_independentdatacheckpy","title":"rmfAudio_test03_independentDataCheck.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test03","title":"User Input Required - test03","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test03","title":"Acceptance Criteria - test03","text":"<p>Play Stream #1 and Stream #2 and verify that primary and auxiliary data captures work independent of each other.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test03","title":"Expected Results - test03","text":"<p>The test plays a reference stream each on primary and auxiliary interfaces, then issues a series of start and stop calls in a mixed sequence that verifies that primary and audio capture sessions are truly independent of each other and free of side-effects when the other is started or stopped.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test03","title":"Test Steps - test03","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test03_independentDataCheck.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Independent data check Verification:</p> <p>The test will play the designated audio stream on both primary and auxiliary interfaces and start monitoring bytes received before and after each start and stop call.</p> </li> <li> <p>The test will check bytes received on primary and auxiliary audio capture during series of start and stop calls in a mixed sequence. </p> </li> <li>If bytes captured shows that the captures are independent of each other, the step is marked as PASS.</li> <li> <p>If bytes captured shows that the captures are dependent on each other, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream each on primary and auxiliary interfaces, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured shows that the captures are independent of each other</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test04_auxiliarydatacapturepy","title":"rmfAudio_test04_auxiliaryDataCapture.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test04","title":"User Input Required - test04","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test04","title":"Acceptance Criteria - test04","text":"<p>Play Stream #2 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test04","title":"Expected Results - test04","text":"<p>The test plays a reference stream, captures audio data on auxiliary capture interface and verifies that the captured data matches with reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on auxiliary capture interface and written to a wav output file.</li> <li>Captured audio should match with played reference stream.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test04","title":"Test Steps - test04","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test04_auxiliaryDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Auxiliary capture interface data Verification:</p> <p>The test will play the designated audio stream and start audio capture on auxiliary capture interface.</p> </li> <li> <p>The test will validate captured audio data with reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data through auxiliary capture interface, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test05_combineddatacapturepy","title":"rmfAudio_test05_combinedDataCapture.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test05","title":"User Input Required - test05","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test05","title":"Acceptance Criteria - test05","text":"<p>Play Stream #1 and Stream #2 and confirm that the captured audio matches with played reference stream.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test05","title":"Expected Results - test05","text":"<p>The test plays a reference stream, captures audio data on both primary and auxiliary capture interfaces and verifies that the captured data matches with corresponding reference stream.</p> <p>Success Criteria</p> <ul> <li>Audio data should be captured on primary and auxiliary capture interfaces simulataneously and written to a wav output file.</li> <li>Captured audio should match with corresponding played reference stream.</li> </ul>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test05","title":"Test Steps - test05","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test05_combinedDataCapture.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Combined audio capture data Verification:</p> <p>The test will play the designated audio streams and start audio capture simulataneously on primary and auxiliary capture interfaces.</p> </li> <li> <p>The test will validate captured audio data with corresponding reference audio stream with a given threshold.</p> </li> <li>If the files are a match within given threshold, the step is marked as PASS.</li> <li> <p>If the files are not a match within given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and result:</p> </li> </ul> <p>Upon playing a designated audio stream and capturing audio data simultaneously through primary and auxiliary capture interfaces, the test will conclude and present a final result: PASS or FAIL based on file comparison between capture audio data and played stream.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test06_auxiliaryjittertestpy","title":"rmfAudio_test06_auxiliaryJitterTest.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test06","title":"User Input Required - test06","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test06","title":"Acceptance Criteria - test06","text":"<p>Play Stream #2 and confirm that there is no jitter detected on auxiliary capture interface.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test06","title":"Expected Results - test06","text":"<p>The test plays a reference stream, checks bytes of audio data received on auxiliary capture interface and verifies there is no jitter detected on auxiliary capture interface.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test06","title":"Test Steps - test06","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test06_auxiliaryJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Auxiliary capture jitter Verification:</p> <p>The test will play the designated audio stream and start monitoring bytes received on auxiliary capture interface.</p> </li> <li> <p>The test will monitor bytes received on auxiliary capture continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on auxiliary capture interface, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_test07_combinedjittertestpy","title":"rmfAudio_test07_combinedJitterTest.py","text":""},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#user-input-required-test07","title":"User Input Required - test07","text":"<p>No</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#acceptance-criteria-test07","title":"Acceptance Criteria - test07","text":"<p>Play Stream #1 and Stream #2 and confirm that there is no jitter detected on primary and auxiliary capture interfaces.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#expected-results-test07","title":"Expected Results - test07","text":"<p>The test plays a reference stream, checks bytes of audio data received simulataneously on primary and auxiliary capture interface and verifies there is no jitter detected on both audio capture interfaces.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#test-steps-test07","title":"Test Steps - test07","text":"<ul> <li> <p>Run the Test:</p> </li> <li> <p>Select and run the Python script: <code>rmfAudio_test07_combinedJitterTest.py</code></p> </li> <li> <p>Download and Setup:</p> </li> </ul> <p>The test will automatically download all necessary artifacts and streams, and copy them to the target directory on the device.</p> <ul> <li> <p>Primary and auxiliary combined capture jitter Verification:</p> <p>The test will play the designated audio streams and start monitoring bytes received on primary and auxiliary capture interfaces.</p> </li> <li> <p>The test will monitor bytes received on primary and auxiliary audio captures continuously against a set threshold.</p> </li> <li>If bytes captured are greater than given threshold, the step is marked as PASS.</li> <li> <p>If bytes captured are less than given threshold, the step is marked as FAIL.</p> </li> <li> <p>Completion and Result:</p> </li> </ul> <p>Upon playing a designated audio stream and monitoring bytes received on primary and auxiliary capture interfaces, the test will conclude and present a final result: PASS or FAIL based on whether bytes captured were within a given threshold.</p>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_l3_runallpy","title":"rmfAudio_L3_Runall.py","text":"<p>This python file runs all the tests</p> <pre><code>python rmfAudio_L3_Runall.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"},{"location":"rmf_audio_capture_test/docs/pages/rmf-audio-capture_L3_TestProcedure/#rmfaudio_l3_runall_primarypy","title":"rmfAudio_L3_Runall_primary.py","text":"<p>This python file runs all the tests for primary audio capture</p> <pre><code>python rmfAudio_L3_Runall_primary.py --config &lt;/PATH&gt;/ut/host/tests/configs/example_rack_config.yml --deviceConfig &lt;/PATH&gt;/ut/host/tests/configs/deviceConfig.yml\n</code></pre>"}]}